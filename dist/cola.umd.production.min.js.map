{"version":3,"file":"cola.umd.production.min.js","sources":["../src/powergraph.ts","../src/linklengths.ts","../src/descent.ts","../src/vpsc.ts","../src/rbtree.ts","../src/rectangle.ts","../src/pqueue.ts","../src/shortestpaths.ts","../src/geom.ts","../src/handledisconnected.ts","../src/layout.ts","../src/adaptor.ts","../src/d3v3adaptor.ts","../src/d3v4adaptor.ts","../src/gridrouter.ts","../src/layout3d.ts","../src/d3adaptor.ts","../src/batch.ts"],"sourcesContent":["import {LinkAccessor} from './linklengths'\n\nexport interface LinkTypeAccessor<Link> extends LinkAccessor<Link> {\n        // return a unique identifier for the type of the link\n        getType(l: Link): number;\n    }\n\n    export class PowerEdge {\n        constructor(\n            public source: any,\n            public target: any,\n            public type: number) { }\n    }\n\n    export class Configuration<Link> {\n        // canonical list of modules.\n        // Initialized to a module for each leaf node, such that the ids and indexes of the module in the array match the indexes of the nodes in links\n        // Modules created through merges are appended to the end of this.\n        modules: Module[];\n        // top level modules and candidates for merges\n        roots: ModuleSet[];\n        // remaining edge count\n        R: number;\n        constructor(n: number, edges: Link[], private linkAccessor: LinkTypeAccessor<Link>, rootGroup?: any[]) {\n            this.modules = new Array(n);\n            this.roots = [];\n            if (rootGroup) {\n                this.initModulesFromGroup(rootGroup);\n            } else {\n                this.roots.push(new ModuleSet());\n                for (var i = 0; i < n; ++i)\n                    this.roots[0].add(this.modules[i] = new Module(i));\n            }\n            this.R = edges.length;\n            edges.forEach(e => {\n                var s = this.modules[linkAccessor.getSourceIndex(e)],\n                    t = this.modules[linkAccessor.getTargetIndex(e)],\n                    type = linkAccessor.getType(e);\n                s.outgoing.add(type, t);\n                t.incoming.add(type, s);\n            });\n        }\n\n        private initModulesFromGroup(group): ModuleSet {\n            var moduleSet = new ModuleSet();\n            this.roots.push(moduleSet);\n            for (var i = 0; i < group.leaves.length; ++i) {\n                var node = group.leaves[i];\n                var module = new Module(node.id);\n                this.modules[node.id] = module;\n                moduleSet.add(module);\n            }\n            if (group.groups) {\n                for (var j = 0; j < group.groups.length; ++j) {\n                    var child = group.groups[j];\n                    // Propagate group properties (like padding, stiffness, ...) as module definition so that the generated power graph group will inherit it\n                    var definition = {};\n                    for (var prop in child)\n                        if (prop !== \"leaves\" && prop !== \"groups\" && child.hasOwnProperty(prop))\n                            definition[prop] = child[prop];\n                    // Use negative module id to avoid clashes between predefined and generated modules\n                    moduleSet.add(new Module(-1-j, new LinkSets(), new LinkSets(), this.initModulesFromGroup(child), definition));\n                }\n            }\n            return moduleSet;\n         }\n\n        // merge modules a and b keeping track of their power edges and removing the from roots\n        merge(a: Module, b: Module, k: number = 0): Module {\n            var inInt = a.incoming.intersection(b.incoming),\n                outInt = a.outgoing.intersection(b.outgoing);\n            var children = new ModuleSet();\n            children.add(a);\n            children.add(b);\n            var m = new Module(this.modules.length, outInt, inInt, children);\n            this.modules.push(m);\n            var update = (s: LinkSets, i: string, o: string) => {\n                s.forAll((ms, linktype) => {\n                    ms.forAll(n => {\n                        var nls = <LinkSets>n[i];\n                        nls.add(linktype, m);\n                        nls.remove(linktype, a);\n                        nls.remove(linktype, b);\n                        (<LinkSets>a[o]).remove(linktype, n);\n                        (<LinkSets>b[o]).remove(linktype, n);\n                    });\n                });\n            };\n            update(outInt, \"incoming\", \"outgoing\");\n            update(inInt, \"outgoing\", \"incoming\");\n            this.R -= inInt.count() + outInt.count();\n            this.roots[k].remove(a);\n            this.roots[k].remove(b);\n            this.roots[k].add(m);\n            return m;\n        }\n\n        private rootMerges(k: number = 0): {\n            id: number;\n            nEdges: number;\n            a: Module;\n            b: Module;\n        }[] {\n            var rs = this.roots[k].modules();\n            var n = rs.length;\n            var merges = new Array(n * (n - 1));\n            var ctr = 0;\n            for (var i = 0, i_ = n - 1; i < i_; ++i) {\n                for (var j = i+1; j < n; ++j) {\n                    var a = rs[i], b = rs[j];\n                    merges[ctr] = { id: ctr, nEdges: this.nEdges(a, b), a: a, b: b };\n                    ctr++;\n                }\n            }\n            return merges;\n        }\n\n        greedyMerge(): boolean {\n            for (var i = 0; i < this.roots.length; ++i) {\n                // Handle single nested module case\n                if (this.roots[i].modules().length < 2) continue;\n\n                // find the merge that allows for the most edges to be removed.  secondary ordering based on arbitrary id (for predictability)\n                var ms = this.rootMerges(i).sort((a, b) => a.nEdges == b.nEdges ? a.id - b.id : a.nEdges - b.nEdges);\n                var m = ms[0];\n                if (m.nEdges >= this.R) continue;\n                this.merge(m.a, m.b, i);\n                return true;\n            }\n        }\n\n        private nEdges(a: Module, b: Module): number {\n            var inInt = a.incoming.intersection(b.incoming),\n                outInt = a.outgoing.intersection(b.outgoing);\n            return this.R - inInt.count() - outInt.count();\n        }\n\n        getGroupHierarchy(retargetedEdges: PowerEdge[]): any[]{\n            var groups = [];\n            var root = {};\n            toGroups(this.roots[0], root, groups);\n            var es = this.allEdges();\n            es.forEach(e => {\n                var a = this.modules[e.source];\n                var b = this.modules[e.target];\n                retargetedEdges.push(new PowerEdge(\n                    typeof a.gid === \"undefined\" ? e.source : groups[a.gid],\n                    typeof b.gid === \"undefined\" ? e.target : groups[b.gid],\n                    e.type\n                ));\n            });\n            return groups;\n        }\n\n        allEdges(): PowerEdge[] {\n            var es = [];\n            Configuration.getEdges(this.roots[0], es);\n            return es;\n        }\n\n        static getEdges(modules: ModuleSet, es: PowerEdge[]) {\n            modules.forAll(m => {\n                m.getEdges(es);\n                Configuration.getEdges(m.children, es);\n            });\n        }\n    }\n\n    function toGroups(modules: ModuleSet, group, groups) {\n        modules.forAll(m => {\n            if (m.isLeaf()) {\n                if (!group.leaves) group.leaves = [];\n                group.leaves.push(m.id);\n            } else {\n                var g = group;\n                m.gid = groups.length;\n                if (!m.isIsland() || m.isPredefined()) {\n                    g = { id: m.gid };\n                    if (m.isPredefined())\n                        // Apply original group properties\n                        for (var prop in m.definition)\n                            g[prop] = m.definition[prop];\n                    if (!group.groups) group.groups = [];\n                    group.groups.push(m.gid);\n                    groups.push(g);\n                }\n                toGroups(m.children, g, groups);\n            }\n        });\n    }\n\n    export class Module {\n        gid: number;\n\n        constructor(\n            public id: number,\n            public outgoing: LinkSets = new LinkSets(),\n            public incoming: LinkSets = new LinkSets(),\n            public children: ModuleSet = new ModuleSet(),\n            public definition?: any) { }\n\n        getEdges(es: PowerEdge[]) {\n            this.outgoing.forAll((ms, edgetype) => {\n                ms.forAll(target => {\n                    es.push(new PowerEdge(this.id, target.id, edgetype));\n                });\n            });\n        }\n\n        isLeaf() {\n            return this.children.count() === 0;\n        }\n\n        isIsland() {\n            return this.outgoing.count() === 0 && this.incoming.count() === 0;\n        }\n\n        isPredefined(): boolean {\n            return typeof this.definition !== \"undefined\";\n        }\n    }\n\n    function intersection(m: any, n: any): any {\n        var i = {};\n        for (var v in m) if (v in n) i[v] = m[v];\n        return i;\n    }\n\n    export class ModuleSet {\n        table: any = {};\n        count() {\n            return Object.keys(this.table).length;\n        }\n        intersection(other: ModuleSet): ModuleSet {\n            var result = new ModuleSet();\n            result.table = intersection(this.table, other.table);\n            return result;\n        }\n        intersectionCount(other: ModuleSet): number {\n            return this.intersection(other).count();\n        }\n        contains(id: number): boolean {\n            return id in this.table;\n        }\n        add(m: Module): void {\n            this.table[m.id] = m;\n        }\n        remove(m: Module): void {\n            delete this.table[m.id];\n        }\n        forAll(f: (m: Module) => void) {\n            for (var mid in this.table) {\n                f(this.table[mid]);\n            }\n        }\n        modules(): Module[] {\n            var vs = [];\n            this.forAll(m => {\n                if (!m.isPredefined())\n                    vs.push(m);\n            });\n            return vs;\n        }\n    }\n\n    export class LinkSets {\n        sets: any = {};\n        n: number = 0;\n        count(): number {\n            return this.n;\n        }\n        contains(id: number) {\n            var result = false;\n            this.forAllModules(m => {\n                if (!result && m.id == id) {\n                    result = true;\n                }\n            });\n            return result;\n        }\n        add(linktype: number, m: Module) {\n            var s: ModuleSet = linktype in this.sets ? this.sets[linktype] : this.sets[linktype] = new ModuleSet();\n            s.add(m);\n            ++this.n;\n        }\n        remove(linktype: number, m: Module) {\n            var ms = <ModuleSet>this.sets[linktype];\n            ms.remove(m);\n            if (ms.count() === 0) {\n                delete this.sets[linktype];\n            }\n            --this.n;\n        }\n        forAll(f: (ms: ModuleSet, linktype: number) => void) {\n            for (var linktype in this.sets) {\n                f(<ModuleSet>this.sets[linktype], Number(linktype));\n            }\n        }\n        forAllModules(f: (m: Module) => void) {\n            this.forAll((ms, lt) => ms.forAll(f));\n        }\n        intersection(other: LinkSets): LinkSets {\n            var result: LinkSets = new LinkSets();\n            this.forAll((ms, lt) => {\n                if (lt in other.sets) {\n                    var i = ms.intersection(other.sets[lt]),\n                        n = i.count();\n                    if (n > 0) {\n                        result.sets[lt] = i;\n                        result.n += n;\n                    }\n                }\n            });\n            return result;\n        }\n    }\n\n    function intersectionCount(m: any, n: any): number {\n        return Object.keys(intersection(m, n)).length\n    }\n\n    export function getGroups<Link>(nodes: any[], links: Link[], la: LinkTypeAccessor<Link>, rootGroup?: any[]): { groups: any[]; powerEdges: PowerEdge[] } {\n        var n = nodes.length,\n            c = new Configuration(n, links, la, rootGroup);\n        while (c.greedyMerge());\n        var powerEdges: PowerEdge[] = [];\n        var g = c.getGroupHierarchy(powerEdges);\n        powerEdges.forEach(function (e) {\n            var f = (end) => {\n                var g = e[end];\n                if (typeof g == \"number\") e[end] = nodes[g];\n            };\n            f(\"source\");\n            f(\"target\");\n        });\n        return { groups: g, powerEdges: powerEdges };\n    }\n","    export interface LinkAccessor<Link> {\n        getSourceIndex(l: Link): number;\n        getTargetIndex(l: Link): number;\n    }\n\n    export interface LinkLengthAccessor<Link> extends LinkAccessor<Link> {\n        setLength(l: Link, value: number): void;\n    }\n\n    // compute the size of the union of two sets a and b\n    function unionCount(a: any, b: any): number {\n        var u = {};\n        for (var i in a) u[i] = {};\n        for (var i in b) u[i] = {};\n        return Object.keys(u).length;\n    }\n\n    // compute the size of the intersection of two sets a and b\n    function intersectionCount(a: number[], b: number[]): number {\n        var n = 0;\n        for (var i in a) if (typeof b[i] !== 'undefined') ++n;\n        return n;\n    }\n\n    function getNeighbours<Link>(links: Link[], la: LinkAccessor<Link>): any {\n        var neighbours = {};\n        var addNeighbours = (u, v) => {\n            if (typeof neighbours[u] === 'undefined')\n                neighbours[u] = {};\n            neighbours[u][v] = {};\n        };\n        links.forEach(e => {\n            var u = la.getSourceIndex(e), v = la.getTargetIndex(e);\n            addNeighbours(u, v);\n            addNeighbours(v, u);\n        });\n        return neighbours;\n    }\n\n    // modify the lengths of the specified links by the result of function f weighted by w\n    function computeLinkLengths<Link>(links: Link[], w: number, f: (a: any, b: any) => number, la: LinkLengthAccessor<Link>) {\n        var neighbours = getNeighbours(links, la);\n        links.forEach(l => {\n            var a = neighbours[la.getSourceIndex(l)];\n            var b = neighbours[la.getTargetIndex(l)];\n            la.setLength(l, 1 + w * f(a, b));\n        });\n    }\n\n    /** modify the specified link lengths based on the symmetric difference of their neighbours\n     * @class symmetricDiffLinkLengths\n     */\n    export function symmetricDiffLinkLengths<Link>(links: Link[], la: LinkLengthAccessor<Link>, w: number = 1) {\n        computeLinkLengths(links, w, (a, b) => Math.sqrt(unionCount(a, b) - intersectionCount(a, b)), la);\n    }\n\n    /** modify the specified links lengths based on the jaccard difference between their neighbours\n     * @class jaccardLinkLengths\n     */\n    export function jaccardLinkLengths<Link>(links: Link[], la: LinkLengthAccessor<Link>, w: number = 1) {\n        computeLinkLengths(links, w, (a, b) =>\n            Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b)\n            , la);\n    }\n\n    export interface IConstraint {\n        left: number;\n        right: number;\n        gap: number;\n    }\n\n    export interface DirectedEdgeConstraints {\n        axis: string;\n        gap: number;\n    }\n\n    export interface LinkSepAccessor<Link> extends LinkAccessor<Link> {\n        getMinSeparation(l: Link): number;\n    }\n\n    /** generate separation constraints for all edges unless both their source and sink are in the same strongly connected component\n     * @class generateDirectedEdgeConstraints\n     */\n    export function generateDirectedEdgeConstraints<Link>(n: number, links: Link[], axis: string,\n        la: LinkSepAccessor<Link>): IConstraint[]\n    {\n        var components = stronglyConnectedComponents(n, links, la);\n        var nodes = {};\n        components.forEach((c,i) =>\n            c.forEach(v => nodes[v] = i)\n        );\n        var constraints: any[] = [];\n        links.forEach(l => {\n            var ui = la.getSourceIndex(l), vi = la.getTargetIndex(l),\n                u = nodes[ui], v = nodes[vi];\n            if (u !== v) {\n                constraints.push({\n                    axis: axis,\n                    left: ui,\n                    right: vi,\n                    gap: la.getMinSeparation(l)\n                });\n            }\n        });\n        return constraints;\n    }\n\n    /**\n     * Tarjan's strongly connected components algorithm for directed graphs\n     * returns an array of arrays of node indicies in each of the strongly connected components.\n     * a vertex not in a SCC of two or more nodes is it's own SCC.\n     * adaptation of https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n     */\n    export function stronglyConnectedComponents<Link>(numVertices: number, edges: Link[], la: LinkAccessor<Link>): number[][]{\n        var nodes = [];\n        var index = 0;\n        var stack = [];\n        var components = [];\n        function strongConnect(v) {\n            // Set the depth index for v to the smallest unused index\n            v.index = v.lowlink = index++;\n            stack.push(v);\n            v.onStack = true;\n\n            // Consider successors of v\n            for (var w of v.out) {\n                if (typeof w.index === 'undefined') {\n                    // Successor w has not yet been visited; recurse on it\n                    strongConnect(w);\n                    v.lowlink = Math.min(v.lowlink, w.lowlink);\n                } else if (w.onStack) {\n                    // Successor w is in stack S and hence in the current SCC\n                    v.lowlink = Math.min(v.lowlink, w.index);\n                }\n            }\n\n            // If v is a root node, pop the stack and generate an SCC\n            if (v.lowlink === v.index) {\n                // start a new strongly connected component\n                var component = [];\n                while (stack.length) {\n                    w = stack.pop();\n                    w.onStack = false;\n                    //add w to current strongly connected component\n                    component.push(w);\n                    if (w === v) break;\n                }\n                // output the current strongly connected component\n                components.push(component.map(v => v.id));\n            }\n        }\n        for (var i = 0; i < numVertices; i++) {\n            nodes.push({id: i, out: []});\n        }\n        for (var e of edges) {\n            let v = nodes[la.getSourceIndex(e)],\n                w = nodes[la.getTargetIndex(e)];\n            v.out.push(w);\n        }\n        for (var v of nodes) if (typeof v.index === 'undefined') strongConnect(v);\n        return components;\n    }\n","    import { Node } from './layout'\n    \n    /**\n     * Descent respects a collection of locks over nodes that should not move\n     * @class Locks\n     */\n    export class Locks {\n        locks: { [key:number]:number[]} = {};\n        /**\n         * add a lock on the node at index id\n         * @method add\n         * @param id index of node to be locked\n         * @param x required position for node\n         */\n        add(id: number, x: number[]) {\n/* DEBUG\n            if (isNaN(x[0]) || isNaN(x[1])) debugger;\nDEBUG */\n            this.locks[id] = x;\n        }\n        /**\n         * @method clear clear all locks\n         */\n        clear() {\n            this.locks = {};\n        }\n        /**\n         * @isEmpty\n         * @returns false if no locks exist\n         */\n        isEmpty(): boolean {\n            for (var l in this.locks) return false;\n            return true;\n        }\n        /**\n         * perform an operation on each lock\n         * @apply\n         */\n        apply(f: (id: number, x: number[]) => void) {\n            for (var l in this.locks) {\n                f(Number(l), this.locks[l]);\n            }\n        }\n    }\n\n    /**\n     * Uses a gradient descent approach to reduce a stress or p-stress goal function over a graph with specified ideal edge lengths or a square matrix of dissimilarities.\n     * The standard stress function over a graph nodes with position vectors x,y,z is (mathematica input):\n     *   stress[x_,y_,z_,D_,w_]:=Sum[w[[i,j]] (length[x[[i]],y[[i]],z[[i]],x[[j]],y[[j]],z[[j]]]-d[[i,j]])^2,{i,Length[x]-1},{j,i+1,Length[x]}]\n     * where: D is a square matrix of ideal separations between nodes, w is matrix of weights for those separations\n     *        length[x1_, y1_, z1_, x2_, y2_, z2_] = Sqrt[(x1 - x2)^2 + (y1 - y2)^2 + (z1 - z2)^2]\n     * below, we use wij = 1/(Dij^2)\n     *\n     * @class Descent\n     */\n    export class Descent {\n        public threshold: number = 0.0001;\n        /** Hessian Matrix\n         * @property H {number[][][]}\n         */\n        public H: number[][][];\n        /** gradient vector\n         * @property G {number[][]}\n         */\n        public g: number[][];\n        /** positions vector\n         * @property x {number[][]}\n         */\n        public x: number[][];\n        /**\n         * @property k {number} dimensionality\n         */\n        public k: number;\n        /**\n         * number of data-points / nodes / size of vectors/matrices\n         * @property n {number}\n         */\n        public n: number;\n\n        public locks: Locks;\n\n        private static zeroDistance: number = 1e-10;\n        private minD: number;\n\n        // pool of arrays of size n used internally, allocated in constructor\n        private Hd: number[][];\n        private a: number[][];\n        private b: number[][];\n        private c: number[][];\n        private d: number[][];\n        private e: number[][];\n        private ia: number[][];\n        private ib: number[][];\n        private xtmp: number[][];\n\n\n        // Parameters for grid snap stress.\n        // TODO: Make a pluggable \"StressTerm\" class instead of this\n        // mess.\n        public numGridSnapNodes: number = 0;\n        public snapGridSize: number = 100;\n        public snapStrength: number = 1000;\n        public scaleSnapByMaxH: boolean = false;\n\n        private random = new PseudoRandom();\n\n        public project: { (x0: number[], y0: number[], r: number[]): void }[] = null;\n\n        _nodes: Node[]\n\n        /** The dimension distance calculation (defaults to x[i][u]-x[i][v])\n         * @property dimensionDistance{(number[][], number, number, number) => number}\n         * Can be replaced with a custom function.\n         * For example replacing with (x, i, u, v) => i==0 ? (x[i][u]-x[i][v])/4 : x[i][u]-x[i][v];\n         * has the effect of making horizontal distances larger than vertical\n         * distances.\n         */\n        public static dimensionDistance(\n            x: number[][],\n            i: number,\n            u: number,\n            v: number,\n            nodes: Node[],\n        ): number {\n            //const original = x[i][u] - x[i][v]\n            let dx = x[i][u] - x[i][v]\n            const dedge =\n            i == 0\n                ? ((nodes[u]?.width || 0) + (nodes[v]?.width || 0)) / 2\n                : ((nodes[u]?.height || 0) + (nodes[v]?.height || 0)) / 2\n            if (dx > dedge) {\n            dx -= dedge\n            } else if (dx < -dedge) {\n            dx += dedge\n            } else if (dx != 0) {\n            dx /= 10\n            }\n            //console.log(\"DD\", i, u, v, original, dedge, dx)\n            return dx\n        }\n\n        /**\n         * @method constructor\n         * @param x {number[][]} initial coordinates for nodes\n         * @param D {number[][]} matrix of desired distances between pairs of nodes\n         * @param G {number[][]} [default=null] if specified, G is a matrix of weights for goal terms between pairs of nodes.\n         * If G[i][j] > 1 and the separation between nodes i and j is greater than their ideal distance, then there is no contribution for this pair to the goal\n         * If G[i][j] <= 1 then it is used as a weighting on the contribution of the variance between ideal and actual separation between i and j to the goal function\n         */\n        constructor(x: number[][], public D: number[][], public G: number[][]= null, nodes: Node[] = []) {\n            this._nodes = nodes\n            this.x = x;\n            this.k = x.length; // dimensionality\n            var n = this.n = x[0].length; // number of nodes\n            this.H = new Array(this.k);\n            this.g = new Array(this.k);\n            this.Hd = new Array(this.k);\n            this.a = new Array(this.k);\n            this.b = new Array(this.k);\n            this.c = new Array(this.k);\n            this.d = new Array(this.k);\n            this.e = new Array(this.k);\n            this.ia = new Array(this.k);\n            this.ib = new Array(this.k);\n            this.xtmp = new Array(this.k);\n            this.locks = new Locks();\n            this.minD = Number.MAX_VALUE;\n            var i = n, j;\n            while (i--) {\n                j = n;\n                while (--j > i) {\n                    var d = D[i][j];\n                    if (d > 0 && d < this.minD) {\n                        this.minD = d;\n                    }\n                }\n            }\n            if (this.minD === Number.MAX_VALUE) this.minD = 1;\n            i = this.k;\n            while (i--) {\n                this.g[i] = new Array(n);\n                this.H[i] = new Array(n);\n                j = n;\n                while (j--) {\n                    this.H[i][j] = new Array(n);\n                }\n                this.Hd[i] = new Array(n);\n                this.a[i] = new Array(n);\n                this.b[i] = new Array(n);\n                this.c[i] = new Array(n);\n                this.d[i] = new Array(n);\n                this.e[i] = new Array(n);\n                this.ia[i] = new Array(n);\n                this.ib[i] = new Array(n);\n                this.xtmp[i] = new Array(n);\n            }\n        }\n\n        public static createSquareMatrix(n: number, f: (i: number, j: number) => number): number[][] {\n            var M = new Array(n);\n            for (var i = 0; i < n; ++i) {\n                M[i] = new Array(n);\n                for (var j = 0; j < n; ++j) {\n                    M[i][j] = f(i, j);\n                }\n            }\n            return M;\n        }\n\n        private offsetDir(): number[] {\n            var u = new Array(this.k);\n            var l = 0;\n            for (var i = 0; i < this.k; ++i) {\n                var x = u[i] = this.random.getNextBetween(0.01, 1) - 0.5;\n                l += x * x;\n            }\n            l = Math.sqrt(l);\n            return u.map(x=> x *= this.minD / l);\n        }\n\n        // compute first and second derivative information storing results in this.g and this.H\n        public computeDerivatives(x: number[][]) {\n            const n = this.n;\n            if (n < 1) return;\n            let i: number;\n/* DEBUG\n            for (var u: number = 0; u < n; ++u)\n                for (i = 0; i < this.k; ++i)\n                    if (isNaN(x[i][u])) debugger;\nDEBUG */\n\n            let d = new Array<number>(this.k); // distance vector\n            let d2 = new Array<number>(this.k); // distance vector squared\n            let Huu = new Array<number>(this.k); // Hessian diagonal\n            let maxH = 0; // max Hessian matrix entry\n\n            // across all nodes u\n            for (let u = 0; u < n; ++u) {\n                // zero gradient and hessian diagonals\n                for (i = 0; i < this.k; ++i) Huu[i] = this.g[i][u] = 0;\n\n                // across all nodes v\n                for (let v = 0; v < n; ++v) {\n                    if (u === v) continue;\n\n                    // The following loop computes distance vector and\n                    // randomly displaces nodes that are at identical positions\n                    let maxDisplaces = n; // avoid infinite loop in the case of numerical issues, such as huge values\n                    let distanceSquared = 0;\n                    while (maxDisplaces--) {\n                        distanceSquared = 0;\n                        for (i = 0; i < this.k; ++i) {\n                            //const dx = d[i] = x[i][u] - x[i][v];\n                            const dx = (d[i] = Descent.dimensionDistance(\n                                x,\n                                i,\n                                u,\n                                v,\n                                this._nodes,\n                              ))\n                            distanceSquared += d2[i] = dx * dx;\n                        }\n                        if (distanceSquared > 1e-9) break;\n                        const rd = this.offsetDir();\n                        for (i = 0; i < this.k; ++i) x[i][v] += rd[i];\n                    }\n                    const distance = Math.sqrt(distanceSquared);\n                    const idealDistance = this.D[u][v];\n                    // weights are passed via G matrix.\n                    // weight > 1 means not immediately connected\n                    // small weights (<<1) are used for group dummy nodes\n                    let weight = this.G != null ? this.G[u][v] : 1;\n\n                    // ignore long range attractions for nodes not immediately connected (P-stress)\n                    if (weight > 1 && distance > idealDistance || !isFinite(idealDistance)) {\n                        for (i = 0; i < this.k; ++i) this.H[i][u][v] = 0;\n                        continue;\n                    }\n                    // weight > 1 was just an indicator - this is an arcane interface,\n                    // but we are trying to be economical storing and passing node pair info\n                    if (weight > 1) {\n                        weight = 1;\n                    }\n                    const idealDistSquared = idealDistance * idealDistance,\n                        gs = 2 * weight * (distance - idealDistance) / (idealDistSquared * distance),\n                        distanceCubed = distanceSquared * distance,\n                        hs = 2 * -weight / (idealDistSquared * distanceCubed);\n                    if (!isFinite(gs))\n                        console.log(gs);\n                    for (i = 0; i < this.k; ++i) {\n                        this.g[i][u] += d[i] * gs;\n                        Huu[i] -= this.H[i][u][v] = hs * (2 * distanceCubed + idealDistance * (d2[i] - distanceSquared));\n                    }\n                }\n                for (i = 0; i < this.k; ++i) maxH = Math.max(maxH, this.H[i][u][u] = Huu[i]);\n            }\n            // Grid snap forces\n            var r = this.snapGridSize/2;\n            var g = this.snapGridSize;\n            var w = this.snapStrength;\n            var k = w / (r * r);\n            var numNodes = this.numGridSnapNodes;\n            //var numNodes = n;\n            for (var u: number = 0; u < numNodes; ++u) {\n                for (i = 0; i < this.k; ++i) {\n                    var xiu = this.x[i][u];\n                    var m = xiu / g;\n                    var f = m % 1;\n                    var q = m - f;\n                    var a = Math.abs(f);\n                    var dx = (a <= 0.5) ? xiu - q * g :\n                        (xiu > 0) ? xiu - (q + 1) * g : xiu - (q - 1) * g;\n                    if (-r < dx && dx <= r) {\n                        if (this.scaleSnapByMaxH) {\n                            this.g[i][u] += maxH * k * dx;\n                            this.H[i][u][u] += maxH * k;\n                        } else {\n                            this.g[i][u] += k * dx;\n                            this.H[i][u][u] += k;\n                        }\n                    }\n                }\n            }\n            if (!this.locks.isEmpty()) {\n                this.locks.apply((u, p) => {\n                    for (i = 0; i < this.k; ++i) {\n                        this.H[i][u][u] += maxH;\n                        this.g[i][u] -= maxH * (p[i] - x[i][u]);\n                    }\n                });\n            }\n/* DEBUG\n            for (var u: number = 0; u < n; ++u)\n                for (i = 0; i < this.k; ++i) {\n                    if (isNaN(this.g[i][u])) debugger;\n                    for (var v: number = 0; v < n; ++v)\n                        if (isNaN(this.H[i][u][v])) debugger;\n                }\nDEBUG */\n        }\n\n        private static dotProd(a: number[], b: number[]): number {\n            var x = 0, i = a.length;\n            while (i--) x += a[i] * b[i];\n            return x;\n        }\n\n        // result r = matrix m * vector v\n        private static rightMultiply(m: number[][], v: number[], r: number[]) {\n            var i = m.length;\n            while (i--) r[i] = Descent.dotProd(m[i], v);\n        }\n\n        // computes the optimal step size to take in direction d using the\n        // derivative information in this.g and this.H\n        // returns the scalar multiplier to apply to d to get the optimal step\n        public computeStepSize(d: number[][]): number {\n            var numerator = 0, denominator = 0;\n            for (var i = 0; i < this.k; ++i) {\n                numerator += Descent.dotProd(this.g[i], d[i]);\n                Descent.rightMultiply(this.H[i], d[i], this.Hd[i]);\n                denominator += Descent.dotProd(d[i], this.Hd[i]);\n            }\n            if (denominator === 0 || !isFinite(denominator)) return 0;\n            return 1 * numerator / denominator;\n        }\n\n        public reduceStress(): number {\n            this.computeDerivatives(this.x);\n            var alpha = this.computeStepSize(this.g);\n            for (var i = 0; i < this.k; ++i) {\n                this.takeDescentStep(this.x[i], this.g[i], alpha);\n            }\n            return this.computeStress();\n        }\n\n        private static copy(a: number[][], b: number[][]): void {\n            var m = a.length, n = b[0].length;\n            for (var i = 0; i < m; ++i) {\n                for (var j = 0; j < n; ++j) {\n                    b[i][j] = a[i][j];\n                }\n            }\n        }\n\n        // takes a step of stepSize * d from x0, and then project against any constraints.\n        // result is returned in r.\n        // x0: starting positions\n        // r: result positions will be returned here\n        // d: unconstrained descent vector\n        // stepSize: amount to step along d\n        private stepAndProject(x0: number[][], r: number[][], d: number[][], stepSize: number): void {\n            Descent.copy(x0, r);\n            this.takeDescentStep(r[0], d[0], stepSize);\n            if (this.project) this.project[0](x0[0], x0[1], r[0]);\n            this.takeDescentStep(r[1], d[1], stepSize);\n            if (this.project) this.project[1](r[0], x0[1], r[1]);\n\n            // todo: allow projection against constraints in higher dimensions\n            for (var i = 2; i < this.k; i++)\n                this.takeDescentStep(r[i], d[i], stepSize);\n\n            // the following makes locks extra sticky... but hides the result of the projection from the consumer\n            //if (!this.locks.isEmpty()) {\n            //    this.locks.apply((u, p) => {\n            //        for (var i = 0; i < this.k; i++) {\n            //            r[i][u] = p[i];\n            //        }\n            //    });\n            //}\n        }\n\n        private static mApply(m: number, n: number, f: (i: number, j: number) => any) {\n            var i = m; while (i-- > 0) {\n                var j = n; while (j-- > 0) f(i, j);\n            }\n        }\n        private matrixApply(f: (i: number, j: number) => any) {\n            Descent.mApply(this.k, this.n, f);\n        }\n\n        private computeNextPosition(x0: number[][], r: number[][]): void {\n            this.computeDerivatives(x0);\n            var alpha = this.computeStepSize(this.g);\n            this.stepAndProject(x0, r, this.g, alpha);\n/* DEBUG\n            for (var u: number = 0; u < this.n; ++u)\n                for (var i = 0; i < this.k; ++i)\n                    if (isNaN(r[i][u])) debugger;\nDEBUG */\n            if (this.project) {\n                this.matrixApply((i, j) => this.e[i][j] = x0[i][j] - r[i][j]);\n                var beta = this.computeStepSize(this.e);\n                beta = Math.max(0.2, Math.min(beta, 1));\n                this.stepAndProject(x0, r, this.e, beta);\n            }\n        }\n\n        public run(iterations: number): number {\n            var stress = Number.MAX_VALUE, converged = false;\n            while (!converged && iterations-- > 0) {\n                var s = this.rungeKutta();\n                converged = Math.abs(stress / s - 1) < this.threshold;\n                stress = s;\n            }\n            return stress;\n        }\n\n        public rungeKutta(): number {\n            this.computeNextPosition(this.x, this.a);\n            Descent.mid(this.x, this.a, this.ia);\n            this.computeNextPosition(this.ia, this.b);\n            Descent.mid(this.x, this.b, this.ib);\n            this.computeNextPosition(this.ib, this.c);\n            this.computeNextPosition(this.c, this.d);\n            var disp = 0;\n            this.matrixApply((i, j) => {\n                var x = (this.a[i][j] + 2.0 * this.b[i][j] + 2.0 * this.c[i][j] + this.d[i][j]) / 6.0,\n                    d = this.x[i][j] - x;\n                disp += d * d;\n                this.x[i][j] = x;\n            });\n            return disp;\n        }\n\n        private static mid(a: number[][], b: number[][], m: number[][]): void {\n            Descent.mApply(a.length, a[0].length, (i, j) =>\n                m[i][j] = a[i][j] + (b[i][j] - a[i][j]) / 2.0);\n        }\n\n        public takeDescentStep(x: number[], d: number[], stepSize: number): void {\n            for (var i = 0; i < this.n; ++i) {\n                x[i] = x[i] - stepSize * d[i];\n            }\n        }\n\n        public computeStress(): number {\n            var stress = 0;\n            for (var u = 0, nMinus1 = this.n - 1; u < nMinus1; ++u) {\n                for (var v = u + 1, n = this.n; v < n; ++v) {\n                    var l = 0;\n                    for (var i = 0; i < this.k; ++i) {\n                        var dx = this.x[i][u] - this.x[i][v];\n                        l += dx * dx;\n                    }\n                    l = Math.sqrt(l);\n                    var d = this.D[u][v];\n                    if (!isFinite(d)) continue;\n                    var rl = d - l;\n                    var d2 = d * d;\n                    stress += rl * rl / d2;\n                }\n            }\n            return stress;\n        }\n    }\n\n    // Linear congruential pseudo random number generator\n    export class PseudoRandom {\n        private a: number = 214013;\n        private c: number = 2531011;\n        private m: number = 2147483648;\n        private range: number = 32767;\n\n        constructor(public seed: number = 1) { }\n\n        // random real between 0 and 1\n        getNext(): number {\n            this.seed = (this.seed * this.a + this.c) % this.m;\n            return (this.seed >> 16) / this.range;\n        }\n\n        // random real between min and max\n        getNextBetween(min: number, max: number) {\n            return min + this.getNext() * (max - min);\n        }\n    }\n","    export class PositionStats {\n        AB: number = 0;\n        AD: number = 0;\n        A2: number = 0;\n\n        constructor(public scale: number) {}\n\n        addVariable(v: Variable): void {\n            var ai = this.scale / v.scale;\n            var bi = v.offset / v.scale;\n            var wi = v.weight;\n            this.AB += wi * ai * bi;\n            this.AD += wi * ai * v.desiredPosition;\n            this.A2 += wi * ai * ai;\n        }\n\n        getPosn(): number {\n            return (this.AD - this.AB) / this.A2;\n        }\n    }\n\n    export class Constraint {\n        lm: number;\n        active: boolean = false;\n        unsatisfiable: boolean = false;\n\n        constructor(public left: Variable, public right: Variable, public gap: number, public equality: boolean = false) {\n            this.left = left;\n            this.right = right;\n            this.gap = gap;\n            this.equality = equality;\n        }\n\n        slack(): number {\n            return this.unsatisfiable ? Number.MAX_VALUE\n                : this.right.scale * this.right.position() - this.gap\n                - this.left.scale * this.left.position();\n        }\n    }\n\n    export class Variable {\n        offset: number = 0;\n        block: Block;\n        cIn: Constraint[];\n        cOut: Constraint[];\n\n        constructor(public desiredPosition: number, public weight: number = 1, public scale: number = 1) {}\n\n        dfdv(): number {\n            return 2.0 * this.weight * (this.position() - this.desiredPosition);\n        }\n\n        position(): number {\n            return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;\n        }\n\n        // visit neighbours by active constraints within the same block\n        visitNeighbours(prev: Variable, f: (c: Constraint, next: Variable) => void ): void {\n            var ff = (c, next) => c.active && prev !== next && f(c, next);\n            this.cOut.forEach(c=> ff(c, c.right));\n            this.cIn.forEach(c=> ff(c, c.left));\n        }\n    }\n\n    export class Block {\n        vars: Variable[] = [];\n        posn: number;\n        ps: PositionStats;\n        blockInd: number;\n\n        constructor(v: Variable) {\n            v.offset = 0;\n            this.ps = new PositionStats(v.scale);\n            this.addVariable(v);\n        }\n\n        private addVariable(v: Variable): void {\n            v.block = this;\n            this.vars.push(v);\n            this.ps.addVariable(v);\n            this.posn = this.ps.getPosn();\n        }\n\n        // move the block where it needs to be to minimize cost\n        updateWeightedPosition(): void {\n            this.ps.AB = this.ps.AD = this.ps.A2 = 0;\n            for (var i = 0, n = this.vars.length; i < n; ++i)\n                this.ps.addVariable(this.vars[i]);\n            this.posn = this.ps.getPosn();\n        }\n\n        private compute_lm(v: Variable, u: Variable, postAction: (c: Constraint)=>void): number {\n            var dfdv = v.dfdv();\n            v.visitNeighbours(u, (c, next) => {\n                var _dfdv = this.compute_lm(next, v, postAction);\n                if (next === c.right) {\n                    dfdv += _dfdv * c.left.scale;\n                    c.lm = _dfdv;\n                } else {\n                    dfdv += _dfdv * c.right.scale;\n                    c.lm = -_dfdv;\n                }\n                postAction(c);\n            });\n            return dfdv / v.scale;\n        }\n\n        private populateSplitBlock(v: Variable, prev: Variable): void {\n            v.visitNeighbours(prev, (c, next) => {\n                next.offset = v.offset + (next === c.right ? c.gap : -c.gap);\n                this.addVariable(next);\n                this.populateSplitBlock(next, v);\n            });\n        }\n\n        // traverse the active constraint tree applying visit to each active constraint\n        traverse(visit: (c: Constraint) => any, acc: any[], v: Variable = this.vars[0], prev: Variable=null) {\n            v.visitNeighbours(prev, (c, next) => {\n                acc.push(visit(c));\n                this.traverse(visit, acc, next, v);\n            });\n        }\n\n        // calculate lagrangian multipliers on constraints and\n        // find the active constraint in this block with the smallest lagrangian.\n        // if the lagrangian is negative, then the constraint is a split candidate.\n        findMinLM(): Constraint {\n            var m: Constraint = null;\n            this.compute_lm(this.vars[0], null, c=> {\n                if (!c.equality && (m === null || c.lm < m.lm)) m = c;\n            });\n            return m;\n        }\n\n        private findMinLMBetween(lv: Variable, rv: Variable): Constraint {\n            this.compute_lm(lv, null, () => {});\n            var m = null;\n            this.findPath(lv, null, rv, (c, next)=> {\n                if (!c.equality && c.right === next && (m === null || c.lm < m.lm)) m = c;\n            });\n            return m;\n        }\n\n        private findPath(v: Variable, prev: Variable, to: Variable, visit: (c: Constraint, next:Variable)=>void): boolean {\n            var endFound = false;\n            v.visitNeighbours(prev, (c, next) => {\n                if (!endFound && (next === to || this.findPath(next, v, to, visit)))\n                {\n                    endFound = true;\n                    visit(c, next);\n                }\n            });\n            return endFound;\n        }\n\n        // Search active constraint tree from u to see if there is a directed path to v.\n        // Returns true if path is found.\n        isActiveDirectedPathBetween(u: Variable, v: Variable) : boolean {\n            if (u === v) return true;\n            var i = u.cOut.length;\n            while(i--) {\n                var c = u.cOut[i];\n                if (c.active && this.isActiveDirectedPathBetween(c.right, v))\n                    return true;\n            }\n            return false;\n        }\n\n        // split the block into two by deactivating the specified constraint\n        static split(c: Constraint): Block[]{\n/* DEBUG\n            console.log(\"split on \" + c);\n            console.assert(c.active, \"attempt to split on inactive constraint\");\nDEBUG */\n            c.active = false;\n            return [Block.createSplitBlock(c.left), Block.createSplitBlock(c.right)];\n        }\n\n        private static createSplitBlock(startVar: Variable): Block {\n            var b = new Block(startVar);\n            b.populateSplitBlock(startVar, null);\n            return b;\n        }\n\n        // find a split point somewhere between the specified variables\n        splitBetween(vl: Variable, vr: Variable): { constraint: Constraint; lb: Block; rb: Block } {\n/* DEBUG\n            console.assert(vl.block === this);\n            console.assert(vr.block === this);\nDEBUG */\n            var c = this.findMinLMBetween(vl, vr);\n            if (c !== null) {\n                var bs = Block.split(c);\n                return { constraint: c, lb: bs[0], rb: bs[1] };\n            }\n            // couldn't find a split point - for example the active path is all equality constraints\n            return null;\n        }\n\n        mergeAcross(b: Block, c: Constraint, dist: number): void {\n            c.active = true;\n            for (var i = 0, n = b.vars.length; i < n; ++i) {\n                var v = b.vars[i];\n                v.offset += dist;\n                this.addVariable(v);\n            }\n            this.posn = this.ps.getPosn();\n        }\n\n        cost(): number {\n            var sum = 0, i = this.vars.length;\n            while (i--) {\n                var v = this.vars[i],\n                    d = v.position() - v.desiredPosition;\n                sum += d * d * v.weight;\n            }\n            return sum;\n        }\n\n/* DEBUG\n        toString(): string {\n            var cs = [];\n            this.traverse(c=> c.toString() + \"\\n\", cs)\n            return \"b\"+this.blockInd + \"@\" + this.posn + \": vars=\" + this.vars.map(v=> v.toString()+\":\"+v.offset) + \";\\n cons=\\n\" + cs;\n        }\nDEBUG */\n    }\n\n    export class Blocks {\n        private list: Block[];\n\n        constructor(public vs: Variable[]) {\n            var n = vs.length;\n            this.list = new Array(n);\n            while (n--) {\n                var b = new Block(vs[n]);\n                this.list[n] = b;\n                b.blockInd = n;\n            }\n        }\n\n        cost(): number {\n            var sum = 0, i = this.list.length;\n            while (i--) sum += this.list[i].cost();\n            return sum;\n        }\n\n        insert(b: Block) {\n/* DEBUG\n            console.assert(!this.contains(b), \"blocks error: tried to reinsert block \" + b.blockInd)\nDEBUG */\n            b.blockInd = this.list.length;\n            this.list.push(b);\n/* DEBUG\n            console.log(\"insert block: \" + b.blockInd);\n            this.contains(b);\nDEBUG */\n        }\n\n        remove(b: Block) {\n/* DEBUG\n            console.log(\"remove block: \" + b.blockInd);\n            console.assert(this.contains(b));\nDEBUG */\n            var last = this.list.length - 1;\n            var swapBlock = this.list[last];\n            this.list.length = last;\n            if (b !== swapBlock) {\n                this.list[b.blockInd] = swapBlock;\n                swapBlock.blockInd = b.blockInd;\n/* DEBUG\n                console.assert(this.contains(swapBlock));\nDEBUG */\n            }\n        }\n\n        // merge the blocks on either side of the specified constraint, by copying the smaller block into the larger\n        // and deleting the smaller.\n        merge(c: Constraint): void {\n            var l = c.left.block, r = c.right.block;\n/* DEBUG\n            console.assert(l!==r, \"attempt to merge within the same block\");\nDEBUG */\n            var dist = c.right.offset - c.left.offset - c.gap;\n            if (l.vars.length < r.vars.length) {\n                r.mergeAcross(l, c, dist);\n                this.remove(l);\n            } else {\n                l.mergeAcross(r, c, -dist);\n                this.remove(r);\n            }\n/* DEBUG\n            console.assert(Math.abs(c.slack()) < 1e-6, \"Error: Constraint should be at equality after merge!\");\n            console.log(\"merged on \" + c);\nDEBUG */\n        }\n\n        forEach(f: (b: Block, i: number) => void ) {\n            this.list.forEach(f);\n        }\n\n        // useful, for example, after variable desired positions change.\n        updateBlockPositions(): void {\n            this.list.forEach(b=> b.updateWeightedPosition());\n        }\n\n        // split each block across its constraint with the minimum lagrangian\n        split(inactive: Constraint[]): void {\n            this.updateBlockPositions();\n            this.list.forEach(b=> {\n                var v = b.findMinLM();\n                if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {\n                    b = v.left.block;\n                    Block.split(v).forEach(nb=>this.insert(nb));\n                    this.remove(b);\n                    inactive.push(v);\n/* DEBUG\n                    console.assert(this.contains(v.left.block));\n                    console.assert(this.contains(v.right.block));\nDEBUG */\n                }\n            });\n        }\n\n/* DEBUG\n        // checks b is in the block, and does a sanity check over list index integrity\n        contains(b: Block): boolean {\n            var result = false;\n            this.list.forEach((bb, i) => {\n                if (bb.blockInd !== i) {\n                    console.error(\"blocks error, blockInd \" + b.blockInd + \" found at \" + i);\n                    return false;\n                }\n                result = result || b === bb;\n            });\n            return result;\n        }\n\n        toString(): string {\n            return this.list.toString();\n        }\nDEBUG */\n    }\n\n    export class Solver {\n        bs: Blocks;\n        inactive: Constraint[];\n\n        static LAGRANGIAN_TOLERANCE = -1e-4;\n        static ZERO_UPPERBOUND = -1e-10;\n\n        constructor(public vs: Variable[], public cs: Constraint[]) {\n            this.vs = vs;\n            vs.forEach(v => {\n                v.cIn = [], v.cOut = [];\n/* DEBUG\n                v.toString = () => \"v\" + vs.indexOf(v);\nDEBUG */\n            });\n            this.cs = cs;\n            cs.forEach(c => {\n                c.left.cOut.push(c);\n                c.right.cIn.push(c);\n/* DEBUG\n                c.toString = () => c.left + \"+\" + c.gap + \"<=\" + c.right + \" slack=\" + c.slack() + \" active=\" + c.active;\nDEBUG */\n            });\n            this.inactive = cs.map(c=> { c.active = false; return c; });\n            this.bs = null;\n        }\n\n        cost(): number {\n            return this.bs.cost();\n        }\n\n        // set starting positions without changing desired positions.\n        // Note: it throws away any previous block structure.\n        setStartingPositions(ps: number[]): void {\n            this.inactive = this.cs.map(c=> { c.active = false; return c; });\n            this.bs = new Blocks(this.vs);\n            this.bs.forEach((b, i) => b.posn = ps[i]);\n        }\n\n        setDesiredPositions(ps: number[]): void {\n            this.vs.forEach((v, i) => v.desiredPosition = ps[i]);\n        }\n\n/* DEBUG\n        private getId(v: Variable): number {\n            return this.vs.indexOf(v);\n        }\n\n        // sanity check of the index integrity of the inactive list\n        checkInactive(): void {\n            var inactiveCount = 0;\n            this.cs.forEach(c=> {\n                var i = this.inactive.indexOf(c);\n                console.assert(!c.active && i >= 0 || c.active && i < 0, \"constraint should be in the inactive list if it is not active: \" + c);\n                if (i >= 0) {\n                    inactiveCount++;\n                } else {\n                    console.assert(c.active, \"inactive constraint not found in inactive list: \" + c);\n                }\n            });\n            console.assert(inactiveCount === this.inactive.length, inactiveCount + \" inactive constraints found, \" + this.inactive.length + \"in inactive list\");\n        }\n        // after every call to satisfy the following should check should pass\n        checkSatisfied(): void {\n            this.cs.forEach(c=>console.assert(c.slack() >= vpsc.Solver.ZERO_UPPERBOUND, \"Error: Unsatisfied constraint! \"+c));\n        }\nDEBUG */\n\n        private mostViolated(): Constraint {\n            var minSlack = Number.MAX_VALUE,\n                v: Constraint = null,\n                l = this.inactive,\n                n = l.length,\n                deletePoint = n;\n            for (var i = 0; i < n; ++i) {\n                var c = l[i];\n                if (c.unsatisfiable) continue;\n                var slack = c.slack();\n                if (c.equality || slack < minSlack) {\n                    minSlack = slack;\n                    v = c;\n                    deletePoint = i;\n                    if (c.equality) break;\n                }\n            }\n            if (deletePoint !== n &&\n                (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality))\n            {\n                l[deletePoint] = l[n - 1];\n                l.length = n - 1;\n            }\n            return v;\n        }\n\n        // satisfy constraints by building block structure over violated constraints\n        // and moving the blocks to their desired positions\n        satisfy(): void {\n            if (this.bs == null) {\n                this.bs = new Blocks(this.vs);\n            }\n/* DEBUG\n            console.log(\"satisfy: \" + this.bs);\nDEBUG */\n            this.bs.split(this.inactive);\n            var v: Constraint = null;\n            while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {\n                var lb = v.left.block, rb = v.right.block;\n/* DEBUG\n                console.log(\"most violated is: \" + v);\n                this.bs.contains(lb);\n                this.bs.contains(rb);\nDEBUG */\n                if (lb !== rb) {\n                    this.bs.merge(v);\n                } else {\n                    if (lb.isActiveDirectedPathBetween(v.right, v.left)) {\n                        // cycle found!\n                        v.unsatisfiable = true;\n                        continue;\n                    }\n                    // constraint is within block, need to split first\n                    var split = lb.splitBetween(v.left, v.right);\n                    if (split !== null) {\n                        this.bs.insert(split.lb);\n                        this.bs.insert(split.rb);\n                        this.bs.remove(lb);\n                        this.inactive.push(split.constraint);\n                    } else {\n/* DEBUG\n                        console.log(\"unsatisfiable constraint found\");\nDEBUG */\n                        v.unsatisfiable = true;\n                        continue;\n                    }\n                    if (v.slack() >= 0) {\n/* DEBUG\n                        console.log(\"violated constraint indirectly satisfied: \" + v);\nDEBUG */\n                        // v was satisfied by the above split!\n                        this.inactive.push(v);\n                    } else {\n/* DEBUG\n                        console.log(\"merge after split:\");\nDEBUG */\n                        this.bs.merge(v);\n                    }\n                }\n/* DEBUG\n                this.bs.contains(v.left.block);\n                this.bs.contains(v.right.block);\n                this.checkInactive();\nDEBUG */\n            }\n/* DEBUG\n            this.checkSatisfied();\nDEBUG */\n        }\n\n        // repeatedly build and split block structure until we converge to an optimal solution\n        solve(): number {\n            this.satisfy();\n            var lastcost = Number.MAX_VALUE, cost = this.bs.cost();\n            while (Math.abs(lastcost - cost) > 0.0001) {\n                this.satisfy();\n                lastcost = cost;\n                cost = this.bs.cost();\n            }\n            return cost;\n        }\n    }\n    /**\n      * Remove overlap between spans while keeping their centers as close as possible to the specified desiredCenters.\n      * Lower and upper bounds will be respected if the spans physically fit between them\n      * (otherwise they'll be moved and their new position returned).\n      * If no upper/lower bound is specified then the bounds of the moved spans will be returned.\n      * returns a new center for each span.\n      */\n    export function removeOverlapInOneDimension(spans: { size: number, desiredCenter: number }[], lowerBound?: number, upperBound?: number)\n        : { newCenters: number[], lowerBound: number, upperBound: number }\n    {\n        const vs: Variable[] = spans.map(s => new Variable(s.desiredCenter));\n        const cs: Constraint[] = [];\n        const n = spans.length;\n        for (var i = 0; i < n - 1; i++) {\n            const left = spans[i], right = spans[i + 1];\n            cs.push(new Constraint(vs[i], vs[i + 1], (left.size + right.size) / 2));\n        }\n        const leftMost = vs[0],\n            rightMost = vs[n - 1],\n            leftMostSize = spans[0].size / 2,\n            rightMostSize = spans[n - 1].size / 2;\n        let vLower: Variable = null, vUpper: Variable = null;\n        if (lowerBound) {\n            vLower = new Variable(lowerBound, leftMost.weight * 1000);\n            vs.push(vLower);\n            cs.push(new Constraint(vLower, leftMost, leftMostSize));\n        }\n        if (upperBound) {\n            vUpper = new Variable(upperBound, rightMost.weight * 1000);\n            vs.push(vUpper);\n            cs.push(new Constraint(rightMost, vUpper, rightMostSize));\n        }\n        var solver = new Solver(vs, cs);\n        solver.solve();\n        return {\n            newCenters: vs.slice(0, spans.length).map(v => v.position()),\n            lowerBound: vLower ? vLower.position() : leftMost.position() - leftMostSize,\n            upperBound: vUpper ? vUpper.position() : rightMost.position() + rightMostSize\n        };\n    }\n","    //Based on js_es:\n    //\n    //https://github.com/vadimg/js_bintrees\n    //\n    //Copyright (C) 2011 by Vadim Graboys\n    //\n    //Permission is hereby granted, free of charge, to any person obtaining a copy\n    //of this software and associated documentation files (the \"Software\"), to deal\n    //in the Software without restriction, including without limitation the rights\n    //to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    //copies of the Software, and to permit persons to whom the Software is\n    //furnished to do so, subject to the following conditions:\n    //\n    //The above copyright notice and this permission notice shall be included in\n    //all copies or substantial portions of the Software.\n    //\n    //THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    //IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    //FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    //AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    //LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    //OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n    //THE SOFTWARE.\n    export class TreeBase {\n        _root;\n        size;\n        _comparator;\n        // removes all nodes from the tree\n        clear() {\n            this._root = null;\n            this.size = 0;\n        };\n\n        // returns node data if found, null otherwise\n        find(data) {\n            var res = this._root;\n\n            while (res !== null) {\n                var c = this._comparator(data, res.data);\n                if (c === 0) {\n                    return res.data;\n                }\n                else {\n                    res = res.get_child(c > 0);\n                }\n            }\n\n            return null;\n        };\n\n        // returns iterator to node if found, null otherwise\n        findIter = function (data) {\n            var res = this._root;\n            var iter = this.iterator();\n\n            while (res !== null) {\n                var c = this._comparator(data, res.data);\n                if (c === 0) {\n                    iter._cursor = res;\n                    return iter;\n                }\n                else {\n                    iter._ancestors.push(res);\n                    res = res.get_child(c > 0);\n                }\n            }\n\n            return null;\n        };\n\n        // Returns an interator to the tree node immediately before (or at) the element\n        lowerBound(data) {\n            return this._bound(data, this._comparator);\n        };\n\n        // Returns an interator to the tree node immediately after (or at) the element\n        upperBound(data) {\n            var cmp = this._comparator;\n\n            function reverse_cmp(a, b) {\n                return cmp(b, a);\n            }\n\n            return this._bound(data, reverse_cmp);\n        };\n\n        // returns null if tree is empty\n        min() {\n            var res = this._root;\n            if (res === null) {\n                return null;\n            }\n\n            while (res.left !== null) {\n                res = res.left;\n            }\n\n            return res.data;\n        };\n\n        // returns null if tree is empty\n        max() {\n            var res = this._root;\n            if (res === null) {\n                return null;\n            }\n\n            while (res.right !== null) {\n                res = res.right;\n            }\n\n            return res.data;\n        };\n\n        // returns a null iterator\n        // call next() or prev() to point to an element\n        iterator(): Iterator {\n            return new Iterator(this);\n        };\n\n        // calls cb on each node's data, in order\n        each(cb) {\n            var it = this.iterator(), data;\n            while ((data = it.next()) !== null) {\n                cb(data);\n            }\n        };\n\n        // calls cb on each node's data, in reverse order\n        reach(cb) {\n            var it = this.iterator(), data;\n            while ((data = it.prev()) !== null) {\n                cb(data);\n            }\n        };\n\n        // used for lowerBound and upperBound\n        _bound(data, cmp) {\n            var cur = this._root;\n            var iter = this.iterator();\n\n            while (cur !== null) {\n                var c = this._comparator(data, cur.data);\n                if (c === 0) {\n                    iter._cursor = cur;\n                    return iter;\n                }\n                iter._ancestors.push(cur);\n                cur = cur.get_child(c > 0);\n            }\n\n            for (var i = iter._ancestors.length - 1; i >= 0; --i) {\n                cur = iter._ancestors[i];\n                if (cmp(data, cur.data) > 0) {\n                    iter._cursor = cur;\n                    iter._ancestors.length = i;\n                    return iter;\n                }\n            }\n\n            iter._ancestors.length = 0;\n            return iter;\n        };\n    }\n    export class Iterator {\n        _tree;\n        _ancestors;\n        _cursor;\n        constructor(tree) {\n            this._tree = tree;\n            this._ancestors = [];\n            this._cursor = null;\n        }\n\n        data() {\n            return this._cursor !== null ? this._cursor.data : null;\n        };\n\n        // if null-iterator, returns first node\n        // otherwise, returns next node\n        next() {\n            if (this._cursor === null) {\n                var root = this._tree._root;\n                if (root !== null) {\n                    this._minNode(root);\n                }\n            }\n            else {\n                if (this._cursor.right === null) {\n                    // no greater node in subtree, go up to parent\n                    // if coming from a right child, continue up the stack\n                    var save;\n                    do {\n                        save = this._cursor;\n                        if (this._ancestors.length) {\n                            this._cursor = this._ancestors.pop();\n                        }\n                        else {\n                            this._cursor = null;\n                            break;\n                        }\n                    } while (this._cursor.right === save);\n                }\n                else {\n                    // get the next node from the subtree\n                    this._ancestors.push(this._cursor);\n                    this._minNode(this._cursor.right);\n                }\n            }\n            return this._cursor !== null ? this._cursor.data : null;\n        };\n\n        // if null-iterator, returns last node\n        // otherwise, returns previous node\n        prev() {\n            if (this._cursor === null) {\n                var root = this._tree._root;\n                if (root !== null) {\n                    this._maxNode(root);\n                }\n            }\n            else {\n                if (this._cursor.left === null) {\n                    var save;\n                    do {\n                        save = this._cursor;\n                        if (this._ancestors.length) {\n                            this._cursor = this._ancestors.pop();\n                        }\n                        else {\n                            this._cursor = null;\n                            break;\n                        }\n                    } while (this._cursor.left === save);\n                }\n                else {\n                    this._ancestors.push(this._cursor);\n                    this._maxNode(this._cursor.left);\n                }\n            }\n            return this._cursor !== null ? this._cursor.data : null;\n        };\n\n        _minNode(start) {\n            while (start.left !== null) {\n                this._ancestors.push(start);\n                start = start.left;\n            }\n            this._cursor = start;\n        };\n\n        _maxNode(start) {\n            while (start.right !== null) {\n                this._ancestors.push(start);\n                start = start.right;\n            }\n            this._cursor = start;\n        };\n    }\n\n    class Node {\n        data;\n        left;\n        right;\n        red;\n        constructor(data) {\n            this.data = data;\n            this.left = null;\n            this.right = null;\n            this.red = true;\n        }\n\n        get_child(dir) {\n            return dir ? this.right : this.left;\n        };\n\n        set_child(dir, val) {\n            if (dir) {\n                this.right = val;\n            }\n            else {\n                this.left = val;\n            }\n        };\n    }\n\n    export class RBTree<T> extends TreeBase {\n\n        _root;\n        _comparator;\n        size;\n        constructor(comparator: (a: T, b: T) => number) {\n            super();\n            this._root = null;\n            this._comparator = comparator;\n            this.size = 0;\n        }\n\n        // returns true if inserted, false if duplicate\n        insert(data) {\n            var ret = false;\n\n            if (this._root === null) {\n                // empty tree\n                this._root = new Node(data);\n                ret = true;\n                this.size++;\n            }\n            else {\n                var head = new Node(undefined); // fake tree root\n\n                var dir = false;\n                var last = false;\n\n                // setup\n                var gp = null; // grandparent\n                var ggp = head; // grand-grand-parent\n                var p = null; // parent\n                var node = this._root;\n                ggp.right = this._root;\n\n                // search down\n                while (true) {\n                    if (node === null) {\n                        // insert new node at the bottom\n                        node = new Node(data);\n                        p.set_child(dir, node);\n                        ret = true;\n                        this.size++;\n                    }\n                    else if (RBTree.is_red(node.left) && RBTree.is_red(node.right)) {\n                        // color flip\n                        node.red = true;\n                        node.left.red = false;\n                        node.right.red = false;\n                    }\n\n                    // fix red violation\n                    if (RBTree.is_red(node) && RBTree.is_red(p)) {\n                        var dir2 = ggp.right === gp;\n\n                        if (node === p.get_child(last)) {\n                            ggp.set_child(dir2, RBTree.single_rotate(gp, !last));\n                        }\n                        else {\n                            ggp.set_child(dir2, RBTree.double_rotate(gp, !last));\n                        }\n                    }\n\n                    var cmp = this._comparator(node.data, data);\n\n                    // stop if found\n                    if (cmp === 0) {\n                        break;\n                    }\n\n                    last = dir;\n                    dir = cmp < 0;\n\n                    // update helpers\n                    if (gp !== null) {\n                        ggp = gp;\n                    }\n                    gp = p;\n                    p = node;\n                    node = node.get_child(dir);\n                }\n\n                // update root\n                this._root = head.right;\n            }\n\n            // make root black\n            this._root.red = false;\n\n            return ret;\n        };\n\n        // returns true if removed, false if not found\n        remove(data) {\n            if (this._root === null) {\n                return false;\n            }\n\n            var head = new Node(undefined); // fake tree root\n            var node = head;\n            node.right = this._root;\n            var p = null; // parent\n            var gp = null; // grand parent\n            var found = null; // found item\n            var dir = true;\n\n            while (node.get_child(dir) !== null) {\n                var last = dir;\n\n                // update helpers\n                gp = p;\n                p = node;\n                node = node.get_child(dir);\n\n                var cmp = this._comparator(data, node.data);\n\n                dir = cmp > 0;\n\n                // save found node\n                if (cmp === 0) {\n                    found = node;\n                }\n\n                // push the red node down\n                if (!RBTree.is_red(node) && !RBTree.is_red(node.get_child(dir))) {\n                    if (RBTree.is_red(node.get_child(!dir))) {\n                        var sr = RBTree.single_rotate(node, dir);\n                        p.set_child(last, sr);\n                        p = sr;\n                    }\n                    else if (!RBTree.is_red(node.get_child(!dir))) {\n                        var sibling = p.get_child(!last);\n                        if (sibling !== null) {\n                            if (!RBTree.is_red(sibling.get_child(!last)) && !RBTree.is_red(sibling.get_child(last))) {\n                                // color flip\n                                p.red = false;\n                                sibling.red = true;\n                                node.red = true;\n                            }\n                            else {\n                                var dir2 = gp.right === p;\n\n                                if (RBTree.is_red(sibling.get_child(last))) {\n                                    gp.set_child(dir2, RBTree.double_rotate(p, last));\n                                }\n                                else if (RBTree.is_red(sibling.get_child(!last))) {\n                                    gp.set_child(dir2, RBTree.single_rotate(p, last));\n                                }\n\n                                // ensure correct coloring\n                                var gpc = gp.get_child(dir2);\n                                gpc.red = true;\n                                node.red = true;\n                                gpc.left.red = false;\n                                gpc.right.red = false;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // replace and remove if found\n            if (found !== null) {\n                found.data = node.data;\n                p.set_child(p.right === node, node.get_child(node.left === null));\n                this.size--;\n            }\n\n            // update root and make it black\n            this._root = head.right;\n            if (this._root !== null) {\n                this._root.red = false;\n            }\n\n            return found !== null;\n        };\n\n        static is_red(node) {\n            return node !== null && node.red;\n        }\n\n        static single_rotate(root, dir) {\n            var save = root.get_child(!dir);\n\n            root.set_child(!dir, save.get_child(dir));\n            save.set_child(dir, root);\n\n            root.red = true;\n            save.red = false;\n\n            return save;\n        }\n\n        static double_rotate(root, dir) {\n            root.set_child(!dir, RBTree.single_rotate(root.get_child(!dir), !dir));\n            return RBTree.single_rotate(root, dir);\n        }\n    }\n","import {Constraint, Variable, Solver} from './vpsc'\nimport {RBTree} from './rbtree'\nimport {Point} from './geom'\n\n    export interface Leaf {\n        bounds: Rectangle;\n        variable: Variable;\n    }\n\n    export interface ProjectionGroup {\n        bounds: Rectangle;\n        padding: number;\n        stiffness: number;\n        leaves: Leaf[];\n        groups: ProjectionGroup[];\n        minVar: Variable;\n        maxVar: Variable;\n    }\n\n    export function computeGroupBounds(g: ProjectionGroup): Rectangle {\n        g.bounds = typeof g.leaves !== \"undefined\" ?\n            g.leaves.reduce((r: Rectangle, c) => c.bounds.union(r), Rectangle.empty()) :\n            Rectangle.empty();\n        if (typeof g.groups !== \"undefined\")\n            g.bounds = <Rectangle>g.groups.reduce((r: Rectangle, c) => computeGroupBounds(c).union(r), g.bounds);\n        g.bounds = g.bounds.inflate(g.padding);\n        return g.bounds;\n    }\n\n    export class Rectangle {\n        constructor(\n            public x: number,\n            public X: number,\n            public y: number,\n            public Y: number) { }\n\n        static empty(): Rectangle { return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY); }\n\n        cx(): number { return (this.x + this.X) / 2; }\n\n        cy(): number { return (this.y + this.Y) / 2; }\n\n        overlapX(r: Rectangle): number {\n            var ux = this.cx(), vx = r.cx();\n            if (ux <= vx && r.x < this.X) return this.X - r.x;\n            if (vx <= ux && this.x < r.X) return r.X - this.x;\n            return 0;\n        }\n\n        overlapY(r: Rectangle): number {\n            var uy = this.cy(), vy = r.cy();\n            if (uy <= vy && r.y < this.Y) return this.Y - r.y;\n            if (vy <= uy && this.y < r.Y) return r.Y - this.y;\n            return 0;\n        }\n\n        setXCentre(cx: number): void {\n            var dx = cx - this.cx();\n            this.x += dx;\n            this.X += dx;\n        }\n\n        setYCentre(cy: number): void {\n            var dy = cy - this.cy();\n            this.y += dy;\n            this.Y += dy;\n        }\n\n        width(): number {\n            return this.X - this.x;\n        }\n\n        height(): number {\n            return this.Y - this.y;\n        }\n\n        union(r: Rectangle): Rectangle {\n            return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));\n        }\n\n        /**\n         * return any intersection points between the given line and the sides of this rectangle\n         * @method lineIntersection\n         * @param x1 number first x coord of line\n         * @param y1 number first y coord of line\n         * @param x2 number second x coord of line\n         * @param y2 number second y coord of line\n         * @return any intersection points found\n         */\n        lineIntersections(x1: number, y1: number, x2: number, y2: number): Array<Point> {\n            var sides = [[this.x, this.y, this.X, this.y],\n                    [this.X, this.y, this.X, this.Y],\n                    [this.X, this.Y, this.x, this.Y],\n                [this.x, this.Y, this.x, this.y]];\n            var intersections = [];\n            for (var i = 0; i < 4; ++i) {\n                var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);\n                if (r !== null) intersections.push({ x: r.x, y: r.y });\n            }\n            return intersections;\n        }\n\n        /**\n         * return any intersection points between a line extending from the centre of this rectangle to the given point,\n         *  and the sides of this rectangle\n         * @method lineIntersection\n         * @param x2 number second x coord of line\n         * @param y2 number second y coord of line\n         * @return any intersection points found\n         */\n        rayIntersection(x2: number, y2: number): Point {\n            var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);\n            return ints.length > 0 ? ints[0] : null;\n        }\n\n        vertices(): Point[] {\n            return [\n                { x: this.x, y: this.y },\n                { x: this.X, y: this.y },\n                { x: this.X, y: this.Y },\n                { x: this.x, y: this.Y }];\n        }\n\n        static lineIntersection(\n            x1: number, y1: number,\n            x2: number, y2: number,\n            x3: number, y3: number,\n            x4: number, y4: number): Point {\n            var dx12 = x2 - x1, dx34 = x4 - x3,\n                dy12 = y2 - y1, dy34 = y4 - y3,\n                denominator = dy34 * dx12 - dx34 * dy12;\n            if (denominator == 0) return null;\n            var dx31 = x1 - x3, dy31 = y1 - y3,\n                numa = dx34 * dy31 - dy34 * dx31,\n                a = numa / denominator,\n                numb = dx12 * dy31 - dy12 * dx31,\n                b = numb / denominator;\n            if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {\n                return {\n                    x: x1 + a * dx12,\n                    y: y1 + a * dy12\n                };\n            }\n            return null;\n        }\n\n        inflate(pad: number): Rectangle {\n            return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);\n        }\n    }\n\n    /**\n     * Returns the endpoints of a line that connects the centre of two rectangles.\n     * @param {Rectangle} [source] The source Rectangle.\n     * @param {Rectangle} [target] The target Rectangle.\n     * @param {number} [ah] The size of the arrow head, a distance to shorten the\n     *                      line by.\n     * @return An object with three point properties, the intersection with the\n     *         source rectangle (sourceIntersection), the intersection with then\n     *         target rectangle (targetIntersection), and the point an arrow\n     *         head of the specified size would need to start (arrowStart).\n     */\n    export function makeEdgeBetween(source: Rectangle, target: Rectangle, ah: number)\n        : { sourceIntersection: Point; targetIntersection: Point; arrowStart: Point } {\n        const si = source.rayIntersection(target.cx(), target.cy()) || { x: source.cx(), y: source.cy() },\n            ti = target.rayIntersection(source.cx(), source.cy()) || { x: target.cx(), y: target.cy() },\n            dx = ti.x - si.x,\n            dy = ti.y - si.y,\n            l = Math.sqrt(dx * dx + dy * dy), al = l - ah;\n        return {\n            sourceIntersection: si,\n            targetIntersection: ti,\n            arrowStart: { x: si.x + al * dx / l, y: si.y + al * dy / l }\n        }\n    }\n\n    /**\n     * Returns the intersection of a line from the given point to the centre\n     * of the target rectangle where it intersects the rectanngle.\n     * @param [source] The source point.\n     * @param {Rectangle} [target] The target Rectangle.\n     * @param {number} [ah] The size of the arrow head, a distance to shorten the\n     *                      line by.\n     * @return The point an arrow head of the specified size would need to start.\n     */\n    export function makeEdgeTo(s: { x: number; y: number }, target: Rectangle, ah: number): Point {\n        var ti = target.rayIntersection(s.x, s.y);\n        if (!ti) ti = { x: target.cx(), y: target.cy() };\n        var dx = ti.x - s.x,\n            dy = ti.y - s.y,\n            l = Math.sqrt(dx * dx + dy * dy);\n        return { x: ti.x - ah * dx / l, y: ti.y - ah * dy / l };\n    }\n\n    class Node {\n        prev: RBTree<Node>;\n        next: RBTree<Node>;\n\n        constructor(public v: Variable, public r: Rectangle, public pos: number) {\n            this.prev = makeRBTree();\n            this.next = makeRBTree();\n        }\n    }\n\n    class Event {\n        constructor(public isOpen: boolean, public v: Node, public pos: number) {}\n    }\n\n    function compareEvents(a: Event, b: Event): number {\n        if (a.pos > b.pos) {\n            return 1;\n        }\n        if (a.pos < b.pos) {\n            return -1;\n        }\n        if (a.isOpen) {\n            // open must come before close\n            return -1;\n        }\n        if (b.isOpen) {\n            // open must come before close\n            return 1;\n        }\n        return 0;\n    }\n\n    function makeRBTree(): RBTree<Node> {\n        return new RBTree<Node>((a, b) => a.pos - b.pos);\n    }\n\n    interface RectAccessors {\n        getCentre: (r: Rectangle) => number;\n        getOpen: (r: Rectangle) => number;\n        getClose: (r: Rectangle) => number;\n        getSize: (r: Rectangle) => number;\n        makeRect: (open: number, close: number, center: number, size: number) => Rectangle;\n        findNeighbours: (v: Node, scanline: RBTree<Node>) => void;\n    }\n\n    var xRect: RectAccessors = {\n        getCentre: r=> r.cx(),\n        getOpen: r=> r.y,\n        getClose: r=> r.Y,\n        getSize: r=> r.width(),\n        makeRect: (open, close, center, size) => new Rectangle(center - size / 2, center + size / 2, open, close) ,\n        findNeighbours: findXNeighbours\n    };\n\n    var yRect: RectAccessors = {\n        getCentre: r=> r.cy(),\n        getOpen: r=> r.x,\n        getClose: r=> r.X,\n        getSize: r=> r.height(),\n        makeRect: (open, close, center, size) => new Rectangle(open, close, center - size / 2, center + size / 2),\n        findNeighbours: findYNeighbours\n    };\n\n    function generateGroupConstraints(root: ProjectionGroup, f: RectAccessors, minSep: number, isContained: boolean = false): Constraint[]\n    {\n        var padding = root.padding,\n            gn = typeof root.groups !== 'undefined' ? root.groups.length : 0,\n            ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0,\n            childConstraints: Constraint[] = !gn ? []\n            : root.groups.reduce((ccs: Constraint[], g) => ccs.concat(generateGroupConstraints(g, f, minSep, true)), []),\n            n = (isContained ? 2 : 0) + ln + gn,\n            vs: Variable[] = new Array(n),\n            rs: Rectangle[] = new Array(n),\n            i = 0,\n            add = (r, v) => { rs[i] = r; vs[i++] = v };\n        if (isContained) {\n            // if this group is contained by another, then we add two dummy vars and rectangles for the borders\n            var b: Rectangle = root.bounds,\n                c = f.getCentre(b), s = f.getSize(b) / 2,\n                open = f.getOpen(b), close = f.getClose(b),\n                min = c - s + padding / 2, max = c + s - padding / 2;\n            root.minVar.desiredPosition = min;\n            add(f.makeRect(open, close, min, padding), root.minVar);\n            root.maxVar.desiredPosition = max;\n            add(f.makeRect(open, close, max, padding), root.maxVar);\n        }\n        if (ln) root.leaves.forEach(l => add(l.bounds, l.variable));\n        if (gn) root.groups.forEach(g => {\n            var b: Rectangle = g.bounds;\n            add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);\n        });\n        var cs = generateConstraints(rs, vs, f, minSep);\n        if (gn) {\n            vs.forEach(v => { v.cOut = [], v.cIn = [] });\n            cs.forEach(c => { c.left.cOut.push(c), c.right.cIn.push(c) });\n            root.groups.forEach(g => {\n                var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;\n                g.minVar.cIn.forEach(c => c.gap += gapAdjustment);\n                g.minVar.cOut.forEach(c => { c.left = g.maxVar; c.gap += gapAdjustment; });\n            });\n        }\n        return childConstraints.concat(cs);\n    }\n\n    function generateConstraints(rs: Rectangle[], vars: Variable[],\n        rect: RectAccessors, minSep: number): Constraint[]\n    {\n        var i, n = rs.length;\n        var N = 2 * n;\n        console.assert(vars.length >= n);\n        var events = new Array<Event>(N);\n        for (i = 0; i < n; ++i) {\n            var r = rs[i];\n            var v = new Node(vars[i], r, rect.getCentre(r));\n            events[i] = new Event(true, v, rect.getOpen(r));\n            events[i + n] = new Event(false, v, rect.getClose(r));\n        }\n        events.sort(compareEvents);\n        var cs = new Array<Constraint>();\n        var scanline = makeRBTree();\n        for (i = 0; i < N; ++i) {\n            var e = events[i];\n            var v = e.v;\n            if (e.isOpen) {\n                scanline.insert(v);\n                rect.findNeighbours(v, scanline);\n            } else {\n                // close event\n                scanline.remove(v);\n                var makeConstraint = (l, r) => {\n                    var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;\n                    cs.push(new Constraint(l.v, r.v, sep));\n                };\n                var visitNeighbours = (forward, reverse, mkcon) => {\n                    var u, it = v[forward].iterator();\n                    while ((u = it[forward]()) !== null) {\n                        mkcon(u, v);\n                        u[reverse].remove(v);\n                    }\n                };\n                visitNeighbours(\"prev\", \"next\", (u, v) => makeConstraint(u, v));\n                visitNeighbours(\"next\", \"prev\", (u, v) => makeConstraint(v, u));\n            }\n        }\n        console.assert(scanline.size === 0);\n        return cs;\n    }\n\n    function findXNeighbours(v: Node, scanline: RBTree<Node>): void {\n        var f = (forward, reverse) => {\n            var it = scanline.findIter(v);\n            var u;\n            while ((u = it[forward]()) !== null) {\n                var uovervX = u.r.overlapX(v.r);\n                if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {\n                    v[forward].insert(u);\n                    u[reverse].insert(v);\n                }\n                if (uovervX <= 0) {\n                    break;\n                }\n            }\n        }\n        f(\"next\", \"prev\");\n        f(\"prev\", \"next\");\n    }\n\n    function findYNeighbours(v: Node, scanline: RBTree<Node>): void {\n        var f = (forward, reverse) => {\n            var u = scanline.findIter(v)[forward]();\n            if (u !== null && u.r.overlapX(v.r) > 0) {\n                v[forward].insert(u);\n                u[reverse].insert(v);\n            }\n        }\n        f(\"next\", \"prev\");\n        f(\"prev\", \"next\");\n    }\n\n    export function generateXConstraints(rs: Rectangle[], vars: Variable[]): Constraint[] {\n        return generateConstraints(rs, vars, xRect, 1e-6);\n    }\n\n    export function generateYConstraints(rs: Rectangle[], vars: Variable[]): Constraint[] {\n        return generateConstraints(rs, vars, yRect, 1e-6);\n    }\n\n    export function generateXGroupConstraints(root: ProjectionGroup): Constraint[] {\n        return generateGroupConstraints(root, xRect, 1e-6);\n    }\n\n    export function generateYGroupConstraints(root: ProjectionGroup): Constraint[] {\n        return generateGroupConstraints(root, yRect, 1e-6);\n    }\n\n    export function removeOverlaps(rs: Rectangle[]): void {\n        var vs = rs.map(r => new Variable(r.cx()));\n        var cs = generateXConstraints(rs, vs);\n        var solver = new Solver(vs, cs);\n        solver.solve();\n        vs.forEach((v, i) => rs[i].setXCentre(v.position()));\n        vs = rs.map(r=> new Variable(r.cy()));\n        cs = generateYConstraints(rs, vs);\n        solver = new Solver(vs, cs);\n        solver.solve();\n        vs.forEach((v, i) => rs[i].setYCentre(v.position()));\n    }\n\n    export interface GraphNode extends Leaf {\n        fixed: boolean;\n        fixedWeight?: number;\n        width: number;\n        height: number;\n        x: number;\n        y: number;\n        px: number;\n        py: number;\n    }\n\n    export class IndexedVariable extends Variable {\n        constructor(public index: number, w: number) {\n            super(0, w);\n        }\n    }\n\n    export class Projection {\n        private xConstraints: Constraint[];\n        private yConstraints: Constraint[];\n        private variables: Variable[];\n\n        constructor(private nodes: GraphNode[],\n            private groups: ProjectionGroup[],\n            private rootGroup: ProjectionGroup = null,\n            constraints: any[]= null,\n            private avoidOverlaps: boolean = false)\n        {\n            this.variables = nodes.map((v, i) => {\n                return v.variable = new IndexedVariable(i, 1);\n            });\n\n            if (constraints) this.createConstraints(constraints);\n\n            if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {\n                nodes.forEach(v => {\n\t\t\t\t\tif (!v.width || !v.height)\n\t\t\t\t\t{\n\t\t\t\t\t\t//If undefined, default to nothing\n\t\t\t\t\t\tv.bounds = new Rectangle(v.x, v.x, v.y, v.y);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n                    var w2 = v.width / 2, h2 = v.height / 2;\n                    v.bounds = new Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);\n                });\n                computeGroupBounds(rootGroup);\n                var i = nodes.length;\n                groups.forEach(g => {\n                    this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\n                    this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\n                });\n            }\n        }\n\n\n        private createSeparation(c: any) : Constraint {\n            return new Constraint(\n                this.nodes[c.left].variable,\n                this.nodes[c.right].variable,\n                c.gap,\n                typeof c.equality !== \"undefined\" ? c.equality : false);\n        }\n\n        // simple satisfaction of alignment constraints to ensure initial feasibility\n        private makeFeasible(c: any) {\n            if (!this.avoidOverlaps) return;\n            // sort nodes in constraint by position (along \"guideline\")\n            var axis = 'x', dim = 'width';\n            if (c.axis === 'x') axis = 'y', dim = 'height';\n            var vs: GraphNode[] = c.offsets.map(o => this.nodes[o.node]).sort((a, b) => a[axis] - b[axis]);\n            var p: GraphNode = null;\n            vs.forEach(v => {\n                // if two nodes overlap then shove the second one along\n                if (p) {\n                    let nextPos = p[axis] + p[dim];\n                    if (nextPos > v[axis]) {\n                        v[axis] = nextPos;\n                    }\n                }\n                p = v;\n            });\n        }\n\n        private createAlignment(c: any) {\n            var u = this.nodes[c.offsets[0].node].variable;\n            this.makeFeasible(c);\n            var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;\n            c.offsets.slice(1).forEach(o => {\n                var v = this.nodes[o.node].variable;\n                cs.push(new Constraint(u, v, o.offset, true));\n            });\n        }\n\n        private createConstraints(constraints: any[]) {\n            var isSep = c => typeof c.type === 'undefined' || c.type === 'separation';\n            this.xConstraints = constraints\n                .filter(c => c.axis === \"x\" && isSep(c))\n                .map(c => this.createSeparation(c));\n            this.yConstraints = constraints\n                .filter(c => c.axis === \"y\" && isSep(c))\n                .map(c => this.createSeparation(c));\n            constraints\n                .filter(c => c.type === 'alignment')\n                .forEach(c => this.createAlignment(c));\n        }\n\n        private setupVariablesAndBounds(x0: number[], y0: number[], desired: number[], getDesired: (v: GraphNode) => number) {\n            this.nodes.forEach((v, i) => {\n                if (v.fixed) {\n                    v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;\n                    desired[i] = getDesired(v);\n                } else {\n                    v.variable.weight = 1;\n                }\n                var w = (v.width || 0) / 2, h = (v.height || 0) / 2;\n                var ix = x0[i], iy = y0[i];\n                v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);\n            });\n        }\n\n        xProject(x0: number[], y0: number[], x: number[]) {\n            if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints)) return;\n            this.project(x0, y0, x0, x, v=> v.px, this.xConstraints, generateXGroupConstraints,\n                v => v.bounds.setXCentre(x[(<IndexedVariable>v.variable).index] = v.variable.position()),\n                g => {\n                    var xmin = x[(<IndexedVariable>g.minVar).index] = g.minVar.position();\n                    var xmax = x[(<IndexedVariable>g.maxVar).index] = g.maxVar.position();\n                    var p2 = g.padding / 2;\n                    g.bounds.x = xmin - p2;\n                    g.bounds.X = xmax + p2;\n                });\n        }\n\n        yProject(x0: number[], y0: number[], y: number[]) {\n            if (!this.rootGroup && !this.yConstraints) return;\n            this.project(x0, y0, y0, y, v=> v.py, this.yConstraints, generateYGroupConstraints,\n                v => v.bounds.setYCentre(y[(<IndexedVariable>v.variable).index] = v.variable.position()),\n                g => {\n                    var ymin = y[(<IndexedVariable>g.minVar).index] = g.minVar.position();\n                    var ymax = y[(<IndexedVariable>g.maxVar).index] = g.maxVar.position();\n                    var p2 = g.padding / 2;\n                    g.bounds.y = ymin - p2;;\n                    g.bounds.Y = ymax + p2;\n                });\n        }\n\n        projectFunctions(): { (x0: number[], y0: number[], r: number[]): void }[]{\n            return [\n                (x0, y0, x) => this.xProject(x0, y0, x),\n                (x0, y0, y) => this.yProject(x0, y0, y)\n            ];\n        }\n\n        private project(x0: number[], y0: number[], start: number[], desired: number[],\n            getDesired: (v: GraphNode) => number,\n            cs: Constraint[],\n            generateConstraints: (g: ProjectionGroup) => Constraint[],\n            updateNodeBounds: (v: GraphNode) => any,\n            updateGroupBounds: (g: ProjectionGroup) => any)\n        {\n            this.setupVariablesAndBounds(x0, y0, desired, getDesired);\n            if (this.rootGroup && this.avoidOverlaps) {\n                computeGroupBounds(this.rootGroup);\n                cs = cs.concat(generateConstraints(this.rootGroup));\n            }\n            this.solve(this.variables, cs, start, desired);\n            this.nodes.forEach(updateNodeBounds);\n            if (this.rootGroup && this.avoidOverlaps) {\n                this.groups.forEach(updateGroupBounds);\n                computeGroupBounds(this.rootGroup);\n            }\n        }\n\n        private solve(vs: Variable[], cs: Constraint[], starting: number[], desired: number[]) {\n            var solver = new Solver(vs, cs);\n            solver.setStartingPositions(starting);\n            solver.setDesiredPositions(desired);\n            solver.solve();\n        }\n    }\n","\nexport class PairingHeap<T> {\n    private subheaps : PairingHeap<T>[];\n    // from: https://gist.github.com/nervoussystem\n    //{elem:object, subheaps:[array of heaps]}\n    constructor(public elem: T) {\n        this.subheaps = [];\n    }\n\n    public toString(selector) : string {\n        var str = \"\", needComma = false;\n        for (var i = 0; i < this.subheaps.length; ++i) {\n            var subheap: PairingHeap<T> = this.subheaps[i];\n            if (!subheap.elem) {\n                needComma = false;\n                continue;\n            }\n            if (needComma) {\n                str = str + \",\";\n            }\n            str = str + subheap.toString(selector);\n            needComma = true;\n        }\n        if (str !== \"\") {\n            str = \"(\" + str + \")\";\n        }\n        return (this.elem ? selector(this.elem) : \"\") + str;\n    }\n\n    public forEach(f) {\n        if (!this.empty()) {\n            f(this.elem, this);\n            this.subheaps.forEach(s => s.forEach(f));\n        }\n    }\n\n    public count(): number {\n        return this.empty() ? 0 : 1 + this.subheaps.reduce((n: number, h: PairingHeap<T>) => {\n            return n + h.count();\n        }, 0);\n    }\n\n    public min() : T {\n        return this.elem;\n    }\n\n    public empty() : boolean {\n        return this.elem == null;\n    }\n\n    public contains(h: PairingHeap<T>): boolean {\n        if (this === h) return true;\n        for (var i = 0; i < this.subheaps.length; i++) {\n            if (this.subheaps[i].contains(h)) return true;\n        }\n        return false;\n    }\n\n    public isHeap(lessThan: (a: T, b: T) => boolean): boolean {\n        return this.subheaps.every(h=> lessThan(this.elem, h.elem) && h.isHeap(lessThan));\n    }\n\n    public insert(obj : T, lessThan) : PairingHeap<T> {\n        return this.merge(new PairingHeap<T>(obj), lessThan);\n    }\n\n    public merge(heap2: PairingHeap<T>, lessThan): PairingHeap<T> {\n        if (this.empty()) return heap2;\n        else if (heap2.empty()) return this;\n        else if (lessThan(this.elem, heap2.elem)) {\n            this.subheaps.push(heap2);\n            return this;\n        } else {\n            heap2.subheaps.push(this);\n            return heap2;\n        }\n    }\n\n    public removeMin(lessThan: (a: T, b: T) => boolean): PairingHeap<T> {\n        if (this.empty()) return null;\n        else return this.mergePairs(lessThan);\n    }\n\n    public mergePairs(lessThan: (a: T, b: T) => boolean) : PairingHeap<T> {\n        if (this.subheaps.length == 0) return new PairingHeap<T>(null);\n        else if (this.subheaps.length == 1) { return this.subheaps[0]; }\n        else {\n            var firstPair = this.subheaps.pop().merge(this.subheaps.pop(), lessThan);\n            var remaining = this.mergePairs(lessThan);\n            return firstPair.merge(remaining, lessThan);\n        }\n    }\n    public decreaseKey(subheap: PairingHeap<T>, newValue: T, setHeapNode: (e: T, h: PairingHeap<T>)=>void, lessThan: (a: T, b: T) => boolean): PairingHeap<T> {\n        var newHeap = subheap.removeMin(lessThan);\n        //reassign subheap values to preserve tree\n        subheap.elem = newHeap.elem;\n        subheap.subheaps = newHeap.subheaps;\n        if (setHeapNode !== null && newHeap.elem !== null) {\n            setHeapNode(subheap.elem, subheap);\n        }\n        var pairingNode = new PairingHeap(newValue);\n        if (setHeapNode !== null) {\n            setHeapNode(newValue, pairingNode);\n        }\n        return this.merge(pairingNode, lessThan);\n    }\n}\n\n/**\n * @class PriorityQueue a min priority queue backed by a pairing heap\n */\nexport class PriorityQueue<T> {\n    private root : PairingHeap<T>;\n    constructor(private lessThan: (a: T, b: T) => boolean) { }\n    /**\n     * @method top\n     * @return the top element (the min element as defined by lessThan)\n     */\n    public top() : T {\n        if (this.empty()) { return null; }\n        return this.root.elem;\n    }\n    /**\n     * @method push\n     * put things on the heap\n     */\n    public push(...args: T[]): PairingHeap<T> {\n        var pairingNode;\n        for (var i = 0, arg; arg=args[i]; ++i) {\n            pairingNode = new PairingHeap(arg);\n            this.root = this.empty() ?\n                pairingNode : this.root.merge(pairingNode, this.lessThan);\n        }\n        return pairingNode;\n    }\n    /**\n     * @method empty\n     * @return true if no more elements in queue\n     */\n    public empty(): boolean {\n        return !this.root || !this.root.elem;\n    }\n    /**\n     * @method isHeap check heap condition (for testing)\n     * @return true if queue is in valid state\n     */\n    public isHeap(): boolean {\n        return this.root.isHeap(this.lessThan);\n    }\n    /**\n     * @method forEach apply f to each element of the queue\n     * @param f function to apply\n     */\n    public forEach(f) {\n        this.root.forEach(f);\n    }\n    /**\n     * @method pop remove and return the min element from the queue\n     */\n    public pop(): T {\n        if (this.empty()) {\n            return null;\n        }\n        var obj = this.root.min();\n        this.root = this.root.removeMin(this.lessThan);\n        return obj;\n    }\n    /**\n     * @method reduceKey reduce the key value of the specified heap node\n     */\n    public reduceKey(heapNode: PairingHeap<T>, newKey: T, setHeapNode: (e: T, h: PairingHeap<T>)=>void = null): void {\n        this.root = this.root.decreaseKey(heapNode, newKey, setHeapNode, this.lessThan);\n    }\n    public toString(selector) {\n        return this.root.toString(selector);\n    }\n    /**\n     * @method count\n     * @return number of elements in queue\n     */\n    public count() {\n        return this.root.count();\n    }\n}\n","import {PairingHeap, PriorityQueue} from './pqueue'\n\nclass Neighbour {\n    constructor(public id: number, public distance: number) { }\n}\n\nclass Node {\n    constructor(public id: number) {\n        this.neighbours = [];\n    }\n    neighbours: Neighbour[];\n    d: number;\n    prev: Node;\n    q: PairingHeap<Node>;\n}\n\nclass QueueEntry {\n    constructor(public node: Node, public prev: QueueEntry, public d: number) {}\n}\n\n/**\n * calculates all-pairs shortest paths or shortest paths from a single node\n * @class Calculator\n * @constructor\n * @param n {number} number of nodes\n * @param es {Edge[]} array of edges\n */\nexport class Calculator<Link> {\n    private neighbours: Node[];\n\n    constructor(public n: number, public es: Link[], getSourceIndex: (l: Link) => number, getTargetIndex: (l: Link) => number, getLength: (l: Link) => number) {\n        this.neighbours = new Array(this.n);\n        var i = this.n; while (i--) this.neighbours[i] = new Node(i);\n\n        i = this.es.length; while (i--) {\n            var e = this.es[i];\n            var u: number = getSourceIndex(e), v: number = getTargetIndex(e);\n            var d = getLength(e);\n            this.neighbours[u].neighbours.push(new Neighbour(v, d));\n            this.neighbours[v].neighbours.push(new Neighbour(u, d));\n        }\n    }\n\n    /**\n     * compute shortest paths for graph over n nodes with edges an array of source/target pairs\n     * edges may optionally have a length attribute.  1 is the default.\n     * Uses Johnson's algorithm.\n     *\n     * @method DistanceMatrix\n     * @return the distance matrix\n     */\n    DistanceMatrix(): number[][] {\n        var D = new Array(this.n);\n        for (var i = 0; i < this.n; ++i) {\n            D[i] = this.dijkstraNeighbours(i);\n        }\n        return D;\n    }\n\n    /**\n     * get shortest paths from a specified start node\n     * @method DistancesFromNode\n     * @param start node index\n     * @return array of path lengths\n     */\n    DistancesFromNode(start: number): number[] {\n        return this.dijkstraNeighbours(start);\n    }\n\n    PathFromNodeToNode(start: number, end: number): number[] {\n        return this.dijkstraNeighbours(start, end);\n    }\n\n    // find shortest path from start to end, with the opportunity at\n    // each edge traversal to compute a custom cost based on the\n    // previous edge.  For example, to penalise bends.\n    PathFromNodeToNodeWithPrevCost(\n        start: number,\n        end: number,\n        prevCost: (u:number,v:number,w:number)=>number): number[]\n    {\n        var q = new PriorityQueue<QueueEntry>((a, b) => a.d <= b.d),\n            u: Node = this.neighbours[start],\n            qu: QueueEntry = new QueueEntry(u,null,0),\n            visitedFrom = {};\n        q.push(qu);\n        while(!q.empty()) {\n            qu = q.pop();\n            u = qu.node;\n            if (u.id === end) {\n                break;\n            }\n            var i = u.neighbours.length; while (i--) {\n                var neighbour = u.neighbours[i],\n                    v = this.neighbours[neighbour.id];\n\n                // don't double back\n                if (qu.prev && v.id === qu.prev.node.id) continue;\n\n                // don't retraverse an edge if it has already been explored\n                // from a lower cost route\n                var viduid = v.id + ',' + u.id;\n                if(viduid in visitedFrom && visitedFrom[viduid] <= qu.d)\n                    continue;\n\n                var cc = qu.prev ? prevCost(qu.prev.node.id, u.id, v.id) : 0,\n                    t = qu.d + neighbour.distance + cc;\n\n                // store cost of this traversal\n                visitedFrom[viduid] = t;\n                q.push(new QueueEntry(v, qu, t));\n            }\n        }\n        var path:number[] = [];\n        while (qu.prev) {\n            qu = qu.prev;\n            path.push(qu.node.id);\n        }\n        return path;\n    }\n\n    private dijkstraNeighbours(start: number, dest: number = -1): number[] {\n        var q = new PriorityQueue<Node>((a, b) => a.d <= b.d),\n            i = this.neighbours.length,\n            d: number[] = new Array(i);\n        while (i--) {\n            var node: Node = this.neighbours[i];\n            node.d = i === start ? 0 : Number.POSITIVE_INFINITY;\n            node.q = q.push(node);\n        }\n        while (!q.empty()) {\n            // console.log(q.toString(function (u) { return u.id + \"=\" + (u.d === Number.POSITIVE_INFINITY ? \"\\u221E\" : u.d.toFixed(2) )}));\n            var u = q.pop();\n            d[u.id] = u.d;\n            if (u.id === dest) {\n                var path: number[] = [];\n                var v = u;\n                while (typeof v.prev !== 'undefined') {\n                    path.push(v.prev.id);\n                    v = v.prev;\n                }\n                return path;\n            }\n            i = u.neighbours.length; while (i--) {\n                var neighbour = u.neighbours[i];\n                var v = this.neighbours[neighbour.id];\n                var t = u.d + neighbour.distance;\n                if (u.d !== Number.MAX_VALUE && v.d > t) {\n                    v.d = t;\n                    v.prev = u;\n                    q.reduceKey(v.q, v, (e,q)=>e.q = q);\n                }\n            }\n        }\n        return d;\n    }\n}\n","import {Rectangle} from './rectangle'\n    export class Point {\n        x: number;\n        y: number;\n    }\n\n    export class LineSegment {\n        constructor(public x1: number, public y1: number, public x2: number, public y2: number) { }\n    }\n\n    export class PolyPoint extends Point {\n        polyIndex: number;\n    }\n\n    /** tests if a point is Left|On|Right of an infinite line.\n     * @param points P0, P1, and P2\n     * @return >0 for P2 left of the line through P0 and P1\n     *            =0 for P2 on the line\n     *            <0 for P2 right of the line\n     */\n    export function isLeft(P0: Point, P1: Point, P2: Point): number {\n        return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);\n    }\n\n    function above(p: Point, vi: Point, vj: Point): boolean {\n        return isLeft(p, vi, vj) > 0;\n    }\n\n    function below(p: Point, vi: Point, vj: Point): boolean {\n        return isLeft(p, vi, vj) < 0;\n    }\n\n\n    /**\n     * returns the convex hull of a set of points using Andrew's monotone chain algorithm\n     * see: http://geomalgorithms.com/a10-_hull-1.html#Monotone%20Chain\n     * @param S array of points\n     * @return the convex hull as an array of points\n     */\n    export function ConvexHull(S: Point[]): Point[] {\n        var P = S.slice(0).sort((a, b) => a.x !== b.x ? b.x - a.x : b.y - a.y);\n        var n = S.length, i;\n        var minmin = 0;\n        var xmin = P[0].x;\n        for (i = 1; i < n; ++i) {\n            if (P[i].x !== xmin) break;\n        }\n        var minmax = i - 1;\n        var H: Point[] = [];\n        H.push(P[minmin]); // push minmin point onto stack\n        if (minmax === n - 1) { // degenerate case: all x-coords == xmin\n            if (P[minmax].y !== P[minmin].y) // a  nontrivial segment\n                H.push(P[minmax]);\n        } else {\n            // Get the indices of points with max x-coord and min|max y-coord\n            var maxmin, maxmax = n - 1;\n            var xmax = P[n - 1].x;\n            for (i = n - 2; i >= 0; i--)\n                if (P[i].x !== xmax) break;\n            maxmin = i + 1;\n\n            // Compute the lower hull on the stack H\n            i = minmax;\n            while (++i <= maxmin) {\n                // the lower line joins P[minmin]  with P[maxmin]\n                if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin)\n                    continue; // ignore P[i] above or on the lower line\n\n                while (H.length > 1) // there are at least 2 points on the stack\n                {\n                    // test if  P[i] is left of the line at the stack top\n                    if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\n                        break; // P[i] is a new hull  vertex\n                    else\n                        H.length -= 1; // pop top point off  stack\n                }\n                if (i != minmin) H.push(P[i]);\n            }\n\n            // Next, compute the upper hull on the stack H above the bottom hull\n            if (maxmax != maxmin) // if  distinct xmax points\n                H.push(P[maxmax]); // push maxmax point onto stack\n            var bot = H.length; // the bottom point of the upper hull stack\n            i = maxmin;\n            while (--i >= minmax) {\n                // the upper line joins P[maxmax]  with P[minmax]\n                if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax)\n                    continue; // ignore P[i] below or on the upper line\n\n                while (H.length > bot) // at least 2 points on the upper stack\n                {\n                    // test if  P[i] is left of the line at the stack top\n                    if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\n                        break; // P[i] is a new hull  vertex\n                    else\n                        H.length -= 1; // pop top point off  stack\n                }\n                if (i != minmin) H.push(P[i]); // push P[i] onto stack\n            }\n        }\n        return H;\n    }\n\n    // apply f to the points in P in clockwise order around the point p\n    export function clockwiseRadialSweep(p: Point, P: Point[], f: (p: Point) => void) {\n        P.slice(0).sort(\n            (a, b) => Math.atan2(a.y - p.y, a.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x)\n            ).forEach(f);\n    }\n\n    function nextPolyPoint(p: PolyPoint, ps: PolyPoint[]): PolyPoint {\n        if (p.polyIndex === ps.length - 1) return ps[0];\n        return ps[p.polyIndex + 1];\n    }\n\n    function prevPolyPoint(p: PolyPoint, ps: PolyPoint[]): PolyPoint {\n        if (p.polyIndex === 0) return ps[ps.length - 1];\n        return ps[p.polyIndex - 1];\n    }\n\n    // tangent_PointPolyC(): fast binary search for tangents to a convex polygon\n    //    Input:  P = a 2D point (exterior to the polygon)\n    //            n = number of polygon vertices\n    //            V = array of vertices for a 2D convex polygon\n    //    Output: rtan = index of rightmost tangent point V[rtan]\n    //            ltan = index of leftmost tangent point V[ltan]\n    function tangent_PointPolyC(P: Point, V: Point[]): { rtan: number; ltan: number } {\n        // Rtangent_PointPolyC and Ltangent_PointPolyC require polygon to be\n        // \"closed\" with the first vertex duplicated at end, so V[n-1] = V[0].\n        let Vclosed = V.slice(0);  // Copy V\n        Vclosed.push(V[0]);        // Add V[0] at end\n\n        return { rtan: Rtangent_PointPolyC(P, Vclosed), ltan: Ltangent_PointPolyC(P, Vclosed) };\n    }\n\n\n    // Rtangent_PointPolyC(): binary search for convex polygon right tangent\n    //    Input:  P = a 2D point (exterior to the polygon)\n    //            n = number of polygon vertices\n    //            V = array of vertices for a 2D convex polygon with first\n    //                vertex duplicated as last, so V[n-1] = V[0]\n    //    Return: index \"i\" of rightmost tangent point V[i]\n    function Rtangent_PointPolyC(P: Point, V: Point[]): number {\n        var n = V.length - 1;\n\n        // use binary search for large convex polygons\n        var a: number, b: number, c: number;            // indices for edge chain endpoints\n        var upA: boolean, dnC: boolean;           // test for up direction of edges a and c\n\n        // rightmost tangent = maximum for the isLeft() ordering\n        // test if V[0] is a local maximum\n        if (below(P, V[1], V[0]) && !above(P, V[n - 1], V[0]))\n            return 0;               // V[0] is the maximum tangent point\n\n        for (a = 0, b = n; ;) {          // start chain = [0,n] with V[n]=V[0]\n            if (b - a === 1)\n                if (above(P, V[a], V[b]))\n                    return a;\n                else\n                    return b;\n\n            c = Math.floor((a + b) / 2);        // midpoint of [a,b], and 0<c<n\n            dnC = below(P, V[c + 1], V[c]);\n            if (dnC && !above(P, V[c - 1], V[c]))\n                return c;          // V[c] is the maximum tangent point\n\n            // no max yet, so continue with the binary search\n            // pick one of the two subchains [a,c] or [c,b]\n            upA = above(P, V[a + 1], V[a]);\n            if (upA) {                       // edge a points up\n                if (dnC)                         // edge c points down\n                    b = c;                           // select [a,c]\n                else {                           // edge c points up\n                    if (above(P, V[a], V[c]))     // V[a] above V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] below V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n            else {                           // edge a points down\n                if (!dnC)                        // edge c points up\n                    a = c;                           // select [c,b]\n                else {                           // edge c points down\n                    if (below(P, V[a], V[c]))     // V[a] below V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] above V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n        }\n    }\n\n    // Ltangent_PointPolyC(): binary search for convex polygon left tangent\n    //    Input:  P = a 2D point (exterior to the polygon)\n    //            n = number of polygon vertices\n    //            V = array of vertices for a 2D convex polygon with first\n    //                vertex duplicated as last, so V[n-1] = V[0]\n    //    Return: index \"i\" of leftmost tangent point V[i]\n    function Ltangent_PointPolyC(P: Point, V: Point[]): number {\n        var n = V.length - 1;\n        // use binary search for large convex polygons\n        var a: number, b: number, c: number;             // indices for edge chain endpoints\n        var dnA: boolean, dnC: boolean;           // test for down direction of edges a and c\n\n        // leftmost tangent = minimum for the isLeft() ordering\n        // test if V[0] is a local minimum\n        if (above(P, V[n - 1], V[0]) && !below(P, V[1], V[0]))\n            return 0;               // V[0] is the minimum tangent point\n\n        for (a = 0, b = n; ;) {          // start chain = [0,n] with V[n] = V[0]\n            if (b - a === 1)\n                if (below(P, V[a], V[b]))\n                    return a;\n                else\n                    return b;\n\n            c = Math.floor((a + b) / 2);        // midpoint of [a,b], and 0<c<n\n            dnC = below(P, V[c + 1], V[c]);\n            if (above(P, V[c - 1], V[c]) && !dnC)\n                return c;          // V[c] is the minimum tangent point\n\n            // no min yet, so continue with the binary search\n            // pick one of the two subchains [a,c] or [c,b]\n            dnA = below(P, V[a + 1], V[a]);\n            if (dnA) {                       // edge a points down\n                if (!dnC)                        // edge c points up\n                    b = c;                           // select [a,c]\n                else {                           // edge c points down\n                    if (below(P, V[a], V[c]))     // V[a] below V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] above V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n            else {                           // edge a points up\n                if (dnC)                         // edge c points down\n                    a = c;                           // select [c,b]\n                else {                           // edge c points up\n                    if (above(P, V[a], V[c]))     // V[a] above V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] below V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n        }\n    }\n\n    // RLtangent_PolyPolyC(): get the RL tangent between two convex polygons\n    //    Input:  m = number of vertices in polygon 1\n    //            V = array of vertices for convex polygon 1 with V[m]=V[0]\n    //            n = number of vertices in polygon 2\n    //            W = array of vertices for convex polygon 2 with W[n]=W[0]\n    //    Output: *t1 = index of tangent point V[t1] for polygon 1\n    //            *t2 = index of tangent point W[t2] for polygon 2\n    export function tangent_PolyPolyC(V: Point[], W: Point[], t1: (a: Point, b: Point[]) => number, t2: (a: Point, b: Point[]) => number, cmp1: (a: Point, b: Point, c: Point) => boolean, cmp2: (a: Point, b: Point, c: Point) => boolean): { t1: number; t2: number } {\n        var ix1: number, ix2: number;      // search indices for polygons 1 and 2\n\n        // first get the initial vertex on each polygon\n        ix1 = t1(W[0], V);   // right tangent from W[0] to V\n        ix2 = t2(V[ix1], W); // left tangent from V[ix1] to W\n\n        // ping-pong linear search until it stabilizes\n        var done = false;                    // flag when done\n        while (!done) {\n            done = true;                     // assume done until...\n            while (true) {\n                if (ix1 === V.length - 1) ix1 = 0;\n                if (cmp1(W[ix2], V[ix1], V[ix1 + 1])) break;\n                ++ix1;                       // get Rtangent from W[ix2] to V\n            }\n            while (true) {\n                if (ix2 === 0) ix2 = W.length - 1;\n                if (cmp2(V[ix1], W[ix2], W[ix2 - 1])) break;\n                --ix2;                       // get Ltangent from V[ix1] to W\n                done = false;                // not done if had to adjust this\n            }\n        }\n        return { t1: ix1, t2: ix2 };\n    }\n\n    export function LRtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        var rl = RLtangent_PolyPolyC(W, V);\n        return { t1: rl.t2, t2: rl.t1 };\n    }\n\n    export function RLtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above, below);\n    }\n\n    export function LLtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);\n    }\n\n    export function RRtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above, above);\n    }\n\n    export class BiTangent {\n        constructor(public t1: number, public t2: number) { }\n    }\n\n    export class BiTangents {\n        rl: BiTangent;\n        lr: BiTangent;\n        ll: BiTangent;\n        rr: BiTangent;\n    }\n\n    export class TVGPoint extends Point {\n        vv: VisibilityVertex;\n    }\n\n    export class VisibilityVertex {\n        constructor(\n            public id: number,\n            public polyid: number,\n            public polyvertid: number,\n            public p: TVGPoint)\n        {\n            p.vv = this;\n        }\n    }\n\n    export class VisibilityEdge {\n        constructor(\n            public source: VisibilityVertex,\n            public target: VisibilityVertex) { }\n        length(): number {\n            var dx = this.source.p.x - this.target.p.x;\n            var dy = this.source.p.y - this.target.p.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n    }\n\n    export class TangentVisibilityGraph {\n        V: VisibilityVertex[] = [];\n        E: VisibilityEdge[] = [];\n        constructor(public P: TVGPoint[][], g0?: { V: VisibilityVertex[]; E: VisibilityEdge[] }) {\n            if (!g0) {\n                var n = P.length;\n                // For each node...\n                for (var i = 0; i < n; i++) {\n                    var p = P[i];\n                    // For each node vertex.\n                    for (var j = 0; j < p.length; ++j) {\n                        var pj = p[j],\n                            vv = new VisibilityVertex(this.V.length, i, j, pj);\n                        this.V.push(vv);\n                        // For the every iteration but the first, generate an\n                        // edge from the previous visibility vertex to the\n                        // current one.\n                        if (j > 0) this.E.push(new VisibilityEdge(p[j - 1].vv, vv));\n                    }\n                    // Add a visibility edge from the first vertex to the last.\n                    if (p.length > 1) this.E.push(new VisibilityEdge(p[0].vv, p[p.length - 1].vv));\n                }\n                for (var i = 0; i < n - 1; i++) {\n                    var Pi = P[i];\n                    for (var j = i + 1; j < n; j++) {\n                        var Pj = P[j],\n                            t = tangents(Pi, Pj);\n                        for (var q in t) {\n                            var c = t[q],\n                                source = Pi[c.t1], target = Pj[c.t2];\n                            this.addEdgeIfVisible(source, target, i, j);\n                        }\n                    }\n                }\n            } else {\n                this.V = g0.V.slice(0);\n                this.E = g0.E.slice(0);\n            }\n        }\n        addEdgeIfVisible(u: TVGPoint, v: TVGPoint, i1: number, i2: number) {\n            if (!this.intersectsPolys(new LineSegment(u.x, u.y, v.x, v.y), i1, i2)) {\n                this.E.push(new VisibilityEdge(u.vv, v.vv));\n            }\n        }\n        addPoint(p: TVGPoint, i1: number): VisibilityVertex {\n            var n = this.P.length;\n            this.V.push(new VisibilityVertex(this.V.length, n, 0, p));\n            for (var i = 0; i < n; ++i) {\n                if (i === i1) continue;\n                var poly = this.P[i],\n                    t = tangent_PointPolyC(p, poly);\n                this.addEdgeIfVisible(p, poly[t.ltan], i1, i);\n                this.addEdgeIfVisible(p, poly[t.rtan], i1, i);\n            }\n            return p.vv;\n        }\n        private intersectsPolys(l: LineSegment, i1: number, i2: number): boolean {\n            for (var i = 0, n = this.P.length; i < n; ++i) {\n                if (i != i1 && i != i2 && intersects(l, this.P[i]).length > 0) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    function intersects(l: LineSegment, P: Point[]) {\n        var ints = [];\n        for (var i = 1, n = P.length; i < n; ++i) {\n            var int = Rectangle.lineIntersection(\n                l.x1, l.y1,\n                l.x2, l.y2,\n                P[i - 1].x, P[i - 1].y,\n                P[i].x, P[i].y\n                );\n            if (int) ints.push(int);\n        }\n        return ints;\n    }\n\n    export function tangents(V: Point[], W: Point[]): BiTangents\n    {\n        var m = V.length - 1, n = W.length - 1;\n        var bt = new BiTangents();\n        for (var i = 0; i <= m; ++i) {\n            for (var j = 0; j <= n; ++j) {\n                var v1 = V[i == 0 ? m : i - 1];\n                var v2 = V[i];\n                var v3 = V[i == m ? 0 : i + 1];\n                var w1 = W[j == 0 ? n : j - 1];\n                var w2 = W[j];\n                var w3 = W[j == n ? 0 : j + 1];\n                var v1v2w2 = isLeft(v1, v2, w2);\n                var v2w1w2 = isLeft(v2, w1, w2);\n                var v2w2w3 = isLeft(v2, w2, w3);\n                var w1w2v2 = isLeft(w1, w2, v2);\n                var w2v1v2 = isLeft(w2, v1, v2);\n                var w2v2v3 = isLeft(w2, v2, v3);\n                if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0\n                    && w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {\n                        bt.ll = new BiTangent(i, j);\n                } else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0\n                    && w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {\n                        bt.rr = new BiTangent(i, j);\n                } else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0\n                    && w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {\n                        bt.rl = new BiTangent(i, j);\n                } else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0\n                    && w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {\n                        bt.lr = new BiTangent(i, j);\n                }\n            }\n        }\n        return bt;\n    }\n\n    function isPointInsidePoly(p: Point, poly: Point[]): boolean {\n        for (var i = 1, n = poly.length; i < n; ++i)\n            if (below(poly[i - 1], poly[i], p)) return false;\n        return true;\n    }\n\n    function isAnyPInQ(p: Point[], q: Point[]): boolean {\n        return !p.every(v => !isPointInsidePoly(v, q));\n    }\n\n    export function polysOverlap(p: Point[], q: Point[]): boolean {\n        if (isAnyPInQ(p, q)) return true;\n        if (isAnyPInQ(q, p)) return true;\n        for (var i = 1, n = p.length; i < n; ++i) {\n            var v = p[i], u = p[i - 1];\n            if (intersects(new LineSegment(u.x, u.y, v.x, v.y), q).length > 0) return true;\n        }\n        return false;\n    }\n","    var packingOptions = {\n        PADDING: 10,\n        GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,\n        FLOAT_EPSILON: 0.0001,\n        MAX_INERATIONS: 100\n    };\n\n    // assign x, y to nodes while using box packing algorithm for disconnected graphs\n    export function applyPacking(graphs:Array<any>, w, h, node_size, desired_ratio = 1, centerGraph = true) {\n\n        var init_x = 0,\n            init_y = 0,\n\n            svg_width = w,\n            svg_height = h,\n\n            desired_ratio = typeof desired_ratio !== 'undefined' ? desired_ratio : 1,\n            node_size = typeof node_size !== 'undefined' ? node_size : 0,\n\n            real_width = 0,\n            real_height = 0,\n            min_width = 0,\n\n            global_bottom = 0,\n            line = [];\n\n        if (graphs.length == 0)\n            return;\n\n        /// that would take care of single nodes problem\n        // graphs.forEach(function (g) {\n        //     if (g.array.length == 1) {\n        //         g.array[0].x = 0;\n        //         g.array[0].y = 0;\n        //     }\n        // });\n\n        calculate_bb(graphs);\n        apply(graphs, desired_ratio);\n        if(centerGraph) {\n            put_nodes_to_right_positions(graphs);\n        }\n\n        // get bounding boxes for all separate graphs\n        function calculate_bb(graphs) {\n\n            graphs.forEach(function (g) {\n                calculate_single_bb(g)\n            });\n\n            function calculate_single_bb(graph) {\n                var min_x = Number.MAX_VALUE, min_y = Number.MAX_VALUE,\n                    max_x = 0, max_y = 0;\n\n                graph.array.forEach(function (v) {\n                    var w = typeof v.width !== 'undefined' ? v.width : node_size;\n                    var h = typeof v.height !== 'undefined' ? v.height : node_size;\n                    w /= 2;\n                    h /= 2;\n                    max_x = Math.max(v.x + w, max_x);\n                    min_x = Math.min(v.x - w, min_x);\n                    max_y = Math.max(v.y + h, max_y);\n                    min_y = Math.min(v.y - h, min_y);\n                });\n\n                graph.width = max_x - min_x;\n                graph.height = max_y - min_y;\n            }\n        }\n\n        //function plot(data, left, right, opt_x, opt_y) {\n        //    // plot the cost function\n        //    var plot_svg = d3.select(\"body\").append(\"svg\")\n        //        .attr(\"width\", function () { return 2 * (right - left); })\n        //        .attr(\"height\", 200);\n\n\n        //    var x = d3.time.scale().range([0, 2 * (right - left)]);\n\n        //    var xAxis = d3.svg.axis().scale(x).orient(\"bottom\");\n        //    plot_svg.append(\"g\").attr(\"class\", \"x axis\")\n        //        .attr(\"transform\", \"translate(0, 199)\")\n        //        .call(xAxis);\n\n        //    var lastX = 0;\n        //    var lastY = 0;\n        //    var value = 0;\n        //    for (var r = left; r < right; r += 1) {\n        //        value = step(data, r);\n        //        // value = 1;\n\n        //        plot_svg.append(\"line\").attr(\"x1\", 2 * (lastX - left))\n        //            .attr(\"y1\", 200 - 30 * lastY)\n        //            .attr(\"x2\", 2 * r - 2 * left)\n        //            .attr(\"y2\", 200 - 30 * value)\n        //            .style(\"stroke\", \"rgb(6,120,155)\");\n\n        //        lastX = r;\n        //        lastY = value;\n        //    }\n\n        //    plot_svg.append(\"circle\").attr(\"cx\", 2 * opt_x - 2 * left).attr(\"cy\", 200 - 30 * opt_y)\n        //        .attr(\"r\", 5).style('fill', \"rgba(0,0,0,0.5)\");\n\n        //}\n\n        // actual assigning of position to nodes\n        function put_nodes_to_right_positions(graphs) {\n            graphs.forEach(function (g) {\n                // calculate current graph center:\n                var center = { x: 0, y: 0 };\n\n                g.array.forEach(function (node) {\n                    center.x += node.x;\n                    center.y += node.y;\n                });\n\n                center.x /= g.array.length;\n                center.y /= g.array.length;\n\n                // calculate current top left corner:\n                var corner = { x: center.x - g.width / 2, y: center.y - g.height / 2 };\n                var offset = { x: g.x - corner.x + svg_width / 2 - real_width / 2, y: g.y - corner.y + svg_height / 2 - real_height / 2};\n\n                // put nodes:\n                g.array.forEach(function (node) {\n                    node.x += offset.x;\n                    node.y += offset.y;\n                });\n            });\n        }\n\n        // starts box packing algorithm\n        // desired ratio is 1 by default\n        function apply(data, desired_ratio) {\n            var curr_best_f = Number.POSITIVE_INFINITY;\n            var curr_best = 0;\n            data.sort(function (a, b) { return b.height - a.height; });\n\n            min_width = data.reduce(function (a, b) {\n                return a.width < b.width ? a.width : b.width;\n            });\n\n            var left = x1 = min_width;\n            var right = x2 = get_entire_width(data);\n            var iterationCounter = 0;\n\n            var f_x1 = Number.MAX_VALUE;\n            var f_x2 = Number.MAX_VALUE;\n            var flag = -1; // determines which among f_x1 and f_x2 to recompute\n\n\n            var dx = Number.MAX_VALUE;\n            var df = Number.MAX_VALUE;\n\n            while ((dx > min_width) || df > packingOptions.FLOAT_EPSILON) {\n\n                if (flag != 1) {\n                    var x1 = right - (right - left) / packingOptions.GOLDEN_SECTION;\n                    var f_x1 = step(data, x1);\n                }\n                if (flag != 0) {\n                    var x2 = left + (right - left) / packingOptions.GOLDEN_SECTION;\n                    var f_x2 = step(data, x2);\n                }\n\n                dx = Math.abs(x1 - x2);\n                df = Math.abs(f_x1 - f_x2);\n\n                if (f_x1 < curr_best_f) {\n                    curr_best_f = f_x1;\n                    curr_best = x1;\n                }\n\n                if (f_x2 < curr_best_f) {\n                    curr_best_f = f_x2;\n                    curr_best = x2;\n                }\n\n                if (f_x1 > f_x2) {\n                    left = x1;\n                    x1 = x2;\n                    f_x1 = f_x2;\n                    flag = 1;\n                } else {\n                    right = x2;\n                    x2 = x1;\n                    f_x2 = f_x1;\n                    flag = 0;\n                }\n\n                if (iterationCounter++ > 100) {\n                    break;\n                }\n            }\n            // plot(data, min_width, get_entire_width(data), curr_best, curr_best_f);\n            step(data, curr_best);\n        }\n\n        // one iteration of the optimization method\n        // (gives a proper, but not necessarily optimal packing)\n        function step(data, max_width) {\n            line = [];\n            real_width = 0;\n            real_height = 0;\n            global_bottom = init_y;\n\n            for (var i = 0; i < data.length; i++) {\n                var o = data[i];\n                put_rect(o, max_width);\n            }\n\n            return Math.abs(get_real_ratio() - desired_ratio);\n        }\n\n        // looking for a position to one box\n        function put_rect(rect, max_width) {\n\n\n            var parent = undefined;\n\n            for (var i = 0; i < line.length; i++) {\n                if ((line[i].space_left >= rect.height) && (line[i].x + line[i].width + rect.width + packingOptions.PADDING - max_width) <= packingOptions.FLOAT_EPSILON) {\n                    parent = line[i];\n                    break;\n                }\n            }\n\n            line.push(rect);\n\n            if (parent !== undefined) {\n                rect.x = parent.x + parent.width + packingOptions.PADDING;\n                rect.y = parent.bottom;\n                rect.space_left = rect.height;\n                rect.bottom = rect.y;\n                parent.space_left -= rect.height + packingOptions.PADDING;\n                parent.bottom += rect.height + packingOptions.PADDING;\n            } else {\n                rect.y = global_bottom;\n                global_bottom += rect.height + packingOptions.PADDING;\n                rect.x = init_x;\n                rect.bottom = rect.y;\n                rect.space_left = rect.height;\n            }\n\n            if (rect.y + rect.height - real_height > -packingOptions.FLOAT_EPSILON) real_height = rect.y + rect.height - init_y;\n            if (rect.x + rect.width - real_width > -packingOptions.FLOAT_EPSILON) real_width = rect.x + rect.width - init_x;\n        };\n\n        function get_entire_width(data) {\n            var width = 0;\n            data.forEach(function (d) { return width += d.width + packingOptions.PADDING; });\n            return width;\n        }\n\n        function get_real_ratio() {\n            return (real_width / real_height);\n        }\n    }\n\n    /**\n     * connected components of graph\n     * returns an array of {}\n     */\n    export function separateGraphs(nodes, links) {\n        var marks = {};\n        var ways = {};\n        var graphs = [];\n        var clusters = 0;\n\n        for (var i = 0; i < links.length; i++) {\n            var link = links[i];\n            var n1 = link.source;\n            var n2 = link.target;\n            if (ways[n1.index])\n                ways[n1.index].push(n2);\n            else\n                ways[n1.index] = [n2];\n\n            if (ways[n2.index])\n                ways[n2.index].push(n1);\n            else\n                ways[n2.index] = [n1];\n        }\n\n        for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n            if (marks[node.index]) continue;\n            explore_node(node, true);\n        }\n\n        function explore_node(n, is_new) {\n            if (marks[n.index] !== undefined) return;\n            if (is_new) {\n                clusters++;\n                graphs.push({ array: [] });\n            }\n            marks[n.index] = clusters;\n            graphs[clusters - 1].array.push(n);\n            var adjacent = ways[n.index];\n            if (!adjacent) return;\n\n            for (var j = 0; j < adjacent.length; j++) {\n                explore_node(adjacent[j], false);\n            }\n        }\n\n        return graphs;\n    }\n","import * as powergraph from './powergraph'\nimport {LinkLengthAccessor, symmetricDiffLinkLengths, jaccardLinkLengths, generateDirectedEdgeConstraints} from './linklengths'\nimport {Descent} from './descent'\nimport {Rectangle, Projection, makeEdgeTo, makeEdgeBetween} from './rectangle'\nimport {Calculator} from './shortestpaths'\nimport {TangentVisibilityGraph, TVGPoint} from './geom'\nimport {separateGraphs, applyPacking} from './handledisconnected'\n    /**\n     * The layout process fires three events:\n     *  - start: layout iterations started\n     *  - tick: fired once per iteration, listen to this to animate\n     *  - end: layout converged, you might like to zoom-to-fit or something at notification of this event\n     */\n    export enum EventType { start, tick, end };\n    export interface Event {\n        type: EventType;\n        alpha: number;\n        stress?: number;\n        listener?: () => void;\n    }\n    export interface InputNode {\n        /**\n         * index in nodes array, this is initialized by Layout.start()\n         */\n        index?: number;\n        /**\n         * x and y will be computed by layout as the Node's centroid\n         */\n        x?: number;\n        /**\n         * x and y will be computed by layout as the Node's centroid\n         */\n        y?: number;\n        /**\n         * specify a width and height of the node's bounding box if you turn on avoidOverlaps\n         */\n        width?: number;\n        /**\n         * specify a width and height of the node's bounding box if you turn on avoidOverlaps\n         */\n        height?: number;\n        /**\n         * selective bit mask.  !=0 means layout will not move.\n         */\n        fixed?: number;\n    }\n    export interface Node extends InputNode {\n      // Client-passed node may be missing these properties, which will be set\n      // upon ingestion\n      x: number;\n      y: number;\n    }\n\n    export interface Group {\n        bounds?: Rectangle;\n        leaves?: Node[];\n        groups?: Group[];\n        padding?: number;\n    }\n\n    function isGroup(g: any): g is Group {\n        return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';\n    }\n\n    export interface Link<NodeRefType> {\n        source: NodeRefType;\n        target: NodeRefType;\n\n        // ideal length the layout should try to achieve for this link\n        length?: number;\n\n        // how hard we should try to satisfy this link's ideal length\n        // must be in the range: 0 < weight <= 1\n        // if unspecified 1 is the default\n        weight?: number;\n    }\n\n    export type LinkNumericPropertyAccessor = (t: Link<Node | number>) => number;\n\n    export interface LinkLengthTypeAccessor extends LinkLengthAccessor<Link<Node | number>> {\n        getType: LinkNumericPropertyAccessor;\n    }\n    /**\n     * Main interface to cola layout.\n     * @class Layout\n     */\n    export class Layout {\n        private _canvasSize = [1, 1];\n        private _linkDistance: number | LinkNumericPropertyAccessor = 20;\n        private _defaultNodeSize: number = 10;\n        private _linkLengthCalculator = null;\n        private _linkType = null;\n        private _avoidOverlaps = false;\n        private _handleDisconnected = true;\n        private _alpha;\n        private _lastStress;\n        private _running = false;\n        private _nodes = [];\n        private _groups = [];\n        private _rootGroup = null;\n        private _links: Link<Node | number>[] = [];\n        private _constraints = [];\n        private _distanceMatrix = null;\n        private _descent: Descent = null;\n        private _directedLinkConstraints = null;\n        private _threshold = 0.01;\n        private _visibilityGraph = null;\n        private _groupCompactness = 1e-6;\n\n        // sub-class and override this property to replace with a more sophisticated eventing mechanism\n        protected event = null;\n\n        // subscribe a listener to an event\n        // sub-class and override this method to replace with a more sophisticated eventing mechanism\n        public on(e: EventType | string, listener: (event?: Event) => void): this {\n            // override me!\n            if (!this.event) this.event = {};\n            if (typeof e === 'string') {\n                this.event[EventType[e]] = listener;\n            } else {\n                this.event[e] = listener;\n            }\n            return this;\n        }\n\n        // a function that is notified of events like \"tick\"\n        // sub-classes can override this method to replace with a more sophisticated eventing mechanism\n        protected trigger(e: Event) {\n            if (this.event && typeof this.event[e.type] !== 'undefined') {\n                this.event[e.type](e);\n            }\n        }\n\n        // a function that kicks off the iteration tick loop\n        // it calls tick() repeatedly until tick returns true (is converged)\n        // subclass and override it with something fancier (e.g. dispatch tick on a timer)\n        protected kick(): void {\n            while (!this.tick());\n        }\n\n        /**\n         * iterate the layout.  Returns true when layout converged.\n         */\n        protected tick(): boolean {\n            if (this._alpha < this._threshold) {\n                this._running = false;\n                this.trigger({ type: EventType.end, alpha: this._alpha = 0, stress: this._lastStress });\n                return true;\n            }\n            const n = this._nodes.length,\n                  m = this._links.length;\n            let o, i;\n\n            this._descent.locks.clear();\n            for (i = 0; i < n; ++i) {\n                o = this._nodes[i];\n                if (o.fixed) {\n                    if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {\n                        o.px = o.x;\n                        o.py = o.y;\n                    }\n                    var p = [o.px, o.py];\n                    this._descent.locks.add(i, p);\n                }\n            }\n\n            let s1 = this._descent.rungeKutta();\n            //var s1 = descent.reduceStress();\n            if (s1 === 0) {\n                this._alpha = 0;\n            } else if (typeof this._lastStress !== 'undefined') {\n                this._alpha = s1; //Math.abs(Math.abs(this._lastStress / s1) - 1);\n            }\n            this._lastStress = s1;\n\n            this.updateNodePositions();\n\n            this.trigger({ type: EventType.tick, alpha: this._alpha, stress: this._lastStress });\n            return false;\n        }\n\n        // copy positions out of descent instance into each of the nodes' center coords\n        private updateNodePositions(): void {\n            const x = this._descent.x[0], y = this._descent.x[1];\n            let o, i = this._nodes.length;\n            while (i--) {\n                o = this._nodes[i];\n                o.x = x[i];\n                o.y = y[i];\n            }\n        }\n\n        /**\n         * the list of nodes.\n         * If nodes has not been set, but links has, then we instantiate a nodes list here, of the correct size,\n         * before returning it.\n         * @property nodes {Array}\n         * @default empty list\n         */\n        nodes(): Array<Node>\n        nodes(v: Array<InputNode>): this\n        nodes(v?: any): any {\n            if (!v) {\n                if (this._nodes.length === 0 && this._links.length > 0) {\n                    // if we have links but no nodes, create the nodes array now with empty objects for the links to point at.\n                    // in this case the links are expected to be numeric indices for nodes in the range 0..n-1 where n is the number of nodes\n                    var n = 0;\n                    this._links.forEach(function (l) {\n                        n = Math.max(n, <number>l.source, <number>l.target);\n                    });\n                    this._nodes = new Array(++n);\n                    for (var i = 0; i < n; ++i) {\n                        this._nodes[i] = {};\n                    }\n                }\n                return this._nodes;\n            }\n            this._nodes = v;\n            return this;\n        }\n\n        /**\n         * a list of hierarchical groups defined over nodes\n         * @property groups {Array}\n         * @default empty list\n         */\n        groups(): Array<Group>\n        groups(x: Array<Group>): this\n        groups(x?: Array<Group>): any {\n            if (!x) return this._groups;\n            this._groups = x;\n            this._rootGroup = {};\n            this._groups.forEach(g => {\n                if (typeof g.padding === \"undefined\")\n                    g.padding = 1;\n                if (typeof g.leaves !== \"undefined\") {\n                    g.leaves.forEach((v, i) => {\n                        if (typeof v === 'number')\n                            (g.leaves[i] = this._nodes[v]).parent = g\n                    });\n                }\n                if (typeof g.groups !== \"undefined\") {\n                    g.groups.forEach((gi, i) => {\n                        if (typeof gi === 'number')\n                            (g.groups[i] = this._groups[gi]).parent = g\n                    });\n                }\n            });\n            this._rootGroup.leaves = this._nodes.filter(v => typeof v.parent === 'undefined');\n            this._rootGroup.groups = this._groups.filter(g => typeof g.parent === 'undefined');\n            return this;\n        }\n\n        powerGraphGroups(f: Function): this {\n            var g = powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);\n            this.groups(g.groups);\n            f(g);\n            return this;\n        }\n\n        /**\n         * if true, the layout will not permit overlaps of the node bounding boxes (defined by the width and height properties on nodes)\n         * @property avoidOverlaps\n         * @type bool\n         * @default false\n         */\n        avoidOverlaps(): boolean\n        avoidOverlaps(v: boolean): this\n        avoidOverlaps(v?: boolean): any {\n            if (!arguments.length) return this._avoidOverlaps;\n            this._avoidOverlaps = v;\n            return this;\n        }\n\n        /**\n         * if true, the final step of the start method will be to nicely pack connected components of the graph.\n         * works best if start() is called with a reasonable number of iterations specified and\n         * each node has a bounding box (defined by the width and height properties on nodes).\n         * @property handleDisconnected\n         * @type bool\n         * @default true\n         */\n        handleDisconnected(): boolean\n        handleDisconnected(v: boolean): this\n        handleDisconnected(v?: boolean): any {\n            if (!arguments.length) return this._handleDisconnected;\n            this._handleDisconnected = v;\n            return this;\n        }\n\n        /**\n         * causes constraints to be generated such that directed graphs are laid out either from left-to-right or top-to-bottom.\n         * a separation constraint is generated in the selected axis for each edge that is not involved in a cycle (part of a strongly connected component)\n         * @param axis {string} 'x' for left-to-right, 'y' for top-to-bottom\n         * @param minSeparation {number|link=>number} either a number specifying a minimum spacing required across all links or a function to return the minimum spacing for each link\n         */\n        flowLayout(axis: string, minSeparation: number|((t: any)=>number)): this {\n            if (!arguments.length) axis = 'y';\n            this._directedLinkConstraints = {\n                axis: axis,\n                getMinSeparation: typeof minSeparation === 'number' ? function () { return minSeparation } : minSeparation\n            };\n            return this;\n        }\n\n        /**\n         * links defined as source, target pairs over nodes\n         * @property links {array}\n         * @default empty list\n         */\n        links(): Array<Link<Node|number>>\n        links(x: Array<Link<Node|number>>): this\n        links(x?: Array<Link<Node|number>>): any {\n            if (!arguments.length) return this._links;\n            this._links = x;\n            return this;\n        }\n\n        /**\n         * list of constraints of various types\n         * @property constraints\n         * @type {array}\n         * @default empty list\n         */\n        constraints(): Array<any>\n        constraints(c: Array<any>): this\n        constraints(c?: Array<any>): any {\n            if (!arguments.length) return this._constraints;\n            this._constraints = c;\n            return this;\n        }\n\n        /**\n         * Matrix of ideal distances between all pairs of nodes.\n         * If unspecified, the ideal distances for pairs of nodes will be based on the shortest path distance between them.\n         * @property distanceMatrix\n         * @type {Array of Array of Number}\n         * @default null\n         */\n        distanceMatrix(): Array<Array<number>>\n        distanceMatrix(d: Array<Array<number>>): this\n        distanceMatrix(d?: any): any {\n            if (!arguments.length) return this._distanceMatrix;\n            this._distanceMatrix = d;\n            return this;\n        }\n\n        /**\n         * Size of the layout canvas dimensions [x,y]. Currently only used to determine the midpoint which is taken as the starting position\n         * for nodes with no preassigned x and y.\n         * @property size\n         * @type {Array of Number}\n         */\n        size(): Array<number>\n        size(x: Array<number>): this\n        size(x?: Array<number>): any {\n            if (!x) return this._canvasSize;\n            this._canvasSize = x;\n            return this;\n        }\n\n        /**\n         * Default size (assume nodes are square so both width and height) to use in packing if node width/height are not specified.\n         * @property defaultNodeSize\n         * @type {Number}\n         */\n        defaultNodeSize(): number\n        defaultNodeSize(x: number): this\n        defaultNodeSize(x?: any): any {\n            if (!x) return this._defaultNodeSize;\n            this._defaultNodeSize = x;\n            return this;\n        }\n\n        /**\n         * The strength of attraction between the group boundaries to each other.\n         * @property defaultNodeSize\n         * @type {Number}\n         */\n        groupCompactness(): number\n        groupCompactness(x: number): this\n        groupCompactness(x?: any): any {\n            if (!x) return this._groupCompactness;\n            this._groupCompactness = x;\n            return this;\n        }\n\n        /**\n         * links have an ideal distance, The automatic layout will compute layout that tries to keep links (AKA edges) as close as possible to this length.\n         */\n        linkDistance(): number\n        linkDistance(): LinkNumericPropertyAccessor\n        linkDistance(x: number): this\n        linkDistance(x: LinkNumericPropertyAccessor): this\n        linkDistance(x?: any): any {\n            if (!x) {\n                return this._linkDistance;\n            }\n            this._linkDistance = typeof x === \"function\" ? x : +x;\n            this._linkLengthCalculator = null;\n            return this;\n        }\n\n        linkType(f: Function | number): this {\n            this._linkType = f;\n            return this;\n        }\n\n        convergenceThreshold(): number\n        convergenceThreshold(x: number): this\n        convergenceThreshold(x?: number): any {\n            if (!x) return this._threshold;\n            this._threshold = typeof x === \"function\" ? x : +x;\n            return this;\n        }\n\n        alpha(): number\n        alpha(x: number): this\n        alpha(x?: number): any {\n            if (!arguments.length) return this._alpha;\n            else {\n                x = +x;\n                if (this._alpha) { // if we're already running\n                    if (x > 0) this._alpha = x; // we might keep it hot\n                    else this._alpha = 0; // or, next tick will dispatch \"end\"\n                } else if (x > 0) { // otherwise, fire it up!\n                    if (!this._running) {\n                        this._running = true;\n                        this.trigger({ type: EventType.start, alpha: this._alpha = x});\n                        this.kick();\n                    }\n                }\n                return this;\n            }\n        }\n\n        getLinkLength(link: Link<Node | number>): number {\n            return typeof this._linkDistance === \"function\" ? +((<LinkNumericPropertyAccessor>this._linkDistance)(link)) : <number>this._linkDistance;\n        }\n\n        static setLinkLength(link: Link<Node|number>, length: number) {\n            link.length = length;\n        }\n\n        getLinkType(link: Link<Node | number>): number {\n            return typeof this._linkType === \"function\" ? this._linkType(link) : 0;\n        }\n\n        linkAccessor: LinkLengthTypeAccessor = {\n            getSourceIndex: Layout.getSourceIndex,\n            getTargetIndex: Layout.getTargetIndex,\n            setLength: Layout.setLinkLength,\n            getType: l => typeof this._linkType === \"function\" ? this._linkType(l) : 0\n        };\n\n        /**\n         * compute an ideal length for each link based on the graph structure around that link.\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: sqrt(|a union b| - |a intersection b|)\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\n         * don't have to have been assigned before invoking this function.\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\n         */\n        symmetricDiffLinkLengths(idealLength: number, w: number = 1): this {\n            this.linkDistance(l => idealLength * l.length);\n            this._linkLengthCalculator = () => symmetricDiffLinkLengths(this._links, this.linkAccessor, w);\n            return this;\n        }\n\n        /**\n         * compute an ideal length for each link based on the graph structure around that link.\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: |a intersection b|/|a union b|\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\n         * don't have to have been assigned before invoking this function.\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\n         */\n        jaccardLinkLengths(idealLength: number, w: number = 1): this {\n            this.linkDistance(l => idealLength * l.length);\n            this._linkLengthCalculator = () => jaccardLinkLengths(this._links, this.linkAccessor, w);\n            return this;\n        }\n\n        /**\n         * start the layout process\n         * @method start\n         * @param {number} [initialUnconstrainedIterations=0] unconstrained initial layout iterations\n         * @param {number} [initialUserConstraintIterations=0] initial layout iterations with user-specified constraints\n         * @param {number} [initialAllConstraintsIterations=0] initial layout iterations with all constraints including non-overlap\n         * @param {number} [gridSnapIterations=0] iterations of \"grid snap\", which pulls nodes towards grid cell centers - grid of size node[0].width - only really makes sense if all nodes have the same width and height\n         * @param [keepRunning=true] keep iterating asynchronously via the tick method\n         * @param [centerGraph=true] Center graph on restart\n         */\n        start(\n            initialUnconstrainedIterations: number = 0,\n            initialUserConstraintIterations: number = 0,\n            initialAllConstraintsIterations: number = 0,\n            gridSnapIterations: number = 0,\n            keepRunning = true,\n            centerGraph = true,\n        ): this {\n            var i: number,\n                j: number,\n                n = (<Array<any>>this.nodes()).length,\n                N = n + 2 * this._groups.length,\n                m = this._links.length,\n                w = this._canvasSize[0],\n                h = this._canvasSize[1];\n\n            var x = new Array(N), y = new Array(N);\n\n            var G = null;\n\n            var ao = this._avoidOverlaps;\n\n            this._nodes.forEach((v, i) => {\n                v.index = i;\n                if (typeof v.x === 'undefined') {\n                    v.x = w / 2, v.y = h / 2;\n                }\n                x[i] = v.x, y[i] = v.y;\n            });\n\n            if (this._linkLengthCalculator) this._linkLengthCalculator();\n\n            //should we do this to clearly label groups?\n            //this._groups.forEach((g, i) => g.groupIndex = i);\n\n            var distances;\n            if (this._distanceMatrix) {\n                // use the user specified distanceMatrix\n                distances = this._distanceMatrix;\n            } else {\n                // construct an n X n distance matrix based on shortest paths through graph (with respect to edge.length).\n                distances = (new Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, l=> this.getLinkLength(l))).DistanceMatrix();\n\n                // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\n                // otherwise 2. (\n                G = Descent.createSquareMatrix(N, () => 2);\n                this._links.forEach(l => {\n                    if (typeof l.source == \"number\") l.source = this._nodes[<number>l.source];\n                    if (typeof l.target == \"number\") l.target = this._nodes[<number>l.target];\n                });\n                this._links.forEach(e => {\n                    const u = Layout.getSourceIndex(e), v = Layout.getTargetIndex(e);\n                    G[u][v] = G[v][u] = e.weight || 1;\n                });\n            }\n\n            var D = Descent.createSquareMatrix(N, function (i, j) {\n                return distances[i][j];\n            });\n\n            if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {\n                var i = n;\n                var addAttraction = (i, j, strength, idealDistance) => {\n                    G[i][j] = G[j][i] = strength;\n                    D[i][j] = D[j][i] = idealDistance;\n                };\n                this._groups.forEach(g => {\n                    addAttraction(i, i + 1, this._groupCompactness, 0.1);\n\n                    // todo: add terms here attracting children of the group to the group dummy nodes\n                    //if (typeof g.leaves !== 'undefined')\n                    //    g.leaves.forEach(l => {\n                    //        addAttraction(l.index, i, 1e-4, 0.1);\n                    //        addAttraction(l.index, i + 1, 1e-4, 0.1);\n                    //    });\n                    //if (typeof g.groups !== 'undefined')\n                    //    g.groups.forEach(g => {\n                    //        var gid = n + g.groupIndex * 2;\n                    //        addAttraction(gid, i, 0.1, 0.1);\n                    //        addAttraction(gid + 1, i, 0.1, 0.1);\n                    //        addAttraction(gid, i + 1, 0.1, 0.1);\n                    //        addAttraction(gid + 1, i + 1, 0.1, 0.1);\n                    //    });\n\n                    if (typeof g.bounds === 'undefined') {\n                        x[i] = w / 2, y[i++] = h / 2;\n                        x[i] = w / 2, y[i++] = h / 2;\n                    } else {\n                        x[i] = g.bounds.x, y[i++] = g.bounds.y;\n                        x[i] = g.bounds.X, y[i++] = g.bounds.Y;\n                    }\n                });\n            } else this._rootGroup = { leaves: this._nodes, groups: [] };\n\n            var curConstraints = this._constraints || [];\n            if (this._directedLinkConstraints) {\n                (<any>this.linkAccessor).getMinSeparation = this._directedLinkConstraints.getMinSeparation;\n                curConstraints = curConstraints.concat(generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, <any>(this.linkAccessor)));\n\n                // todo: add containment constraints between group dummy nodes and their children\n            }\n\n            this.avoidOverlaps(false);\n            this._descent = new Descent([x, y], D, undefined, this._nodes);\n\n            this._descent.locks.clear();\n            for (var i = 0; i < n; ++i) {\n                var o = this._nodes[i];\n                if (o.fixed) {\n                    o.px = o.x;\n                    o.py = o.y;\n                    var p = [o.x, o.y];\n                    this._descent.locks.add(i, p);\n                }\n            }\n            this._descent.threshold = this._threshold;\n\n            // apply initialIterations without user constraints or nonoverlap constraints\n            // if groups are specified, dummy nodes and edges will be added to untangle\n            // with respect to group connectivity\n            this.initialLayout(initialUnconstrainedIterations, x, y);\n\n            // apply initialIterations with user constraints but no nonoverlap constraints\n            if (curConstraints.length > 0) this._descent.project = new Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();\n            this._descent.run(initialUserConstraintIterations);\n            this.separateOverlappingComponents(w, h, centerGraph);\n\n            // subsequent iterations will apply all constraints\n            this.avoidOverlaps(ao);\n            if (ao) {\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\n                this._descent.project = new Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();\n                this._nodes.forEach(function (v, i) { x[i] = v.x, y[i] = v.y; });\n            }\n\n            // allow not immediately connected nodes to relax apart (p-stress)\n            this._descent.G = G;\n            this._descent.run(initialAllConstraintsIterations);\n\n            if (gridSnapIterations) {\n                this._descent.snapStrength = 1000;\n                this._descent.snapGridSize = this._nodes[0].width;\n                this._descent.numGridSnapNodes = n;\n                this._descent.scaleSnapByMaxH = n != N; // if we have groups then need to scale hessian so grid forces still apply\n                var G0 = Descent.createSquareMatrix(N,(i, j) => {\n                    if (i >= n || j >= n) return G[i][j];\n                    return 0\n                });\n                this._descent.G = G0;\n                this._descent.run(gridSnapIterations);\n            }\n\n            this.updateNodePositions();\n            this.separateOverlappingComponents(w, h, centerGraph);\n            return keepRunning ? this.resume() : this;\n        }\n\n        private initialLayout(iterations: number, x: number[], y: number[]) {\n            if (this._groups.length > 0 && iterations > 0) {\n                // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children\n                // todo: edges attached to groups are replaced with edges connected to the corresponding group dummy node\n                var n = this._nodes.length;\n                var edges = this._links.map(e => <any>{ source: (<Node>e.source).index, target: (<Node>e.target).index });\n                var vs = this._nodes.map(v => <any>{ index: v.index });\n                this._groups.forEach((g, i) => {\n                    vs.push(<any>{ index: g.index = n + i });\n                });\n                this._groups.forEach((g, i) => {\n                    if (typeof g.leaves !== 'undefined')\n                        g.leaves.forEach(v => edges.push({ source: g.index, target: v.index }));\n                    if (typeof g.groups !== 'undefined')\n                        g.groups.forEach(gg => edges.push({ source: g.index, target: gg.index }));\n                });\n\n                // layout the flat graph with dummy nodes and edges\n                new Layout()\n                    .size(this.size())\n                    .nodes(vs)\n                    .links(edges)\n                    .avoidOverlaps(false)\n                    .linkDistance(this.linkDistance())\n                    .symmetricDiffLinkLengths(5)\n                    .convergenceThreshold(1e-4)\n                    .start(iterations, 0, 0, 0, false);\n\n                this._nodes.forEach(v => {\n                    x[v.index] = vs[v.index].x;\n                    y[v.index] = vs[v.index].y;\n                });\n            } else {\n                this._descent.run(iterations);\n            }\n        }\n\n        // recalculate nodes position for disconnected graphs\n        private separateOverlappingComponents(width: number, height: number, centerGraph: boolean = true): void {\n            // recalculate nodes position for disconnected graphs\n            if (!this._distanceMatrix && this._handleDisconnected) {\n                let x = this._descent.x[0], y = this._descent.x[1];\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\n                var graphs = separateGraphs(this._nodes, this._links);\n                applyPacking(graphs, width, height, this._defaultNodeSize, 1, centerGraph);\n                this._nodes.forEach((v, i) => {\n                    this._descent.x[0][i] = v.x, this._descent.x[1][i] = v.y;\n                    if (v.bounds) {\n                        v.bounds.setXCentre(v.x);\n                        v.bounds.setYCentre(v.y);\n                    }\n                });\n            }\n        }\n\n        resume(): this {\n            return this.alpha(0.1);\n        }\n\n        stop(): this {\n            return this.alpha(0);\n        }\n\n        /// find a visibility graph over the set of nodes.  assumes all nodes have a\n        /// bounds property (a rectangle) and that no pair of bounds overlaps.\n        prepareEdgeRouting(nodeMargin: number = 0) {\n            this._visibilityGraph = new TangentVisibilityGraph(\n                this._nodes.map(function (v) {\n                    return v.bounds.inflate(-nodeMargin).vertices();\n                }));\n        }\n\n        /**\n         * find a route avoiding node bounds for the given edge.\n         * assumes the visibility graph has been created (by prepareEdgeRouting method)\n         * and also assumes that nodes have an index property giving their position in the\n         * node array.  This index property is created by the start() method.\n         * @param [edge] The edge to generate a route for.\n         * @param {number} [ah] The size of the arrow head, a distance to shorten the end\n         *                      of the edge by.  Defaults to 5.\n         */\n        routeEdge(edge, ah: number = 5, draw) {\n            var lineData = [];\n            //if (d.source.id === 10 && d.target.id === 11) {\n            //    debugger;\n            //}\n            var vg2 = new TangentVisibilityGraph(this._visibilityGraph.P, { V: this._visibilityGraph.V, E: this._visibilityGraph.E }),\n                port1 = <TVGPoint>{ x: edge.source.x, y: edge.source.y },\n                port2 = <TVGPoint>{ x: edge.target.x, y: edge.target.y },\n                start = vg2.addPoint(port1, edge.source.index),\n                end = vg2.addPoint(port2, edge.target.index);\n            vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);\n            if (typeof draw !== 'undefined') {\n                draw(vg2);\n            }\n            var sourceInd = e => e.source.id, targetInd = e => e.target.id, length = e => e.length(),\n                spCalc = new Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length),\n                shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);\n            if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {\n                let route = makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, ah);\n                lineData = [route.sourceIntersection, route.arrowStart];\n            } else {\n                var n = shortestPath.length - 2,\n                    p = vg2.V[shortestPath[n]].p,\n                    q = vg2.V[shortestPath[0]].p,\n                    lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];\n                for (var i = n; i >= 0; --i)\n                    lineData.push(vg2.V[shortestPath[i]].p);\n                lineData.push(makeEdgeTo(q, edge.target.innerBounds, ah));\n            }\n            //lineData.forEach((v, i) => {\n            //    if (i > 0) {\n            //        var u = lineData[i - 1];\n            //        this._nodes.forEach(function (node) {\n            //            if (node.id === getSourceIndex(d) || node.id === getTargetIndex(d)) return;\n            //            var ints = node.innerBounds.lineIntersections(u.x, u.y, v.x, v.y);\n            //            if (ints.length > 0) {\n            //                debugger;\n            //            }\n            //        })\n            //    }\n            //})\n            return lineData;\n        }\n\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\n        static getSourceIndex(e: Link<Node | number>): number {\n            return typeof e.source === 'number' ? <number>e.source : (<Node>e.source).index;\n        }\n\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\n        static getTargetIndex(e: Link<Node | number>): number {\n            return typeof e.target === 'number' ? <number>e.target : (<Node>e.target).index;\n        }\n\n        // Get a string ID for a given link.\n        static linkId(e: Link<Node | number>): string {\n            return Layout.getSourceIndex(e) + \"-\" + Layout.getTargetIndex(e);\n        }\n\n        // The fixed property has three bits:\n        // Bit 1 can be set externally (e.g., d.fixed = true) and show persist.\n        // Bit 2 stores the dragging state, from mousedown to mouseup.\n        // Bit 3 stores the hover state, from mouseover to mouseout.\n        static dragStart(d: Node | Group) {\n            if (isGroup(d)) {\n                Layout.storeOffset(d, Layout.dragOrigin(d));\n            } else {\n                Layout.stopNode(d);\n                d.fixed |= 2; // set bit 2\n            }\n        }\n\n        // we clobber any existing desired positions for nodes\n        // in case another tick event occurs before the drag\n        private static stopNode(v: Node) {\n            (<any>v).px = v.x;\n            (<any>v).py = v.y;\n        }\n\n        // we store offsets for each node relative to the centre of the ancestor group\n        // being dragged in a pair of properties on the node\n        private static storeOffset(d: Group, origin: { x: number, y: number }) {\n            if (typeof d.leaves !== 'undefined') {\n                d.leaves.forEach(v => {\n                    v.fixed |= 2;\n                    Layout.stopNode(v);\n                    (<any>v)._dragGroupOffsetX = v.x - origin.x;\n                    (<any>v)._dragGroupOffsetY = v.y - origin.y;\n                });\n            }\n            if (typeof d.groups !== 'undefined') {\n                d.groups.forEach(g => Layout.storeOffset(g, origin));\n            }\n        }\n\n        // the drag origin is taken as the centre of the node or group\n        static dragOrigin(d: Node | Group): { x: number, y: number } {\n            if (isGroup(d)) {\n                return {\n                    x: d.bounds.cx(),\n                    y: d.bounds.cy()\n                };\n            } else {\n                return d;\n            }\n        }\n\n        // for groups, the drag translation is propagated down to all of the children of\n        // the group.\n        static drag(d: Node | Group, position: { x: number, y: number }) {\n            if (isGroup(d)) {\n                if (typeof d.leaves !== 'undefined') {\n                    d.leaves.forEach(v => {\n                        d.bounds.setXCentre(position.x);\n                        d.bounds.setYCentre(position.y);\n                        (<any>v).px = (<any>v)._dragGroupOffsetX + position.x;\n                        (<any>v).py = (<any>v)._dragGroupOffsetY + position.y;\n                    });\n                }\n                if (typeof d.groups !== 'undefined') {\n                    d.groups.forEach(g => Layout.drag(g, position));\n                }\n            } else {\n                (<any>d).px = position.x;\n                (<any>d).py = position.y;\n            }\n        }\n\n        // we unset only bits 2 and 3 so that the user can fix nodes with another a different\n        // bit such that the lock persists between drags\n        static dragEnd(d) {\n            if (isGroup(d)) {\n                if (typeof d.leaves !== 'undefined') {\n                    d.leaves.forEach(v => {\n                        Layout.dragEnd(v);\n                        delete (<any>v)._dragGroupOffsetX;\n                        delete (<any>v)._dragGroupOffsetY;\n                    });\n                }\n                if (typeof d.groups !== 'undefined') {\n                    d.groups.forEach(Layout.dragEnd);\n                }\n            } else {\n                d.fixed &= ~6; // unset bits 2 and 3\n                //d.fixed = 0;\n            }\n        }\n\n        // in d3 hover temporarily locks nodes, currently not used in cola\n        static mouseOver(d) {\n            d.fixed |= 4; // set bit 3\n            d.px = d.x, d.py = d.y; // set velocity to zero\n        }\n\n        // in d3 hover temporarily locks nodes, currently not used in cola\n        static mouseOut(d) {\n            d.fixed &= ~4; // unset bit 3\n        }\n    }\n","import {Layout, EventType, Event} from './layout'\n\n    export class LayoutAdaptor extends Layout {\n\n        // dummy functions in case not defined by client\n        trigger(e: Event) {};\n        kick() {};\n        drag() {};\n        on(eventType: EventType | string, listener: () => void) : this { return this; };\n\n        dragstart: (d:any) => void;\n        dragStart: (d:any) => void;\n        dragend: (d:any) => void;\n        dragEnd: (d:any) => void;\n\n        constructor( options ) {\n            super();\n\n            // take in implementation as defined by client\n\n            var self = this;\n            var o = options;\n\n            if ( o.trigger ) {\n                this.trigger = o.trigger;\n            }\n\n            if ( o.kick ){\n                this.kick = o.kick;\n            }\n\n            if ( o.drag ){\n                this.drag = o.drag;\n            }\n\n            if ( o.on ){\n                this.on = o.on;\n            }\n\n            this.dragstart = this.dragStart = Layout.dragStart;\n            this.dragend = this.dragEnd = Layout.dragEnd;\n        }\n    }\n\n    /**\n     * provides an interface for use with any external graph system (e.g. Cytoscape.js):\n     */\n    export function adaptor( options ): LayoutAdaptor {\n        return new LayoutAdaptor( options );\n    }\n","////<reference path=\"../extern/d3v3.d.ts\"/>\n////commented out the reference, because the path ended up in the typings, which\n////makes it impossible import in other projects.\n// declare const d3;\n\n\nimport {Layout, EventType, Event} from './layout';\nimport {ID3StyleLayoutAdaptor} from './d3adaptor'\n\n    /**\n     * @internal\n     */\n    export class D3StyleLayoutAdaptor extends Layout implements ID3StyleLayoutAdaptor {\n        protected readonly event: any;\n\n        trigger(e: Event) {\n            var d3event = { type: EventType[e.type], alpha: e.alpha, stress: e.stress };\n            this.event[d3event.type](d3event); // via d3 dispatcher, e.g. event.start(e);\n        }\n\n        // iterate layout using a d3.timer, which queues calls to tick repeatedly until tick returns true\n        kick() {\n            this.d3Context.timer(() => super.tick());\n        }\n\n        // a function to allow for dragging of nodes\n        drag: () => any;\n\n        private d3Context: any;\n\n        constructor(d3Context: any = self.d3) {\n            super();\n            this.d3Context = d3Context;\n            this.event = d3Context.dispatch(EventType[EventType.start], EventType[EventType.tick], EventType[EventType.end]);\n            // bit of trickyness remapping 'this' so we can reference it in the function body.\n            var d3layout = this;\n            var drag;\n            this.drag = function () {\n                if (!drag) {\n                    var drag = d3Context.behavior.drag()\n                        .origin(Layout.dragOrigin)\n                        .on(\"dragstart.d3adaptor\", Layout.dragStart)\n                        .on(\"drag.d3adaptor\", d => {\n                            Layout.drag(d, <any>d3layout.d3Context.event);\n                            d3layout.resume(); // restart annealing\n                        })\n                        .on(\"dragend.d3adaptor\", Layout.dragEnd);\n                }\n\n                if (!arguments.length) return drag;\n\n                // this is the context of the function, i.e. the d3 selection\n                this//.on(\"mouseover.adaptor\", colaMouseover)\n                //.on(\"mouseout.adaptor\", colaMouseout)\n                    .call(drag);\n            }\n        }\n\n        // a function for binding to events on the adapter\n        on(eventType: EventType | string, listener: () => void): this {\n            if (typeof eventType === 'string') {\n                this.event.on(eventType, listener);\n            } else {\n                this.event.on(EventType[eventType], listener);\n            }\n            return this;\n        }\n    }\n","import {dispatch} from 'd3-dispatch'\nimport {timer} from 'd3-timer'\nimport {drag as d3drag} from 'd3-drag'\nimport {Layout, EventType, Event} from './layout'\nimport {ID3StyleLayoutAdaptor} from './d3adaptor'\n\nexport interface D3Context {\n    timer: typeof timer; \n    drag: typeof d3drag; \n    dispatch: typeof dispatch;\n    event: any;\n}\n\n/**\n * @internal\n */\nexport class D3v4StyleLayoutAdaptor extends Layout implements ID3StyleLayoutAdaptor {\n    event:any;\n    trigger(e: Event) {\n        var d3event = { type: EventType[e.type], alpha: e.alpha, stress: e.stress };\n        // the dispatcher is actually expecting something of type EventTarget as the second argument\n        // so passing the thing above is totally abusing the pattern... not sure what to do about this yet\n        this.event.call(d3event.type, <any>d3event); // via d3 dispatcher, e.g. event.start(e);\n    }\n\n    // iterate layout using a d3.timer, which queues calls to tick repeatedly until tick returns true\n    kick() {\n        var t = this.d3Context.timer(() => super.tick() && t.stop());\n    }\n\n    // a function to allow for dragging of nodes\n    drag: () => any;\n\n    /**\n     * @internal\n     */\n    private readonly d3Context: D3Context;\n\n    constructor(d3Context: D3Context) {\n        super();\n        this.d3Context = d3Context;\n        this.event = d3Context.dispatch(EventType[EventType.start], EventType[EventType.tick], EventType[EventType.end]);\n\n        // bit of trickyness remapping 'this' so we can reference it in the function body.\n        var d3layout = this;\n        var drag;\n        this.drag = function () {\n            if (!drag) {\n                var drag = d3Context.drag()\n                    .subject(Layout.dragOrigin)\n                    .on(\"start.d3adaptor\", Layout.dragStart)\n                    .on(\"drag.d3adaptor\", d => {\n                        Layout.drag(<any>d, d3Context.event);\n                        d3layout.resume(); // restart annealing\n                    })\n                    .on(\"end.d3adaptor\", Layout.dragEnd);\n            }\n\n            if (!arguments.length) return drag;\n\n            // this is the context of the function, i.e. the d3 selection\n            //this//.on(\"mouseover.adaptor\", colaMouseover)\n            //.on(\"mouseout.adaptor\", colaMouseout)\n            arguments[0].call(drag);\n        }\n    }\n\n    // a function for binding to events on the adapter\n    on(eventType: EventType | string, listener: () => void): this {\n        if (typeof eventType === 'string') {\n            this.event.on(eventType, listener);\n        } else {\n            this.event.on(EventType[eventType], listener);\n        }\n        return this;\n    }\n}\n","import {Point} from './geom'\nimport {Rectangle} from './rectangle'\nimport {Constraint, Solver, Variable} from './vpsc'\nimport {Calculator} from './shortestpaths'\n    export interface NodeAccessor<Node>{\n        getChildren(v:Node) : number[];\n        getBounds(v:Node) : Rectangle;\n    }\n    export class NodeWrapper {\n        leaf: boolean;\n        parent: NodeWrapper;\n        ports: Vert[];\n        constructor(public id: number, public rect: Rectangle, public children: number[]) {\n            this.leaf = typeof children === 'undefined' || children.length === 0;\n        }\n    }\n    export class Vert {\n        constructor(public id: number, public x:number, public y: number, public node: NodeWrapper = null, public line = null) {}\n    }\n\n    export class LongestCommonSubsequence<T> {\n        length: number;\n        si: number;\n        ti: number;\n        reversed: boolean;\n        constructor(public s: T[], public t: T[]) {\n            var mf = LongestCommonSubsequence.findMatch(s, t);\n            var tr = t.slice(0).reverse();\n            var mr = LongestCommonSubsequence.findMatch(s, tr);\n            if (mf.length >= mr.length) {\n                this.length = mf.length;\n                this.si = mf.si;\n                this.ti = mf.ti;\n                this.reversed = false;\n            } else {\n                this.length = mr.length;\n                this.si = mr.si;\n                this.ti = t.length - mr.ti - mr.length;\n                this.reversed = true;\n            }\n        }\n        private static findMatch<T>(s: T[], t: T[]) {\n            var m = s.length;\n            var n = t.length;\n            var match = { length: 0, si: -1, ti: -1 };\n            var l = new Array(m);\n            for (var i = 0; i < m; i++) {\n                l[i] = new Array(n);\n                for (var j = 0; j < n; j++)\n                    if (s[i] === t[j]) {\n                        var v = l[i][j] = (i === 0 || j === 0) ? 1 : l[i - 1][j - 1] + 1;\n                        if (v > match.length) {\n                            match.length = v;\n                            match.si = i - v + 1;\n                            match.ti = j - v + 1;\n                        };\n                    } else l[i][j] = 0;\n            }\n            return match;\n        }\n        getSequence(): T[]{\n            return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];\n        }\n    }\n    // a horizontal or vertical line of nodes\n    export interface GridLine {\n        nodes: NodeWrapper[];\n        pos: number;\n    }\n    export class GridRouter<Node> {\n        leaves: NodeWrapper[] = null;\n        groups: NodeWrapper[];\n        nodes: NodeWrapper[];\n        cols: GridLine[];\n        rows: GridLine[];\n        root;\n        verts: Vert[];\n        edges;\n        backToFront;\n        obstacles;\n        passableEdges;\n        private avg(a) { return a.reduce((x, y) => x + y) / a.length }\n\n        // in the given axis, find sets of leaves overlapping in that axis\n        // center of each GridLine is average of all nodes in column\n        private getGridLines(axis): GridLine[] {\n            var columns = [];\n            var ls = this.leaves.slice(0, this.leaves.length);\n            while (ls.length > 0) {\n                // find a column of all leaves overlapping in axis with the first leaf\n                let overlapping = ls.filter(v=> v.rect['overlap' + axis.toUpperCase()](ls[0].rect));\n                let col = {\n                    nodes: overlapping,\n                    pos: this.avg(overlapping.map(v=> v.rect['c' + axis]()))\n                };\n                columns.push(col);\n                col.nodes.forEach(v=> ls.splice(ls.indexOf(v), 1));\n            }\n            columns.sort((a, b) => a.pos - b.pos)\n            return columns;\n        }\n\n        // get the depth of the given node in the group hierarchy\n        private getDepth(v) {\n            var depth = 0;\n            while (v.parent !== this.root) {\n                depth++;\n                v = v.parent;\n            }\n            return depth;\n        }\n\n        // medial axes between node centres and also boundary lines for the grid\n        private midPoints(a) {\n            if (a.length === 1) {\n                return [a[0]]\n            }\n\n            var gap = a[1] - a[0];\n            var mids = [a[0] - gap / 2];\n            for (var i = 1; i < a.length; i++) {\n                mids.push((a[i] + a[i - 1]) / 2);\n            }\n            mids.push(a[a.length - 1] + gap / 2);\n            return mids;\n        }\n\n        constructor(public originalnodes: Node[], accessor: NodeAccessor<Node>, public groupPadding: number = 12) {\n            this.nodes = originalnodes.map((v, i) => new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v)));\n            this.leaves = this.nodes.filter(v=> v.leaf);\n            this.groups = this.nodes.filter(g=> !g.leaf);\n            this.cols = this.getGridLines('x');\n            this.rows = this.getGridLines('y');\n\n            // create parents for each node or group that is a member of another's children\n            this.groups.forEach(v=>\n                v.children.forEach(c=> this.nodes[<number>c].parent = v));\n\n            // root claims the remaining orphans\n            this.root = { children: [] };\n            this.nodes.forEach(v=> {\n                if (typeof v.parent === 'undefined') {\n                    v.parent = this.root;\n                    this.root.children.push(v.id);\n                }\n\n                // each node will have grid vertices associated with it,\n                // some inside the node and some on the boundary\n                // leaf nodes will have exactly one internal node at the center\n                // and four boundary nodes\n                // groups will have potentially many of each\n                v.ports = []\n            });\n\n            // nodes ordered by their position in the group hierarchy\n            this.backToFront = this.nodes.slice(0);\n            this.backToFront.sort((x, y) => this.getDepth(x) - this.getDepth(y));\n\n            // compute boundary rectangles for each group\n            // has to be done from front to back, i.e. inside groups to outside groups\n            // such that each can be made large enough to enclose its interior\n            var frontToBackGroups = this.backToFront.slice(0).reverse().filter(g=> !g.leaf);\n            frontToBackGroups.forEach(v=> {\n                var r = Rectangle.empty();\n                v.children.forEach(c=> r = r.union(this.nodes[c].rect));\n                v.rect = r.inflate(this.groupPadding);\n            });\n\n            var colMids = this.midPoints(this.cols.map(r=> r.pos));\n            var rowMids = this.midPoints(this.rows.map(r=> r.pos));\n\n            // setup extents of lines\n            var rowx = colMids[0], rowX = colMids[colMids.length - 1];\n            var coly = rowMids[0], colY = rowMids[rowMids.length - 1];\n\n            // horizontal lines\n            var hlines = this.rows.map(r=> <any>{ x1: rowx, x2: rowX, y1: r.pos, y2: r.pos })\n                .concat(rowMids.map(m=> <any>{ x1: rowx, x2: rowX, y1: m, y2: m }));\n\n            // vertical lines\n            var vlines = this.cols.map(c=> <any>{ x1: c.pos, x2: c.pos, y1: coly, y2: colY })\n                .concat(colMids.map(m=> <any>{ x1: m, x2: m, y1: coly, y2: colY }));\n\n            // the full set of lines\n            var lines = hlines.concat(vlines);\n\n            // we record the vertices associated with each line\n            lines.forEach(l=> l.verts = []);\n\n            // the routing graph\n            this.verts = [];\n            this.edges = [];\n\n            // create vertices at the crossings of horizontal and vertical grid-lines\n            hlines.forEach(h=>\n                vlines.forEach(v=> {\n                    var p = new Vert(this.verts.length, v.x1, h.y1);\n                    h.verts.push(p);\n                    v.verts.push(p);\n                    this.verts.push(p);\n\n                    // assign vertices to the nodes immediately under them\n                    var i = this.backToFront.length;\n                    while (i-- > 0) {\n                        var node = this.backToFront[i],\n                            r = node.rect;\n                        var dx = Math.abs(p.x - r.cx()),\n                            dy = Math.abs(p.y - r.cy());\n                        if (dx < r.width() / 2 && dy < r.height() / 2) {\n                            (<any>p).node = node;\n                            break;\n                        }\n                    }\n                })\n                );\n\n            lines.forEach((l, li) => {\n                // create vertices at the intersections of nodes and lines\n                this.nodes.forEach((v, i) => {\n                    v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach((intersect, j) => {\n                        //console.log(li+','+i+','+j+':'+intersect.x + ',' + intersect.y);\n                        var p = new Vert(this.verts.length, intersect.x, intersect.y, v, l);\n                        this.verts.push(p);\n                        l.verts.push(p);\n                        v.ports.push(p);\n                    });\n                });\n\n                // split lines into edges joining vertices\n                var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;\n                var delta = (a, b) => isHoriz ? b.x - a.x : b.y - a.y;\n                l.verts.sort(delta);\n                for (var i = 1; i < l.verts.length; i++) {\n                    var u = l.verts[i - 1], v = l.verts[i];\n                    if (u.node && u.node === v.node && u.node.leaf) continue;\n                    this.edges.push({ source: u.id, target: v.id, length: Math.abs(delta(u, v)) });\n                }\n            });\n\n\n\n        }\n\n        // find path from v to root including both v and root\n        private findLineage(v) {\n            var lineage = [v];\n            do {\n                v = v.parent;\n                lineage.push(v);\n            } while (v !== this.root);\n            return lineage.reverse();\n        }\n\n        // find path connecting a and b through their lowest common ancestor\n        private findAncestorPathBetween(a, b) {\n            var aa = this.findLineage(a), ba = this.findLineage(b), i = 0;\n            while (aa[i] === ba[i]) i++;\n            // i-1 to include common ancestor only once (as first element)\n            return { commonAncestor: aa[i - 1], lineages: aa.slice(i).concat(ba.slice(i)) };\n        }\n\n        // when finding a path between two nodes a and b, siblings of a and b on the\n        // paths from a and b to their least common ancestor are obstacles\n        siblingObstacles(a, b) {\n            var path = this.findAncestorPathBetween(a, b);\n            var lineageLookup = {};\n            path.lineages.forEach(v=> lineageLookup[v.id] = {});\n            var obstacles = path.commonAncestor.children.filter(v=> !(v in lineageLookup));\n\n            path.lineages\n                .filter(v=> v.parent !== path.commonAncestor)\n                .forEach(v=> obstacles = obstacles.concat(v.parent.children.filter(c=> c !== v.id)));\n\n            return obstacles.map(v=> this.nodes[v]);\n        }\n\n        // for the given routes, extract all the segments orthogonal to the axis x\n        // and return all them grouped by x position\n        static getSegmentSets(routes, x, y) {\n            // vsegments is a list of vertical segments sorted by x position\n            var vsegments = [];\n            for (var ei = 0; ei < routes.length; ei++) {\n                var route = routes[ei];\n                for (var si = 0; si < route.length; si++) {\n                    var s = <any>route[si];\n                    s.edgeid = ei;\n                    s.i = si;\n                    var sdx = s[1][x] - s[0][x];\n                    if (Math.abs(sdx) < 0.1) {\n                        vsegments.push(s);\n                    }\n                }\n            }\n            vsegments.sort((a, b) => a[0][x] - b[0][x]);\n\n            // vsegmentsets is a set of sets of segments grouped by x position\n            var vsegmentsets = [];\n            var segmentset = null;\n            for (var i = 0; i < vsegments.length; i++) {\n                var s = vsegments[i];\n                if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {\n                    segmentset = { pos: s[0][x], segments: [] };\n                    vsegmentsets.push(segmentset);\n                }\n                segmentset.segments.push(s);\n            }\n            return vsegmentsets;\n        }\n\n        // for all segments in this bundle create a vpsc problem such that\n        // each segment's x position is a variable and separation constraints\n        // are given by the partial order over the edges to which the segments belong\n        // for each pair s1,s2 of segments in the open set:\n        //   e1 = edge of s1, e2 = edge of s2\n        //   if leftOf(e1,e2) create constraint s1.x + gap <= s2.x\n        //   else if leftOf(e2,e1) create cons. s2.x + gap <= s1.x\n        static nudgeSegs(x: string, y: string, routes, segments, leftOf, gap: number) {\n            var n = segments.length;\n            if (n <= 1) return;\n            var vs = segments.map(s => new Variable(s[0][x]));\n            var cs = [];\n            for (var i = 0; i < n; i++) {\n                for (var j = 0; j < n; j++) {\n                    if (i === j) continue;\n                    var s1 = segments[i],\n                        s2 = segments[j],\n                        e1 = s1.edgeid,\n                        e2 = s2.edgeid,\n                        lind = -1,\n                        rind = -1;\n                    // in page coordinates (not cartesian) the notion of 'leftof' is flipped in the horizontal axis from the vertical axis\n                    // that is, when nudging vertical segments, if they increase in the y(conj) direction the segment belonging to the\n                    // 'left' edge actually needs to be nudged to the right\n                    // when nudging horizontal segments, if the segments increase in the x direction\n                    // then the 'left' segment needs to go higher, i.e. to have y pos less than that of the right\n                    if (x == 'x') {\n                        if (leftOf(e1, e2)) {\n                            //console.log('s1: ' + s1[0][x] + ',' + s1[0][y] + '-' + s1[1][x] + ',' + s1[1][y]);\n                            if (s1[0][y] < s1[1][y]) {\n                                lind = j, rind = i;\n                            } else {\n                                lind = i, rind = j;\n                            }\n                        }\n                    } else {\n                        if (leftOf(e1, e2)) {\n                            if (s1[0][y] < s1[1][y]) {\n                                lind = i, rind = j;\n                            } else {\n                                lind = j, rind = i;\n                            }\n                        }\n                    }\n                    if (lind >= 0) {\n                        //console.log(x+' constraint: ' + lind + '<' + rind);\n                        cs.push(new Constraint(vs[lind], vs[rind], gap));\n                    }\n                }\n            }\n            var solver = new Solver(vs, cs);\n            solver.solve();\n            vs.forEach((v, i) => {\n                var s = segments[i];\n                var pos = v.position();\n                s[0][x] = s[1][x] = pos;\n                var route = routes[s.edgeid];\n                if (s.i > 0) route[s.i - 1][1][x] = pos;\n                if (s.i < route.length - 1) route[s.i + 1][0][x] = pos;\n            });\n        }\n\n        static nudgeSegments(routes, x: string, y: string, leftOf: (e1: number, e2: number) => boolean, gap: number) {\n            var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);\n            // scan the grouped (by x) segment sets to find co-linear bundles\n            for (var i = 0; i < vsegmentsets.length; i++) {\n                var ss = vsegmentsets[i];\n                var events = [];\n                for (var j = 0; j < ss.segments.length; j++) {\n                    var s = ss.segments[j];\n                    events.push({ type: 0, s: s, pos: Math.min(s[0][y], s[1][y]) });\n                    events.push({ type: 1, s: s, pos: Math.max(s[0][y], s[1][y]) });\n                }\n                events.sort((a, b) => a.pos - b.pos + a.type - b.type);\n                var open = [];\n                var openCount = 0;\n                events.forEach(e=> {\n                    if (e.type === 0) {\n                        open.push(e.s);\n                        openCount++;\n                    } else {\n                        openCount--;\n                    }\n                    if (openCount == 0) {\n                        GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);\n                        open = [];\n                    }\n                });\n            }\n        }\n\n        // obtain routes for the specified edges, nicely nudged apart\n        // warning: edge paths may be reversed such that common paths are ordered consistently within bundles!\n        // @param edges list of edges\n        // @param nudgeGap how much to space parallel edge segements\n        // @param source function to retrieve the index of the source node for a given edge\n        // @param target function to retrieve the index of the target node for a given edge\n        // @returns an array giving, for each edge, an array of segments, each segment a pair of points in an array\n        routeEdges<Edge>(edges: Edge[], nudgeGap: number, source: (e: Edge) => number, target: (e: Edge) => number): Point[][][] {\n            var routePaths = edges.map(e=> this.route(source(e), target(e)));\n            var order = GridRouter.orderEdges(routePaths);\n            var routes = routePaths.map(function (e) { return GridRouter.makeSegments(e); });\n            GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);\n            GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);\n            GridRouter.unreverseEdges(routes, routePaths);\n            return routes;\n        }\n\n        // path may have been reversed by the subsequence processing in orderEdges\n        // so now we need to restore the original order\n        static unreverseEdges(routes, routePaths) {\n            routes.forEach((segments, i) => {\n                var path = routePaths[i];\n                if ((<any>path).reversed) {\n                    segments.reverse(); // reverse order of segments\n                    segments.forEach(function (segment) {\n                        segment.reverse();  // reverse each segment\n                    });\n                }\n            });\n        }\n\n        static angleBetween2Lines(line1: Point[], line2: Point[]): number {\n            var angle1 = Math.atan2(line1[0].y - line1[1].y,\n                line1[0].x - line1[1].x);\n            var angle2 = Math.atan2(line2[0].y - line2[1].y,\n                line2[0].x - line2[1].x);\n            var diff = angle1 - angle2;\n            if (diff > Math.PI || diff < -Math.PI) {\n                diff = angle2 - angle1;\n            }\n            return diff;\n        }\n\n        // does the path a-b-c describe a left turn?\n        private static isLeft(a, b, c) {\n            return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) <= 0;\n        }\n\n        // for the given list of ordered pairs, returns a function that (efficiently) looks-up a specific pair to\n        // see if it exists in the list\n        private static getOrder(pairs: { l: number; r: number }[]): (l: number, r: number) => boolean {\n            var outgoing = {};\n            for (var i = 0; i < pairs.length; i++) {\n                var p = pairs[i];\n                if (typeof outgoing[p.l] === 'undefined') outgoing[p.l] = {};\n                outgoing[p.l][p.r] = true;\n            }\n            return (l, r) => typeof outgoing[l] !== 'undefined' && outgoing[l][r];\n        }\n\n        // returns an ordering (a lookup function) that determines the correct order to nudge the\n        // edge paths apart to minimize crossings\n        static orderEdges(edges) {\n            var edgeOrder = [];\n            for (var i = 0; i < edges.length - 1; i++) {\n                for (var j = i + 1; j < edges.length; j++) {\n                    var e = edges[i],\n                        f = edges[j],\n                        lcs = new LongestCommonSubsequence(e, f);\n                    var u, vi, vj;\n                    if (lcs.length === 0)\n                        continue; // no common subpath\n                    if (lcs.reversed) {\n                        // if we found a common subpath but one of the edges runs the wrong way,\n                        // then reverse f.\n                        f.reverse();\n                        f.reversed = true;\n                        lcs = new LongestCommonSubsequence(e, f);\n                    }\n                    if ((lcs.si <= 0 || lcs.ti <= 0) &&\n                        (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {\n                        // the paths do not diverge, so make an arbitrary ordering decision\n                        edgeOrder.push({ l: i, r: j });\n                        continue;\n                    }\n                    if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {\n                        // if the common subsequence of the\n                        // two edges being considered goes all the way to the\n                        // end of one (or both) of the lines then we have to\n                        // base our ordering decision on the other end of the\n                        // common subsequence\n                        u = e[lcs.si + 1];\n                        vj = e[lcs.si - 1];\n                        vi = f[lcs.ti - 1];\n                    } else {\n                        u = e[lcs.si + lcs.length - 2];\n                        vi = e[lcs.si + lcs.length];\n                        vj = f[lcs.ti + lcs.length];\n                    }\n                    if (GridRouter.isLeft(u, vi, vj)) {\n                        edgeOrder.push({ l: j, r: i });\n                    } else {\n                        edgeOrder.push({ l: i, r: j });\n                    }\n                }\n            }\n            //edgeOrder.forEach(function (e) { console.log('l:' + e.l + ',r:' + e.r) });\n            return GridRouter.getOrder(edgeOrder);\n        }\n\n        // for an orthogonal path described by a sequence of points, create a list of segments\n        // if consecutive segments would make a straight line they are merged into a single segment\n        // segments are over cloned points, not the original vertices\n        static makeSegments(path: Point[]): Point[][] {\n            function copyPoint(p: Point) {\n                return <Point>{ x: p.x, y: p.y };\n            }\n            var isStraight = (a, b, c) => Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001;\n            var segments = [];\n            var a = copyPoint(path[0]);\n            for (var i = 1; i < path.length; i++) {\n                var b = copyPoint(path[i]), c = i < path.length - 1 ? path[i + 1] : null;\n                if (!c || !isStraight(a, b, c)) {\n                    segments.push([a, b]);\n                    a = b;\n                }\n            }\n            return segments;\n        }\n\n        // find a route between node s and node t\n        // returns an array of indices to verts\n        route(s: number, t: number): Point[] {\n            var source = this.nodes[<number>s], target = this.nodes[<number>t];\n            this.obstacles = this.siblingObstacles(source, target);\n\n            var obstacleLookup = {};\n            this.obstacles.forEach(o => obstacleLookup[o.id] = o);\n            this.passableEdges = this.edges.filter(e=> {\n                var u = this.verts[e.source],\n                    v = this.verts[e.target];\n                return !(u.node && u.node.id in obstacleLookup\n                    || v.node && v.node.id in obstacleLookup);\n            });\n\n            // add dummy segments linking ports inside source and target\n            for (var i = 1; i < source.ports.length; i++) {\n                var u = source.ports[0].id;\n                var v = source.ports[i].id;\n                this.passableEdges.push({\n                    source: u,\n                    target: v,\n                    length: 0\n                });\n            }\n            for (var i = 1; i < target.ports.length; i++) {\n                var u = target.ports[0].id;\n                var v = target.ports[i].id;\n                this.passableEdges.push({\n                    source: u,\n                    target: v,\n                    length: 0\n                });\n            }\n\n            var getSource = e=> e.source,\n                getTarget = e=> e.target,\n                getLength = e=> e.length;\n\n            var shortestPathCalculator = new Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);\n            var bendPenalty = (u, v, w) => {\n                var a = this.verts[u], b = this.verts[v], c = this.verts[w];\n                var dx = Math.abs(c.x - a.x), dy = Math.abs(c.y - a.y);\n                // don't count bends from internal node edges\n                if (a.node === source && a.node === b.node || b.node === target && b.node === c.node)\n                    return 0;\n                return dx > 1 && dy > 1 ? 1000 : 0;\n            };\n\n            // get shortest path\n            var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(\n                source.ports[0].id, target.ports[0].id,\n                bendPenalty);\n\n            // shortest path is reversed and does not include the target port\n            var pathPoints = shortestPath.reverse().map(vi => this.verts[vi]);\n            pathPoints.push(this.nodes[target.id].ports[0]);\n\n            // filter out any extra end points that are inside the source or target (i.e. the dummy segments above)\n            return pathPoints.filter((v, i) =>\n                !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source\n                    || i > 0 && v.node === target && pathPoints[i - 1].node === target));\n        }\n\n        static getRoutePath(route: Point[][], cornerradius: number, arrowwidth: number, arrowheight: number): { routepath: string; arrowpath: string } {\n            var result = {\n                routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',\n                arrowpath: ''\n            };\n            if (route.length > 1) {\n                for (var i = 0; i < route.length; i++) {\n                    var li = route[i];\n                    var x = li[1].x, y = li[1].y;\n                    var dx = x - li[0].x;\n                    var dy = y - li[0].y;\n                    if (i < route.length - 1) {\n                        if (Math.abs(dx) > 0) {\n                            x -= dx / Math.abs(dx) * cornerradius;\n                        } else {\n                            y -= dy / Math.abs(dy) * cornerradius;\n                        }\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\n                        var l = route[i + 1];\n                        var x0 = l[0].x, y0 = l[0].y;\n                        var x1 = l[1].x;\n                        var y1 = l[1].y;\n                        dx = x1 - x0;\n                        dy = y1 - y0;\n                        var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;\n                        //console.log(cola.GridRouter.angleBetween2Lines(li, l))\n                        var x2, y2;\n                        if (Math.abs(dx) > 0) {\n                            x2 = x0 + dx / Math.abs(dx) * cornerradius;\n                            y2 = y0;\n                        } else {\n                            x2 = x0;\n                            y2 = y0 + dy / Math.abs(dy) * cornerradius;\n                        }\n                        var cx = Math.abs(x2 - x);\n                        var cy = Math.abs(y2 - y);\n                        result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';\n                    } else {\n                        var arrowtip = [x, y];\n                        var arrowcorner1, arrowcorner2;\n                        if (Math.abs(dx) > 0) {\n                            x -= dx / Math.abs(dx) * arrowheight;\n                            arrowcorner1 = [x, y + arrowwidth];\n                            arrowcorner2 = [x, y - arrowwidth];\n                        } else {\n                            y -= dy / Math.abs(dy) * arrowheight;\n                            arrowcorner1 = [x + arrowwidth, y];\n                            arrowcorner2 = [x - arrowwidth, y];\n                        }\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\n                        if (arrowheight > 0) {\n                            result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\n                            + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\n                        }\n                    }\n                }\n            } else {\n                var li = route[0];\n                var x = li[1].x, y = li[1].y;\n                var dx = x - li[0].x;\n                var dy = y - li[0].y;\n                var arrowtip = [x, y];\n                var arrowcorner1, arrowcorner2;\n                if (Math.abs(dx) > 0) {\n                    x -= dx / Math.abs(dx) * arrowheight;\n                    arrowcorner1 = [x, y + arrowwidth];\n                    arrowcorner2 = [x, y - arrowwidth];\n                } else {\n                    y -= dy / Math.abs(dy) * arrowheight;\n                    arrowcorner1 = [x + arrowwidth, y];\n                    arrowcorner2 = [x - arrowwidth, y];\n                }\n                result.routepath += 'L ' + x + ' ' + y + ' ';\n                if (arrowheight > 0) {\n                    result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\n                    + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\n                }\n            }\n            return result;\n        }\n    }\n","import {Calculator} from './shortestpaths'\nimport {Descent} from './descent'\nimport {Projection, GraphNode, Rectangle} from './rectangle'\nimport {Variable} from './vpsc'\nimport {jaccardLinkLengths, LinkLengthAccessor} from './linklengths'\n\nexport class Link3D {\n        length: number;\n        constructor(public source: number, public target: number) { }\n        actualLength(x: number[][]) {\n            return Math.sqrt(\n                x.reduce((c: number, v: number[]) => {\n                    const dx = v[this.target] - v[this.source];\n                    return c + dx * dx;\n                }, 0));\n        }\n    }\n    export class Node3D implements GraphNode {\n        // if fixed, layout will not move the node from its specified starting position\n        fixed: boolean;\n        width: number;\n        height: number;\n        px: number;\n        py: number;\n        bounds: Rectangle;\n        variable: Variable;\n        constructor(\n            public x: number = 0,\n            public y: number = 0,\n            public z: number = 0) { }\n    }\n    export class Layout3D {\n        static dims = ['x', 'y', 'z'];\n        static k = Layout3D.dims.length;\n        result: number[][];\n        constraints: any[] = null;\n\n        constructor(public nodes: Node3D[], public links: Link3D[], public idealLinkLength: number = 1) {\n            this.result = new Array(Layout3D.k);\n            for (var i = 0; i < Layout3D.k; ++i) {\n                this.result[i] = new Array(nodes.length);\n            }\n            nodes.forEach((v, i) => {\n                for (var dim of Layout3D.dims) {\n                    if (typeof v[dim] == 'undefined') v[dim] = Math.random();\n                }\n                this.result[0][i] = v.x;\n                this.result[1][i] = v.y;\n                this.result[2][i] = v.z;\n            });\n        };\n\n        linkLength(l: Link3D): number {\n            return l.actualLength(this.result);\n        }\n\n        useJaccardLinkLengths: boolean = true;\n\n        descent: Descent;\n        start(iterations: number = 100): Layout3D {\n            const n = this.nodes.length;\n\n            var linkAccessor = new LinkAccessor();\n\n            if (this.useJaccardLinkLengths)\n                jaccardLinkLengths(this.links, linkAccessor, 1.5);\n\n            this.links.forEach(e => e.length *= this.idealLinkLength);\n\n            // Create the distance matrix that Cola needs\n            const distanceMatrix = (new Calculator(n, this.links,\n                e=> e.source, e=> e.target, e => e.length)).DistanceMatrix();\n\n            const D = Descent.createSquareMatrix(n, (i, j) => distanceMatrix[i][j]);\n\n            // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\n            // otherwise 2.\n            var G = Descent.createSquareMatrix(n, function () { return 2 });\n            this.links.forEach(({ source, target }) => G[source][target] = G[target][source] = 1);\n\n            this.descent = new Descent(this.result, D);\n            this.descent.threshold = 1e-3;\n            this.descent.G = G;\n            //let constraints = this.links.map(e=> <any>{\n            //    axis: 'y', left: e.source, right: e.target, gap: e.length*1.5\n            //});\n            if (this.constraints)\n                this.descent.project = new Projection(<GraphNode[]>this.nodes, null, null, this.constraints).projectFunctions();\n\n            for (var i = 0; i < this.nodes.length; i++) {\n                var v = this.nodes[i];\n                if (v.fixed) {\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);\n                }\n            }\n\n            this.descent.run(iterations);\n            return this;\n        }\n\n        tick(): number {\n            this.descent.locks.clear();\n            for (var i = 0; i < this.nodes.length; i++) {\n                var v = this.nodes[i];\n                if (v.fixed) {\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);\n                }\n            }\n            return this.descent.rungeKutta();\n        }\n    }\n\n    class LinkAccessor implements LinkLengthAccessor<any> {\n        getSourceIndex(e: any): number { return e.source; }\n        getTargetIndex(e: any): number { return e.target; }\n        getLength(e: any): number { return e.length; }\n        setLength(e: any, l: number) { e.length = l; }\n    }\n","import {D3StyleLayoutAdaptor} from './d3v3adaptor'\nimport {D3Context, D3v4StyleLayoutAdaptor} from './d3v4adaptor'\nimport { Layout, EventType, Event } from './layout';\n\nexport { D3Context } from './d3v4adaptor';\n\nexport interface D3v3Context { version: string };\n\nexport interface ID3StyleLayoutAdaptor {\n    trigger(e: Event): void;\n    kick(): void;\n    drag: () => any;\n\n    on(eventType: EventType | string, listener: () => void): ID3StyleLayoutAdaptor;\n}\n\n\n/**\n * provides an interface for use with d3:\n * Correct way to create way to construct the d3 cola object is to pass the d3 object into the adaptor function, like so:\n * \n *   `var d3cola = cola.d3adaptor(d3);`\n * \n * Internally, it will figure out if d3 is version 3 or 4 from the version tag and set up the right event forwarding. Defaults to version 3 if the d3 object is not passed.\n * - uses the d3 event system to dispatch layout events such as:\n *   o \"start\" (start layout process)\n *   o \"tick\" (after each layout iteration)\n *   o \"end\" (layout converged and complete).\n * - uses the d3 timer to queue layout iterations.\n * - sets up d3.behavior.drag to drag nodes\n *   o use `node.call(<the returned instance of Layout>.drag)` to make nodes draggable\n * returns an instance of the cola.Layout itself with which the user\n * can interact directly.\n */\nexport function d3adaptor(d3Context?: D3Context | D3v3Context): Layout & ID3StyleLayoutAdaptor {\n    if (!d3Context || isD3V3(d3Context)) {\n        return new D3StyleLayoutAdaptor(d3Context);\n    }\n    return new D3v4StyleLayoutAdaptor(d3Context);\n}\n\nfunction isD3V3(d3Context: D3Context | D3v3Context): d3Context is D3v3Context {\n    const v3exp = /^3\\./;\n    return (<any>d3Context).version && (<any>d3Context).version.match(v3exp) !== null;\n}\n","import {Node, Link, Layout} from './layout'\nimport {GridRouter} from './gridrouter'\nimport {Point} from './geom'\n\n/**\n * @property nudgeGap spacing between parallel edge segments\n * @property margin space around nodes\n * @property groupMargin space around groups\n */\nexport function gridify(pgLayout, nudgeGap: number, margin: number, groupMargin: number) {\n    pgLayout.cola.start(0, 0, 0, 10, false);\n    let gridrouter = route(pgLayout.cola.nodes(), pgLayout.cola.groups(), margin, groupMargin);\n    return gridrouter.routeEdges<any>(pgLayout.powerGraph.powerEdges, nudgeGap, e=> e.source.routerNode.id, e=> e.target.routerNode.id);\n}\n\nfunction route(nodes, groups, margin: number, groupMargin: number) {\n    nodes.forEach(d => {\n        d.routerNode = <any>{\n            name: d.name,\n            bounds: d.bounds.inflate(-margin)\n        };\n    });\n    groups.forEach(d => {\n        d.routerNode = <any>{\n            bounds: d.bounds.inflate(-groupMargin),\n            children: (typeof d.groups !== 'undefined' ? d.groups.map(c=> nodes.length + c.id) : [])\n                .concat(typeof d.leaves !== 'undefined' ? d.leaves.map(c=> c.index) : [])\n        };\n    });\n    let gridRouterNodes = nodes.concat(groups).map((d, i) => {\n        d.routerNode.id = i;\n        return d.routerNode;\n    });\n    return new GridRouter(gridRouterNodes, {\n        getChildren: (v: any) => v.children,\n        getBounds: v => v.bounds\n    }, margin - groupMargin);\n}\n\nexport function powerGraphGridLayout(\n    graph: { nodes: Node[], links: Link<Node>[] },\n    size: number[],\n    grouppadding: number)\n{\n    // compute power graph\n    var powerGraph;\n    graph.nodes.forEach((v,i) => (<any>v).index = i);\n    new Layout()\n        .avoidOverlaps(false)\n        .nodes(graph.nodes)\n        .links(graph.links)\n        .powerGraphGroups(function (d) {\n            powerGraph = d;\n            powerGraph.groups.forEach(v=> v.padding = grouppadding);\n        });\n\n    // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children\n    // power edges attached to groups are replaced with edges connected to the corresponding group dummy node\n    var n = graph.nodes.length;\n    var edges = [];\n    var vs = graph.nodes.slice(0);\n    vs.forEach((v, i) => (<any>v).index = i);\n    powerGraph.groups.forEach(g => {\n        var sourceInd = g.index = g.id + n;\n        vs.push(g);\n        if (typeof g.leaves !== 'undefined')\n            g.leaves.forEach(v => edges.push({ source: sourceInd, target: v.index }));\n        if (typeof g.groups !== 'undefined')\n            g.groups.forEach(gg => edges.push({ source: sourceInd, target: gg.id + n }));\n    });\n    powerGraph.powerEdges.forEach(e=> {\n        edges.push({ source: e.source.index, target: e.target.index });\n    });\n\n    // layout the flat graph with dummy nodes and edges\n    new Layout()\n        .size(size)\n        .nodes(vs)\n        .links(edges)\n        .avoidOverlaps(false)\n        .linkDistance(30)\n        .symmetricDiffLinkLengths(5)\n        .convergenceThreshold(1e-4)\n        .start(100, 0, 0, 0, false);\n\n    // final layout taking node positions from above as starting positions\n    // subject to group containment constraints\n    // and then gridifying the layout\n    return {\n        cola:\n            new Layout()\n            .convergenceThreshold(1e-3)\n            .size(size)\n            .avoidOverlaps(true)\n            .nodes(graph.nodes)\n            .links(graph.links)\n        //.flowLayout('y', 30)\n            .groupCompactness(1e-4)\n            .linkDistance(30)\n            .symmetricDiffLinkLengths(5)\n            .powerGraphGroups(function (d) {\n                powerGraph = d;\n                powerGraph.groups.forEach(function (v) {\n                    v.padding = grouppadding\n                });\n            }).start(50, 0, 100, 0, false),\n        powerGraph: powerGraph\n    };\n}\n"],"names":["PowerEdge","source","target","type","Configuration","n","edges","linkAccessor","rootGroup","modules","Array","roots","initModulesFromGroup","push","ModuleSet","i","add","this","Module","R","length","forEach","e","s","_this","getSourceIndex","t","getTargetIndex","getType","outgoing","incoming","group","moduleSet","leaves","node","module","id","groups","j","child","definition","prop","hasOwnProperty","LinkSets","merge","a","b","k","inInt","intersection","outInt","children","m","update","o","forAll","ms","linktype","nls","remove","count","rootMerges","rs","merges","ctr","i_","nEdges","greedyMerge","sort","getGroupHierarchy","retargetedEdges","toGroups","isLeaf","g","gid","isIsland","isPredefined","allEdges","_this2","es","getEdges","edgetype","_this3","Object","keys","table","other","result","v","intersectionCount","contains","f","mid","vs","forAllModules","sets","Number","lt","getGroups","nodes","links","la","c","powerEdges","end","unionCount","u","computeLinkLengths","w","neighbours","addNeighbours","getNeighbours","l","setLength","symmetricDiffLinkLengths","Math","sqrt","jaccardLinkLengths","min","generateDirectedEdgeConstraints","axis","components","stronglyConnectedComponents","constraints","ui","vi","left","right","gap","getMinSeparation","numVertices","index","stack","strongConnect","lowlink","onStack","out","component","pop","map","Locks","x","locks","clear","isEmpty","apply","Descent","D","G","PseudoRandom","_nodes","H","Hd","d","ia","ib","xtmp","minD","MAX_VALUE","dimensionDistance","dx","dedge","width","height","createSquareMatrix","M","offsetDir","random","getNextBetween","computeDerivatives","d2","Huu","maxH","maxDisplaces","distanceSquared","rd","distance","idealDistance","weight","isFinite","idealDistSquared","gs","distanceCubed","hs","console","log","max","r","snapGridSize","snapStrength","numNodes","numGridSnapNodes","xiu","q","abs","scaleSnapByMaxH","p","dotProd","rightMultiply","computeStepSize","numerator","denominator","reduceStress","alpha","takeDescentStep","computeStress","copy","stepAndProject","x0","stepSize","project","mApply","matrixApply","computeNextPosition","beta","run","iterations","stress","converged","rungeKutta","threshold","disp","_this4","nMinus1","rl","seed","getNext","range","PositionStats","scale","addVariable","ai","wi","AB","offset","AD","desiredPosition","A2","getPosn","Constraint","equality","slack","unsatisfiable","position","Variable","dfdv","block","ps","posn","visitNeighbours","prev","ff","next","active","cOut","cIn","Block","vars","updateWeightedPosition","compute_lm","postAction","_dfdv","lm","populateSplitBlock","traverse","visit","acc","findMinLM","findMinLMBetween","lv","rv","findPath","to","endFound","isActiveDirectedPathBetween","split","createSplitBlock","startVar","splitBetween","vl","vr","bs","constraint","lb","rb","mergeAcross","dist","cost","sum","Blocks","list","blockInd","insert","last","swapBlock","updateBlockPositions","inactive","Solver","LAGRANGIAN_TOLERANCE","nb","_this5","cs","setStartingPositions","setDesiredPositions","mostViolated","minSlack","deletePoint","ZERO_UPPERBOUND","satisfy","solve","lastcost","TreeBase","data","res","_root","iter","iterator","_comparator","_cursor","_ancestors","get_child","size","find","lowerBound","_bound","upperBound","cmp","Iterator","each","cb","it","reach","cur","tree","_tree","root","_minNode","save","_maxNode","start","Node","red","dir","set_child","val","RBTree","comparator","ret","head","undefined","gp","ggp","is_red","dir2","single_rotate","double_rotate","found","sr","sibling","gpc","computeGroupBounds","bounds","reduce","union","Rectangle","empty","inflate","padding","X","y","Y","POSITIVE_INFINITY","NEGATIVE_INFINITY","cx","cy","overlapX","ux","vx","overlapY","uy","vy","setXCentre","setYCentre","dy","lineIntersections","x1","y1","x2","y2","sides","intersections","lineIntersection","rayIntersection","ints","vertices","x3","y3","x4","y4","dx12","dx34","dy12","dy34","dx31","dy31","pad","makeEdgeBetween","ah","si","ti","al","sourceIntersection","targetIntersection","arrowStart","makeEdgeTo","pos","makeRBTree","Event","isOpen","compareEvents","xRect","getCentre","getOpen","getClose","getSize","makeRect","open","close","center","findNeighbours","scanline","forward","reverse","findIter","uovervX","yRect","generateGroupConstraints","minSep","isContained","gn","ln","childConstraints","ccs","concat","minVar","maxVar","variable","generateConstraints","gapAdjustment","rect","N","assert","events","makeConstraint","sep","mkcon","generateXConstraints","generateYConstraints","generateXGroupConstraints","generateYGroupConstraints","IndexedVariable","Projection","avoidOverlaps","variables","createConstraints","w2","h2","stiffness","createSeparation","makeFeasible","dim","offsets","nextPos","createAlignment","xConstraints","yConstraints","slice","isSep","filter","setupVariablesAndBounds","y0","desired","getDesired","fixed","fixedWeight","h","ix","iy","xProject","px","xmin","xmax","p2","yProject","py","ymin","ymax","projectFunctions","_this6","updateNodeBounds","updateGroupBounds","starting","solver","PairingHeap","elem","subheaps","toString","selector","str","needComma","subheap","isHeap","lessThan","every","obj","heap2","removeMin","mergePairs","firstPair","remaining","decreaseKey","newValue","setHeapNode","newHeap","pairingNode","PriorityQueue","top","arg","reduceKey","heapNode","newKey","Neighbour","QueueEntry","Calculator","getLength","DistanceMatrix","dijkstraNeighbours","DistancesFromNode","PathFromNodeToNode","PathFromNodeToNodeWithPrevCost","prevCost","qu","visitedFrom","neighbour","viduid","cc","path","dest","Point","LineSegment","PolyPoint","isLeft","P0","P1","P2","above","vj","below","Rtangent_PointPolyC","P","V","dnC","floor","Ltangent_PointPolyC","tangent_PolyPolyC","W","t1","t2","cmp1","cmp2","ix1","ix2","done","RLtangent_PolyPolyC","BiTangent","BiTangents","TVGPoint","VisibilityVertex","polyid","polyvertid","vv","VisibilityEdge","TangentVisibilityGraph","g0","E","Pi","Pj","tangents","addEdgeIfVisible","i1","i2","intersectsPolys","addPoint","Vclosed","poly","rtan","ltan","intersects","int","bt","v1","v2","v3","w1","w3","v1v2w2","v2w1w2","v2w2w3","w1w2v2","w2v1v2","w2v2v3","ll","rr","lr","isAnyPInQ","isPointInsidePoly","EventType","packingOptions","applyPacking","graphs","node_size","desired_ratio","centerGraph","svg_width","svg_height","real_width","real_height","min_width","global_bottom","line","step","max_width","put_rect","parent","space_left","bottom","graph","min_x","min_y","max_x","max_y","array","calculate_bb","curr_best_f","curr_best","get_entire_width","iterationCounter","f_x1","f_x2","flag","df","put_nodes_to_right_positions","separateGraphs","marks","ways","clusters","link","n1","n2","explore_node","is_new","adjacent","isGroup","Layout","setLinkLength","_linkType","on","listener","event","trigger","kick","tick","_alpha","_threshold","_running","_lastStress","_descent","s1","updateNodePositions","_links","_groups","_rootGroup","gi","powerGraphGroups","powergraph","arguments","_avoidOverlaps","handleDisconnected","_handleDisconnected","flowLayout","minSeparation","_directedLinkConstraints","_constraints","distanceMatrix","_distanceMatrix","_canvasSize","defaultNodeSize","_defaultNodeSize","groupCompactness","_groupCompactness","linkDistance","_linkDistance","_linkLengthCalculator","linkType","convergenceThreshold","getLinkLength","getLinkType","idealLength","initialUnconstrainedIterations","initialUserConstraintIterations","initialAllConstraintsIterations","gridSnapIterations","keepRunning","distances","ao","strength","addAttraction","curConstraints","initialLayout","separateOverlappingComponents","G0","resume","gg","stop","prepareEdgeRouting","nodeMargin","_visibilityGraph","routeEdge","edge","draw","lineData","vg2","port1","port2","shortestPath","route","innerBounds","linkId","dragStart","storeOffset","dragOrigin","stopNode","origin","_dragGroupOffsetX","_dragGroupOffsetY","drag","dragEnd","mouseOver","mouseOut","LayoutAdaptor","options","dragstart","dragend","eventType","D3StyleLayoutAdaptor","d3Context","self","d3","dispatch","d3layout","behavior","call","d3event","timer","D3v4StyleLayoutAdaptor","subject","_Layout","NodeWrapper","leaf","Vert","LongestCommonSubsequence","mf","findMatch","tr","mr","reversed","match","getSequence","GridRouter","originalnodes","accessor","groupPadding","getBounds","getChildren","cols","getGridLines","rows","ports","backToFront","getDepth","colMids","midPoints","rowMids","rowx","rowX","coly","colY","hlines","vlines","lines","verts","li","intersect","isHoriz","delta","avg","columns","ls","overlapping","toUpperCase","col","splice","indexOf","depth","mids","findLineage","lineage","findAncestorPathBetween","aa","ba","commonAncestor","lineages","siblingObstacles","lineageLookup","obstacles","getSegmentSets","routes","vsegments","ei","edgeid","vsegmentsets","segmentset","segments","nudgeSegs","leftOf","e1","e2","lind","rind","nudgeSegments","ss","openCount","routeEdges","nudgeGap","routePaths","order","orderEdges","makeSegments","unreverseEdges","segment","angleBetween2Lines","line1","line2","angle1","atan2","angle2","diff","PI","getOrder","pairs","edgeOrder","lcs","copyPoint","isStraight","obstacleLookup","passableEdges","pathPoints","getRoutePath","cornerradius","arrowwidth","arrowheight","arrowcorner1","arrowcorner2","routepath","arrowpath","angle","arrowtip","Link3D","actualLength","Layout3D","idealLinkLength","dims","z","linkLength","LinkAccessor","useJaccardLinkLengths","descent","S","minmax","maxmin","maxmax","bot","version","isD3V3","pgLayout","margin","groupMargin","cola","routerNode","name","gridRouterNodes","powerGraph","grouppadding","sourceInd","spans","desiredCenter","leftMost","rightMost","leftMostSize","rightMostSize","vLower","vUpper","newCenters"],"mappings":"4qCAOiBA,EACT,SACWC,EACAC,EACAC,eAFAF,cACAC,YACAC,GAGFC,wBASGC,EAAWC,EAAuBC,EAAsCC,mCAAtCD,OACrCE,QAAU,IAAIC,MAAML,QACpBM,MAAQ,GACTH,OACKI,qBAAqBJ,OACvB,MACEG,MAAME,KAAK,IAAIC,OACf,IAAIC,EAAI,EAAGA,EAAIV,IAAKU,OAChBJ,MAAM,GAAGK,IAAIC,KAAKR,QAAQM,GAAK,IAAIG,EAAOH,SAElDI,EAAIb,EAAMc,OACfd,EAAMe,SAAQ,SAAAC,OACNC,EAAIC,EAAKf,QAAQF,EAAakB,eAAeH,IAC7CI,EAAIF,EAAKf,QAAQF,EAAaoB,eAAeL,IAC7CnB,EAAOI,EAAaqB,QAAQN,GAChCC,EAAEM,SAASb,IAAIb,EAAMuB,GACrBA,EAAEI,SAASd,IAAIb,EAAMoB,iCAIrBX,qBAAA,SAAqBmB,OACrBC,EAAY,IAAIlB,OACfH,MAAME,KAAKmB,OACX,IAAIjB,EAAI,EAAGA,EAAIgB,EAAME,OAAOb,SAAUL,EAAG,KACtCmB,EAAOH,EAAME,OAAOlB,GACpBoB,EAAS,IAAIjB,EAAOgB,EAAKE,SACxB3B,QAAQyB,EAAKE,IAAMD,EACxBH,EAAUhB,IAAImB,MAEdJ,EAAMM,WACD,IAAIC,EAAI,EAAGA,EAAIP,EAAMM,OAAOjB,SAAUkB,EAAG,KACtCC,EAAQR,EAAMM,OAAOC,GAErBE,EAAa,OACZ,IAAIC,KAAQF,EACA,WAATE,GAA8B,WAATA,GAAqBF,EAAMG,eAAeD,KAC/DD,EAAWC,GAAQF,EAAME,IAEjCT,EAAUhB,IAAI,IAAIE,GAAQ,EAAEoB,EAAG,IAAIK,EAAY,IAAIA,EAAY1B,KAAKL,qBAAqB2B,GAAQC,WAGlGR,KAIXY,MAAA,SAAMC,EAAWC,EAAWC,YAAAA,IAAAA,EAAY,OAChCC,EAAQH,EAAEf,SAASmB,aAAaH,EAAEhB,UAClCoB,EAASL,EAAEhB,SAASoB,aAAaH,EAAEjB,UACnCsB,EAAW,IAAIrC,EACnBqC,EAASnC,IAAI6B,GACbM,EAASnC,IAAI8B,OACTM,EAAI,IAAIlC,EAAOD,KAAKR,QAAQW,OAAQ8B,EAAQF,EAAOG,QAClD1C,QAAQI,KAAKuC,OACdC,EAAS,SAAC9B,EAAaR,EAAWuC,GAClC/B,EAAEgC,QAAO,SAACC,EAAIC,GACVD,EAAGD,QAAO,SAAAlD,OACFqD,EAAgBrD,EAAEU,GACtB2C,EAAI1C,IAAIyC,EAAUL,GAClBM,EAAIC,OAAOF,EAAUZ,GACrBa,EAAIC,OAAOF,EAAUX,GACVD,EAAES,GAAIK,OAAOF,EAAUpD,GACvByC,EAAEQ,GAAIK,OAAOF,EAAUpD,iBAI9CgD,EAAOH,EAAQ,WAAY,YAC3BG,EAAOL,EAAO,WAAY,iBACrB7B,GAAK6B,EAAMY,QAAUV,EAAOU,aAC5BjD,MAAMoC,GAAGY,OAAOd,QAChBlC,MAAMoC,GAAGY,OAAOb,QAChBnC,MAAMoC,GAAG/B,IAAIoC,GACXA,KAGHS,WAAA,SAAWd,YAAAA,IAAAA,EAAY,WAMvBe,EAAK7C,KAAKN,MAAMoC,GAAGtC,UACnBJ,EAAIyD,EAAG1C,OACP2C,EAAS,IAAIrD,MAAML,GAAKA,EAAI,IAC5B2D,EAAM,EACDjD,EAAI,EAAGkD,EAAK5D,EAAI,EAAGU,EAAIkD,IAAMlD,MAC7B,IAAIuB,EAAIvB,EAAE,EAAGuB,EAAIjC,IAAKiC,EAAG,KACtBO,EAAIiB,EAAG/C,GAAI+B,EAAIgB,EAAGxB,GACtByB,EAAOC,GAAO,CAAE5B,GAAI4B,EAAKE,OAAQjD,KAAKiD,OAAOrB,EAAGC,GAAID,EAAGA,EAAGC,EAAGA,GAC7DkB,WAGDD,KAGXI,YAAA,eACS,IAAIpD,EAAI,EAAGA,EAAIE,KAAKN,MAAMS,SAAUL,OAEjCE,KAAKN,MAAMI,GAAGN,UAAUW,OAAS,QAIjCgC,EADKnC,KAAK4C,WAAW9C,GAAGqD,MAAK,SAACvB,EAAGC,UAAMD,EAAEqB,QAAUpB,EAAEoB,OAASrB,EAAET,GAAKU,EAAEV,GAAKS,EAAEqB,OAASpB,EAAEoB,UAClF,QACPd,EAAEc,QAAUjD,KAAKE,eAChByB,MAAMQ,EAAEP,EAAGO,EAAEN,EAAG/B,IACd,MAIPmD,OAAA,SAAOrB,EAAWC,OAClBE,EAAQH,EAAEf,SAASmB,aAAaH,EAAEhB,UAClCoB,EAASL,EAAEhB,SAASoB,aAAaH,EAAEjB,iBAChCZ,KAAKE,EAAI6B,EAAMY,QAAUV,EAAOU,WAG3CS,kBAAA,SAAkBC,cACVjC,EAAS,UA8BrB,SAASkC,EAAS9D,EAAoBsB,EAAOM,GACzC5B,EAAQ8C,QAAO,SAAAH,MACPA,EAAEoB,SACGzC,EAAME,SAAQF,EAAME,OAAS,IAClCF,EAAME,OAAOpB,KAAKuC,EAAEhB,QACjB,KACCqC,EAAI1C,KACRqB,EAAEsB,IAAMrC,EAAOjB,QACVgC,EAAEuB,YAAcvB,EAAEwB,eAAgB,IACnCH,EAAI,CAAErC,GAAIgB,EAAEsB,KACRtB,EAAEwB,mBAEG,IAAInC,KAAQW,EAAEZ,WACfiC,EAAEhC,GAAQW,EAAEZ,WAAWC,GAC1BV,EAAMM,SAAQN,EAAMM,OAAS,IAClCN,EAAMM,OAAOxB,KAAKuC,EAAEsB,KACpBrC,EAAOxB,KAAK4D,GAEhBF,EAASnB,EAAED,SAAUsB,EAAGpC,OA9C5BkC,CAAStD,KAAKN,MAAM,GADT,GACmB0B,GACrBpB,KAAK4D,WACXxD,SAAQ,SAAAC,OACHuB,EAAIiC,EAAKrE,QAAQa,EAAErB,QACnB6C,EAAIgC,EAAKrE,QAAQa,EAAEpB,QACvBoE,EAAgBzD,KAAK,IAAIb,OACJ,IAAV6C,EAAE6B,IAAsBpD,EAAErB,OAASoC,EAAOQ,EAAE6B,UAClC,IAAV5B,EAAE4B,IAAsBpD,EAAEpB,OAASmC,EAAOS,EAAE4B,KACnDpD,EAAEnB,UAGHkC,KAGXwC,SAAA,eACQE,EAAK,UACT3E,EAAc4E,SAAS/D,KAAKN,MAAM,GAAIoE,GAC/BA,KAGJC,SAAP,SAAgBvE,EAAoBsE,GAChCtE,EAAQ8C,QAAO,SAAAH,GACXA,EAAE4B,SAASD,GACX3E,EAAc4E,SAAS5B,EAAED,SAAU4B,YA4BlC7D,wBAIEkB,EACAP,EACAC,EACAqB,EACAX,YAHAX,IAAAA,EAAqB,IAAIc,YACzBb,IAAAA,EAAqB,IAAIa,YACzBQ,IAAAA,EAAsB,IAAIrC,WAH1BsB,gBACAP,gBACAC,gBACAqB,kBACAX,6BAEXwC,SAAA,SAASD,mBACAlD,SAAS0B,QAAO,SAACC,EAAIyB,GACtBzB,EAAGD,QAAO,SAAArD,GACN6E,EAAGlE,KAAK,IAAIb,EAAUkF,EAAK9C,GAAIlC,EAAOkC,GAAI6C,aAKtDT,OAAA,kBACqC,IAA1BvD,KAAKkC,SAASS,WAGzBe,SAAA,kBACqC,IAA1B1D,KAAKY,SAAS+B,SAA2C,IAA1B3C,KAAKa,SAAS8B,WAGxDgB,aAAA,uBACsC,IAApB3D,KAAKuB,iBAUd1B,qCACI,8BACb8C,MAAA,kBACWuB,OAAOC,KAAKnE,KAAKoE,OAAOjE,UAEnC6B,aAAA,SAAaqC,OACLC,EAAS,IAAIzE,SACjByE,EAAOF,MAbf,SAAsBjC,EAAQ/C,OACtBU,EAAI,OACH,IAAIyE,KAAKpC,EAAOoC,KAAKnF,IAAGU,EAAEyE,GAAKpC,EAAEoC,WAC/BzE,EAUYkC,CAAahC,KAAKoE,MAAOC,EAAMD,OACvCE,KAEXE,kBAAA,SAAkBH,UACPrE,KAAKgC,aAAaqC,GAAO1B,WAEpC8B,SAAA,SAAStD,UACEA,KAAMnB,KAAKoE,SAEtBrE,IAAA,SAAIoC,QACKiC,MAAMjC,EAAEhB,IAAMgB,KAEvBO,OAAA,SAAOP,UACInC,KAAKoE,MAAMjC,EAAEhB,OAExBmB,OAAA,SAAOoC,OACE,IAAIC,KAAO3E,KAAKoE,MACjBM,EAAE1E,KAAKoE,MAAMO,OAGrBnF,QAAA,eACQoF,EAAK,eACJtC,QAAO,SAAAH,GACHA,EAAEwB,gBACHiB,EAAGhF,KAAKuC,MAETyC,QAIFlD,oCACG,UACA,6BACZiB,MAAA,kBACW3C,KAAKZ,KAEhBqF,SAAA,SAAStD,OACDmD,GAAS,cACRO,eAAc,SAAA1C,GACVmC,GAAUnC,EAAEhB,IAAMA,IACnBmD,GAAS,MAGVA,KAEXvE,IAAA,SAAIyC,EAAkBL,IACCK,KAAYxC,KAAK8E,KAAO9E,KAAK8E,KAAKtC,GAAYxC,KAAK8E,KAAKtC,GAAY,IAAI3C,GACzFE,IAAIoC,KACJnC,KAAKZ,KAEXsD,OAAA,SAAOF,EAAkBL,OACjBI,EAAgBvC,KAAK8E,KAAKtC,GAC9BD,EAAGG,OAAOP,GACS,IAAfI,EAAGI,gBACI3C,KAAK8E,KAAKtC,KAEnBxC,KAAKZ,KAEXkD,OAAA,SAAOoC,OACE,IAAIlC,KAAYxC,KAAK8E,KACtBJ,EAAa1E,KAAK8E,KAAKtC,GAAWuC,OAAOvC,OAGjDqC,cAAA,SAAcH,QACLpC,QAAO,SAACC,EAAIyC,UAAOzC,EAAGD,OAAOoC,SAEtC1C,aAAA,SAAaqC,OACLC,EAAmB,IAAI5C,cACtBY,QAAO,SAACC,EAAIyC,MACTA,KAAMX,EAAMS,KAAM,KACdhF,EAAIyC,EAAGP,aAAaqC,EAAMS,KAAKE,IAC/B5F,EAAIU,EAAE6C,QACNvD,EAAI,IACJkF,EAAOQ,KAAKE,GAAMlF,EAClBwE,EAAOlF,GAAKA,OAIjBkF,iBAQCW,EAAgBC,EAAcC,EAAeC,EAA4B7F,WAEjF8F,EAAI,IAAIlG,EADJ+F,EAAM/E,OACegF,EAAOC,EAAI7F,GACjC8F,EAAEnC,oBACLoC,EAA0B,GAC1B9B,EAAI6B,EAAEjC,kBAAkBkC,UAC5BA,EAAWlF,SAAQ,SAAUC,OACrBqE,EAAI,SAACa,OACD/B,EAAInD,EAAEkF,GACM,iBAAL/B,IAAenD,EAAEkF,GAAOL,EAAM1B,KAE7CkB,EAAE,UACFA,EAAE,aAEC,CAAEtD,OAAQoC,EAAG8B,WAAYA,GCrUpC,SAASE,EAAW5D,EAAQC,OACpB4D,EAAI,OACH,IAAI3F,KAAK8B,EAAG6D,EAAE3F,GAAK,OACnB,IAAIA,KAAK+B,EAAG4D,EAAE3F,GAAK,UACjBoE,OAAOC,KAAKsB,GAAGtF,OAI1B,SAASqE,EAAkB5C,EAAaC,OAChCzC,EAAI,MACH,IAAIU,KAAK8B,OAAuB,IAATC,EAAE/B,MAAsBV,SAC7CA,EAmBX,SAASsG,EAAyBP,EAAeQ,EAAWjB,EAA+BU,OACnFQ,EAjBR,SAA6BT,EAAeC,OACpCQ,EAAa,GACbC,EAAgB,SAACJ,EAAGlB,QACS,IAAlBqB,EAAWH,KAClBG,EAAWH,GAAK,IACpBG,EAAWH,GAAGlB,GAAK,WAEvBY,EAAM/E,SAAQ,SAAAC,OACNoF,EAAIL,EAAG5E,eAAeH,GAAIkE,EAAIa,EAAG1E,eAAeL,GACpDwF,EAAcJ,EAAGlB,GACjBsB,EAActB,EAAGkB,MAEdG,EAKUE,CAAcX,EAAOC,GACtCD,EAAM/E,SAAQ,SAAA2F,OACNnE,EAAIgE,EAAWR,EAAG5E,eAAeuF,IACjClE,EAAI+D,EAAWR,EAAG1E,eAAeqF,IACrCX,EAAGY,UAAUD,EAAG,EAAIJ,EAAIjB,EAAE9C,EAAGC,gBAOrBoE,EAA+Bd,EAAeC,EAA8BO,YAAAA,IAAAA,EAAY,GACpGD,EAAmBP,EAAOQ,GAAG,SAAC/D,EAAGC,UAAMqE,KAAKC,KAAKX,EAAW5D,EAAGC,GAAK2C,EAAkB5C,EAAGC,MAAKuD,YAMlFgB,EAAyBjB,EAAeC,EAA8BO,YAAAA,IAAAA,EAAY,GAC9FD,EAAmBP,EAAOQ,GAAG,SAAC/D,EAAGC,UAC7BqE,KAAKG,IAAInC,OAAOC,KAAKvC,GAAGzB,OAAQ+D,OAAOC,KAAKtC,GAAG1B,QAAU,IAAM,EAAIqE,EAAkB5C,EAAGC,GAAK2D,EAAW5D,EAAGC,KACzGuD,YAqBMkB,EAAsClH,EAAW+F,EAAeoB,EAC5EnB,OAEIoB,EAAaC,EAA4BrH,EAAG+F,EAAOC,GACnDF,EAAQ,GACZsB,EAAWpG,SAAQ,SAACiF,EAAEvF,UAClBuF,EAAEjF,SAAQ,SAAAmE,UAAKW,EAAMX,GAAKzE,YAE1B4G,EAAqB,UACzBvB,EAAM/E,SAAQ,SAAA2F,OACNY,EAAKvB,EAAG5E,eAAeuF,GAAIa,EAAKxB,EAAG1E,eAAeqF,GAC9Cb,EAAMyB,KAASzB,EAAM0B,IAEzBF,EAAY9G,KAAK,CACb2G,KAAMA,EACNM,KAAMF,EACNG,MAAOF,EACPG,IAAK3B,EAAG4B,iBAAiBjB,QAI9BW,WASKD,EAAkCQ,EAAqB5H,EAAe+F,OAC9EF,EAAQ,GACRgC,EAAQ,EACRC,EAAQ,GACRX,EAAa,YACRY,EAAc7C,GAEnBA,EAAE2C,MAAQ3C,EAAE8C,QAAUH,IACtBC,EAAMvH,KAAK2E,GACXA,EAAE+C,SAAU,gBAGE/C,EAAEgD,oBAAK,KAAZ5B,eACkB,IAAZA,EAAEuB,OAETE,EAAczB,GACdpB,EAAE8C,QAAUnB,KAAKG,IAAI9B,EAAE8C,QAAS1B,EAAE0B,UAC3B1B,EAAE2B,UAET/C,EAAE8C,QAAUnB,KAAKG,IAAI9B,EAAE8C,QAAS1B,EAAEuB,WAKtC3C,EAAE8C,UAAY9C,EAAE2C,MAAO,SAEnBM,EAAY,GACTL,EAAMhH,UACTwF,EAAIwB,EAAMM,OACRH,SAAU,EAEZE,EAAU5H,KAAK+F,GACXA,IAAMpB,KAGdiC,EAAW5G,KAAK4H,EAAUE,KAAI,SAAAnD,UAAKA,EAAEpD,YAGxC,IAAIrB,EAAI,EAAGA,EAAImH,EAAanH,IAC7BoF,EAAMtF,KAAK,CAACuB,GAAIrB,EAAGyH,IAAK,mBAEdlI,kBAAO,KAAZgB,UACDkE,EAAIW,EAAME,EAAG5E,eAAeH,IAC5BsF,EAAIT,EAAME,EAAG1E,eAAeL,IAChCkE,EAAEgD,IAAI3H,KAAK+F,iBAEDT,sBAALX,YAAmC,IAAZA,EAAE2C,OAAuBE,EAAc7C,UAChEiC,MC1JEmB,qCACyB,8BAOlC5H,IAAA,SAAIoB,EAAYyG,QAIPC,MAAM1G,GAAMyG,KAKrBE,MAAA,gBACSD,MAAQ,MAMjBE,QAAA,eACS,IAAIhC,KAAK/F,KAAK6H,aAAc,SAC1B,KAMXG,MAAA,SAAMtD,OACG,IAAIqB,KAAK/F,KAAK6H,MACfnD,EAAEK,OAAOgB,GAAI/F,KAAK6H,MAAM9B,2BAevBkC,wBA8FGL,EAAsBM,EAAsBC,EAAqBjD,YAArBiD,IAAAA,EAAe,eAAMjD,IAAAA,EAAgB,WAA3DgD,SAAsBC,iBA7F7B,2BA2CO,oBACJ,sBACA,0BACI,cAEjB,IAAIC,eAEmD,UA4C/DC,OAASnD,OACT0C,EAAIA,OACJ9F,EAAI8F,EAAEzH,WACPf,EAAIY,KAAKZ,EAAIwI,EAAE,GAAGzH,YACjBmI,EAAI,IAAI7I,MAAMO,KAAK8B,QACnB0B,EAAI,IAAI/D,MAAMO,KAAK8B,QACnByG,GAAK,IAAI9I,MAAMO,KAAK8B,QACpBF,EAAI,IAAInC,MAAMO,KAAK8B,QACnBD,EAAI,IAAIpC,MAAMO,KAAK8B,QACnBuD,EAAI,IAAI5F,MAAMO,KAAK8B,QACnB0G,EAAI,IAAI/I,MAAMO,KAAK8B,QACnBzB,EAAI,IAAIZ,MAAMO,KAAK8B,QACnB2G,GAAK,IAAIhJ,MAAMO,KAAK8B,QACpB4G,GAAK,IAAIjJ,MAAMO,KAAK8B,QACpB6G,KAAO,IAAIlJ,MAAMO,KAAK8B,QACtB+F,MAAQ,IAAIF,OACZiB,KAAO7D,OAAO8D,kBACRxH,EAAPvB,EAAIV,EACDU,SACHuB,EAAIjC,IACKiC,EAAIvB,GAAG,KACR0I,EAAIN,EAAEpI,GAAGuB,GACTmH,EAAI,GAAKA,EAAIxI,KAAK4I,YACbA,KAAOJ,OAIpBxI,KAAK4I,OAAS7D,OAAO8D,YAAW7I,KAAK4I,KAAO,GAChD9I,EAAIE,KAAK8B,EACFhC,KAAK,UACH0D,EAAE1D,GAAK,IAAIL,MAAML,QACjBkJ,EAAExI,GAAK,IAAIL,MAAML,GACtBiC,EAAIjC,EACGiC,UACEiH,EAAExI,GAAGuB,GAAK,IAAI5B,MAAML,QAExBmJ,GAAGzI,GAAK,IAAIL,MAAML,QAClBwC,EAAE9B,GAAK,IAAIL,MAAML,QACjByC,EAAE/B,GAAK,IAAIL,MAAML,QACjBiG,EAAEvF,GAAK,IAAIL,MAAML,QACjBoJ,EAAE1I,GAAK,IAAIL,MAAML,QACjBiB,EAAEP,GAAK,IAAIL,MAAML,QACjBqJ,GAAG3I,GAAK,IAAIL,MAAML,QAClBsJ,GAAG5I,GAAK,IAAIL,MAAML,QAClBuJ,KAAK7I,GAAK,IAAIL,MAAML,MA7EnB0J,kBAAP,SACHlB,EACA9H,EACA2F,EACAlB,EACAW,eAGI6D,EAAKnB,EAAE9H,GAAG2F,GAAKmC,EAAE9H,GAAGyE,GAClByE,EACD,GAALlJ,eACQoF,EAAMO,yBAAIwD,QAAS,eAAM/D,EAAMX,yBAAI0E,QAAS,IAAM,eAClD/D,EAAMO,yBAAIyD,SAAU,eAAMhE,EAAMX,yBAAI2E,SAAU,IAAM,SACxDH,EAAKC,EACTD,GAAMC,EACKD,GAAMC,EACjBD,GAAMC,EACW,GAAND,IACXA,GAAM,IAGCA,KA4DGI,mBAAP,SAA0B/J,EAAWsF,WACpC0E,EAAI,IAAI3J,MAAML,GACTU,EAAI,EAAGA,EAAIV,IAAKU,EAAG,CACxBsJ,EAAEtJ,GAAK,IAAIL,MAAML,OACZ,IAAIiC,EAAI,EAAGA,EAAIjC,IAAKiC,EACrB+H,EAAEtJ,GAAGuB,GAAKqD,EAAE5E,EAAGuB,UAGhB+H,8BAGHC,UAAA,0BACA5D,EAAI,IAAIhG,MAAMO,KAAK8B,GACnBiE,EAAI,EACCjG,EAAI,EAAGA,EAAIE,KAAK8B,IAAKhC,EAAG,KACzB8H,EAAInC,EAAE3F,GAAKE,KAAKsJ,OAAOC,eAAe,IAAM,GAAK,GACrDxD,GAAK6B,EAAIA,SAEb7B,EAAIG,KAAKC,KAAKJ,GACPN,EAAEiC,KAAI,SAAAE,UAAIA,GAAKrH,EAAKqI,KAAO7C,SAI/ByD,mBAAA,SAAmB5B,cAChBxI,EAAIY,KAAKZ,OACXA,EAAI,YACJU,EAOA0I,EAAI,IAAI/I,MAAcO,KAAK8B,GAC3B2H,EAAK,IAAIhK,MAAcO,KAAK8B,GAC5B4H,EAAM,IAAIjK,MAAcO,KAAK8B,GAC7B6H,EAAO,EAGFlE,EAAI,EAAGA,EAAIrG,IAAKqG,EAAG,KAEnB3F,EAAI,EAAGA,EAAIE,KAAK8B,IAAKhC,EAAG4J,EAAI5J,GAAKE,KAAKwD,EAAE1D,GAAG2F,GAAK,MAGhD,IAAIlB,EAAI,EAAGA,EAAInF,IAAKmF,KACjBkB,IAAMlB,WAINqF,EAAexK,EACfyK,EAAkB,EACfD,KAAgB,KACnBC,EAAkB,EACb/J,EAAI,EAAGA,EAAIE,KAAK8B,IAAKhC,EAAG,KAEnBiJ,EAAMP,EAAE1I,GAAKmI,EAAQa,kBACvBlB,EACA9H,EACA2F,EACAlB,EACAvE,KAAKqI,QAETwB,GAAmBJ,EAAG3J,GAAKiJ,EAAKA,KAEhCc,EAAkB,KAAM,UACtBC,EAAK9J,KAAKqJ,gBACXvJ,EAAI,EAAGA,EAAIE,KAAK8B,IAAKhC,EAAG8H,EAAE9H,GAAGyE,IAAMuF,EAAGhK,OAEzCiK,EAAW7D,KAAKC,KAAK0D,GACrBG,EAAgBhK,KAAKkI,EAAEzC,GAAGlB,GAI5B0F,EAAmB,MAAVjK,KAAKmI,EAAYnI,KAAKmI,EAAE1C,GAAGlB,GAAK,KAGzC0F,EAAS,GAAKF,EAAWC,IAAkBE,SAASF,OAC/ClK,EAAI,EAAGA,EAAIE,KAAK8B,IAAKhC,OAAQwI,EAAExI,GAAG2F,GAAGlB,GAAK,OAK/C0F,EAAS,IACTA,EAAS,OAEPE,EAAmBH,EAAgBA,EACrCI,EAAK,EAAIH,GAAUF,EAAWC,IAAkBG,EAAmBJ,GACnEM,EAAgBR,EAAkBE,EAClCO,EAAK,GAAKL,GAAUE,EAAmBE,OACtCH,SAASE,IACVG,QAAQC,IAAIJ,GACXtK,EAAI,EAAGA,EAAIE,KAAK8B,IAAKhC,OACjB0D,EAAE1D,GAAG2F,IAAM+C,EAAE1I,GAAKsK,EACvBV,EAAI5J,IAAME,KAAKsI,EAAExI,GAAG2F,GAAGlB,GAAK+F,GAAM,EAAID,EAAgBL,GAAiBP,EAAG3J,GAAK+J,SAGlF/J,EAAI,EAAGA,EAAIE,KAAK8B,IAAKhC,EAAG6J,EAAOzD,KAAKuE,IAAId,EAAM3J,KAAKsI,EAAExI,GAAG2F,GAAGA,GAAKiE,EAAI5J,YAGzE4K,EAAI1K,KAAK2K,aAAa,EACtBnH,EAAIxD,KAAK2K,aAET7I,EADI9B,KAAK4K,cACAF,EAAIA,GACbG,EAAW7K,KAAK8K,iBAEXrF,EAAY,EAAGA,EAAIoF,IAAYpF,MAC/B3F,EAAI,EAAGA,EAAIE,KAAK8B,IAAKhC,EAAG,KACrBiL,EAAM/K,KAAK4H,EAAE9H,GAAG2F,GAChBtD,EAAI4I,EAAMvH,EACVkB,EAAIvC,EAAI,EACR6I,EAAI7I,EAAIuC,EAERqE,EADI7C,KAAK+E,IAAIvG,IACF,GAAOqG,EAAMC,EAAIxH,EAC3BuH,EAAM,EAAKA,GAAOC,EAAI,GAAKxH,EAAIuH,GAAOC,EAAI,GAAKxH,GAC/CkH,EAAI3B,GAAMA,GAAM2B,IACb1K,KAAKkL,sBACA1H,EAAE1D,GAAG2F,IAAMkE,EAAO7H,EAAIiH,OACtBT,EAAExI,GAAG2F,GAAGA,IAAMkE,EAAO7H,SAErB0B,EAAE1D,GAAG2F,IAAM3D,EAAIiH,OACfT,EAAExI,GAAG2F,GAAGA,IAAM3D,IAK9B9B,KAAK6H,MAAME,gBACPF,MAAMG,OAAM,SAACvC,EAAG0F,OACZrL,EAAI,EAAGA,EAAI+D,EAAK/B,IAAKhC,EACtB+D,EAAKyE,EAAExI,GAAG2F,GAAGA,IAAMkE,EACnB9F,EAAKL,EAAE1D,GAAG2F,IAAMkE,GAAQwB,EAAErL,GAAK8H,EAAE9H,GAAG2F,WAcrC2F,QAAP,SAAexJ,EAAaC,WAC5B+F,EAAI,EAAG9H,EAAI8B,EAAEzB,OACVL,KAAK8H,GAAKhG,EAAE9B,GAAK+B,EAAE/B,UACnB8H,KAIIyD,cAAP,SAAqBlJ,EAAeoC,EAAamG,WACjD5K,EAAIqC,EAAEhC,OACHL,KAAK4K,EAAE5K,GAAKmI,EAAQmD,QAAQjJ,EAAErC,GAAIyE,MAMtC+G,gBAAA,SAAgB9C,WACf+C,EAAY,EAAGC,EAAc,EACxB1L,EAAI,EAAGA,EAAIE,KAAK8B,IAAKhC,EAC1ByL,GAAatD,EAAQmD,QAAQpL,KAAKwD,EAAE1D,GAAI0I,EAAE1I,IAC1CmI,EAAQoD,cAAcrL,KAAKsI,EAAExI,GAAI0I,EAAE1I,GAAIE,KAAKuI,GAAGzI,IAC/C0L,GAAevD,EAAQmD,QAAQ5C,EAAE1I,GAAIE,KAAKuI,GAAGzI,WAE7B,IAAhB0L,GAAsBtB,SAASsB,GAC5B,EAAID,EAAYC,EADiC,KAIrDC,aAAA,gBACEjC,mBAAmBxJ,KAAK4H,WACzB8D,EAAQ1L,KAAKsL,gBAAgBtL,KAAKwD,GAC7B1D,EAAI,EAAGA,EAAIE,KAAK8B,IAAKhC,OACrB6L,gBAAgB3L,KAAK4H,EAAE9H,GAAIE,KAAKwD,EAAE1D,GAAI4L,UAExC1L,KAAK4L,mBAGDC,KAAP,SAAYjK,EAAeC,WAC3BM,EAAIP,EAAEzB,OAAQf,EAAIyC,EAAE,GAAG1B,OAClBL,EAAI,EAAGA,EAAIqC,IAAKrC,MAChB,IAAIuB,EAAI,EAAGA,EAAIjC,IAAKiC,EACrBQ,EAAE/B,GAAGuB,GAAKO,EAAE9B,GAAGuB,MAWnByK,eAAA,SAAeC,EAAgBrB,EAAelC,EAAewD,GACjE/D,EAAQ4D,KAAKE,EAAIrB,QACZiB,gBAAgBjB,EAAE,GAAIlC,EAAE,GAAIwD,GAC7BhM,KAAKiM,SAASjM,KAAKiM,QAAQ,GAAGF,EAAG,GAAIA,EAAG,GAAIrB,EAAE,SAC7CiB,gBAAgBjB,EAAE,GAAIlC,EAAE,GAAIwD,GAC7BhM,KAAKiM,SAASjM,KAAKiM,QAAQ,GAAGvB,EAAE,GAAIqB,EAAG,GAAIrB,EAAE,QAG5C,IAAI5K,EAAI,EAAGA,EAAIE,KAAK8B,EAAGhC,SACnB6L,gBAAgBjB,EAAE5K,GAAI0I,EAAE1I,GAAIkM,MAY1BE,OAAP,SAAc/J,EAAW/C,EAAWsF,WACpC5E,EAAIqC,EAAUrC,KAAM,WAChBuB,EAAIjC,EAAUiC,KAAM,GAAGqD,EAAE5E,EAAGuB,MAGhC8K,YAAA,SAAYzH,GAChBuD,EAAQiE,OAAOlM,KAAK8B,EAAG9B,KAAKZ,EAAGsF,MAG3B0H,oBAAA,SAAoBL,EAAgBrB,mBACnClB,mBAAmBuC,OACpBL,EAAQ1L,KAAKsL,gBAAgBtL,KAAKwD,WACjCsI,eAAeC,EAAIrB,EAAG1K,KAAKwD,EAAGkI,GAM/B1L,KAAKiM,QAAS,MACTE,aAAY,SAACrM,EAAGuB,UAAM4C,EAAK5D,EAAEP,GAAGuB,GAAK0K,EAAGjM,GAAGuB,GAAKqJ,EAAE5K,GAAGuB,UACtDgL,EAAOrM,KAAKsL,gBAAgBtL,KAAKK,GACrCgM,EAAOnG,KAAKuE,IAAI,GAAKvE,KAAKG,IAAIgG,EAAM,SAC/BP,eAAeC,EAAIrB,EAAG1K,KAAKK,EAAGgM,OAIpCC,IAAA,SAAIC,WACHC,EAASzH,OAAO8D,UAAW4D,GAAY,GACnCA,GAAaF,KAAe,GAAG,KAC/BjM,EAAIN,KAAK0M,aACbD,EAAYvG,KAAK+E,IAAIuB,EAASlM,EAAI,GAAKN,KAAK2M,UAC5CH,EAASlM,SAENkM,KAGJE,WAAA,2BACEN,oBAAoBpM,KAAK4H,EAAG5H,KAAK4B,GACtCqG,EAAQtD,IAAI3E,KAAK4H,EAAG5H,KAAK4B,EAAG5B,KAAKyI,SAC5B2D,oBAAoBpM,KAAKyI,GAAIzI,KAAK6B,GACvCoG,EAAQtD,IAAI3E,KAAK4H,EAAG5H,KAAK6B,EAAG7B,KAAK0I,SAC5B0D,oBAAoBpM,KAAK0I,GAAI1I,KAAKqF,QAClC+G,oBAAoBpM,KAAKqF,EAAGrF,KAAKwI,OAClCoE,EAAO,cACNT,aAAY,SAACrM,EAAGuB,OACbuG,GAAKiF,EAAKjL,EAAE9B,GAAGuB,GAAK,EAAMwL,EAAKhL,EAAE/B,GAAGuB,GAAK,EAAMwL,EAAKxH,EAAEvF,GAAGuB,GAAKwL,EAAKrE,EAAE1I,GAAGuB,IAAM,EAC9EmH,EAAIqE,EAAKjF,EAAE9H,GAAGuB,GAAKuG,EACvBgF,GAAQpE,EAAIA,EACZqE,EAAKjF,EAAE9H,GAAGuB,GAAKuG,KAEZgF,KAGIjI,IAAP,SAAW/C,EAAeC,EAAeM,GAC7C8F,EAAQiE,OAAOtK,EAAEzB,OAAQyB,EAAE,GAAGzB,QAAQ,SAACL,EAAGuB,UACtCc,EAAErC,GAAGuB,GAAKO,EAAE9B,GAAGuB,IAAMQ,EAAE/B,GAAGuB,GAAKO,EAAE9B,GAAGuB,IAAM,QAG3CsK,gBAAA,SAAgB/D,EAAaY,EAAawD,OACxC,IAAIlM,EAAI,EAAGA,EAAIE,KAAKZ,IAAKU,EAC1B8H,EAAE9H,GAAK8H,EAAE9H,GAAKkM,EAAWxD,EAAE1I,MAI5B8L,cAAA,mBACCY,EAAS,EACJ/G,EAAI,EAAGqH,EAAU9M,KAAKZ,EAAI,EAAGqG,EAAIqH,IAAWrH,MAC5C,IAAIlB,EAAIkB,EAAI,EAAGrG,EAAIY,KAAKZ,EAAGmF,EAAInF,IAAKmF,EAAG,SACpCwB,EAAI,EACCjG,EAAI,EAAGA,EAAIE,KAAK8B,IAAKhC,EAAG,KACzBiJ,EAAK/I,KAAK4H,EAAE9H,GAAG2F,GAAKzF,KAAK4H,EAAE9H,GAAGyE,GAClCwB,GAAKgD,EAAKA,EAEdhD,EAAIG,KAAKC,KAAKJ,OACVyC,EAAIxI,KAAKkI,EAAEzC,GAAGlB,MACb2F,SAAS1B,QACVuE,EAAKvE,EAAIzC,EAEbyG,GAAUO,EAAKA,GADNvE,EAAIA,WAIdgE,eA5ZIvE,eAAuB,WAia7BG,wBAMU4E,YAAAA,IAAAA,EAAe,aAAfA,SALC,cACA,eACA,sBACI,iCAKxBC,QAAA,uBACSD,MAAQhN,KAAKgN,KAAOhN,KAAK4B,EAAI5B,KAAKqF,GAAKrF,KAAKmC,GACzCnC,KAAKgN,MAAQ,IAAMhN,KAAKkN,SAIpC3D,eAAA,SAAelD,EAAaoE,UACjBpE,EAAMrG,KAAKiN,WAAaxC,EAAMpE,SClgBhC8G,wBAKUC,cAAAA,UAJN,UACA,UACA,6BAIbC,YAAA,SAAY9I,OACJ+I,EAAKtN,KAAKoN,MAAQ7I,EAAE6I,MAEpBG,EAAKhJ,EAAE0F,YACNuD,IAAMD,EAAKD,GAFP/I,EAAEkJ,OAASlJ,EAAE6I,YAGjBM,IAAMH,EAAKD,EAAK/I,EAAEoJ,qBAClBC,IAAML,EAAKD,EAAKA,KAGzBO,QAAA,kBACY7N,KAAK0N,GAAK1N,KAAKwN,IAAMxN,KAAK4N,SAI7BE,wBAKUjH,EAAuBC,EAAwBC,EAAoBgH,YAAAA,IAAAA,GAAoB,aAAvFlH,aAAuBC,WAAwBC,gBAAoBgH,eAHpE,sBACO,OAGhBlH,KAAOA,OACPC,MAAQA,OACRC,IAAMA,OACNgH,SAAWA,qBAGpBC,MAAA,kBACWhO,KAAKiO,cAAgBlJ,OAAO8D,UAC7B7I,KAAK8G,MAAMsG,MAAQpN,KAAK8G,MAAMoH,WAAalO,KAAK+G,IAChD/G,KAAK6G,KAAKuG,MAAQpN,KAAK6G,KAAKqH,iBAI7BC,wBAMUR,EAAgC1D,EAA2BmD,YAA3BnD,IAAAA,EAAiB,YAAUmD,IAAAA,EAAgB,wBAA3EO,cAAgC1D,aAA2BmD,cAL7D,6BAOjBgB,KAAA,kBACW,EAAMpO,KAAKiK,QAAUjK,KAAKkO,WAAalO,KAAK2N,oBAGvDO,SAAA,kBACYlO,KAAKqO,MAAMC,GAAGlB,MAAQpN,KAAKqO,MAAME,KAAOvO,KAAKyN,QAAUzN,KAAKoN,SAIxEoB,gBAAA,SAAgBC,EAAgB/J,OACxBgK,EAAK,SAACrJ,EAAGsJ,UAAStJ,EAAEuJ,QAAUH,IAASE,GAAQjK,EAAEW,EAAGsJ,SACnDE,KAAKzO,SAAQ,SAAAiF,UAAIqJ,EAAGrJ,EAAGA,EAAEyB,eACzBgI,IAAI1O,SAAQ,SAAAiF,UAAIqJ,EAAGrJ,EAAGA,EAAEwB,eAIxBkI,wBAMGxK,aALO,GAMfA,EAAEkJ,OAAS,OACNa,GAAK,IAAInB,EAAc5I,EAAE6I,YACzBC,YAAY9I,8BAGb8I,YAAA,SAAY9I,GAChBA,EAAE8J,MAAQrO,UACLgP,KAAKpP,KAAK2E,QACV+J,GAAGjB,YAAY9I,QACfgK,KAAOvO,KAAKsO,GAAGT,aAIxBoB,uBAAA,gBACSX,GAAGd,GAAKxN,KAAKsO,GAAGZ,GAAK1N,KAAKsO,GAAGV,GAAK,MAClC,IAAI9N,EAAI,EAAGV,EAAIY,KAAKgP,KAAK7O,OAAQL,EAAIV,IAAKU,OACtCwO,GAAGjB,YAAYrN,KAAKgP,KAAKlP,SAC7ByO,KAAOvO,KAAKsO,GAAGT,aAGhBqB,WAAA,SAAW3K,EAAakB,EAAa0J,cACrCf,EAAO7J,EAAE6J,cACb7J,EAAEiK,gBAAgB/I,GAAG,SAACJ,EAAGsJ,OACjBS,EAAQ7O,EAAK2O,WAAWP,EAAMpK,EAAG4K,GACjCR,IAAStJ,EAAEyB,OACXsH,GAAQgB,EAAQ/J,EAAEwB,KAAKuG,MACvB/H,EAAEgK,GAAKD,IAEPhB,GAAQgB,EAAQ/J,EAAEyB,MAAMsG,MACxB/H,EAAEgK,IAAMD,GAEZD,EAAW9J,MAER+I,EAAO7J,EAAE6I,SAGZkC,mBAAA,SAAmB/K,EAAakK,cACpClK,EAAEiK,gBAAgBC,GAAM,SAACpJ,EAAGsJ,GACxBA,EAAKlB,OAASlJ,EAAEkJ,QAAUkB,IAAStJ,EAAEyB,MAAQzB,EAAE0B,KAAO1B,EAAE0B,KACxDlD,EAAKwJ,YAAYsB,GACjB9K,EAAKyL,mBAAmBX,EAAMpK,SAKtCgL,SAAA,SAASC,EAA+BC,EAAYlL,EAA4BkK,uBAA5BlK,IAAAA,EAAcvE,KAAKgP,KAAK,aAAIP,IAAAA,EAAe,MAC3FlK,EAAEiK,gBAAgBC,GAAM,SAACpJ,EAAGsJ,GACxBc,EAAI7P,KAAK4P,EAAMnK,IACfpB,EAAKsL,SAASC,EAAOC,EAAKd,EAAMpK,SAOxCmL,UAAA,eACQvN,EAAgB,iBACf+M,WAAWlP,KAAKgP,KAAK,GAAI,MAAM,SAAA3J,IAC3BA,EAAE0I,WAAmB,OAAN5L,GAAckD,EAAEgK,GAAKlN,EAAEkN,MAAKlN,EAAIkD,MAEjDlD,KAGHwN,iBAAA,SAAiBC,EAAcC,QAC9BX,WAAWU,EAAI,MAAM,mBACtBzN,EAAI,iBACH2N,SAASF,EAAI,KAAMC,GAAI,SAACxK,EAAGsJ,IACvBtJ,EAAE0I,UAAY1I,EAAEyB,QAAU6H,IAAe,OAANxM,GAAckD,EAAEgK,GAAKlN,EAAEkN,MAAKlN,EAAIkD,MAErElD,KAGH2N,SAAA,SAASvL,EAAakK,EAAgBsB,EAAcP,cACpDQ,GAAW,SACfzL,EAAEiK,gBAAgBC,GAAM,SAACpJ,EAAGsJ,GACnBqB,GAAarB,IAASoB,IAAMlD,EAAKiD,SAASnB,EAAMpK,EAAGwL,EAAIP,KAExDQ,GAAW,EACXR,EAAMnK,EAAGsJ,OAGVqB,KAKXC,4BAAA,SAA4BxK,EAAalB,MACjCkB,IAAMlB,EAAG,OAAO,UAChBzE,EAAI2F,EAAEoJ,KAAK1O,OACTL,KAAK,KACHuF,EAAII,EAAEoJ,KAAK/O,MACXuF,EAAEuJ,QAAU5O,KAAKiQ,4BAA4B5K,EAAEyB,MAAOvC,GACtD,OAAO,SAER,KAIJ2L,MAAP,SAAa7K,UAKTA,EAAEuJ,QAAS,EACJ,CAACG,EAAMoB,iBAAiB9K,EAAEwB,MAAOkI,EAAMoB,iBAAiB9K,EAAEyB,WAGtDqJ,iBAAP,SAAwBC,OACxBvO,EAAI,IAAIkN,EAAMqB,UAClBvO,EAAEyN,mBAAmBc,EAAU,MACxBvO,KAIXwO,aAAA,SAAaC,EAAcC,OAKnBlL,EAAIrF,KAAK2P,iBAAiBW,EAAIC,MACxB,OAANlL,EAAY,KACRmL,EAAKzB,EAAMmB,MAAM7K,SACd,CAAEoL,WAAYpL,EAAGqL,GAAIF,EAAG,GAAIG,GAAIH,EAAG,WAGvC,QAGXI,YAAA,SAAY/O,EAAUwD,EAAewL,GACjCxL,EAAEuJ,QAAS,MACN,IAAI9O,EAAI,EAAGV,EAAIyC,EAAEmN,KAAK7O,OAAQL,EAAIV,IAAKU,EAAG,KACvCyE,EAAI1C,EAAEmN,KAAKlP,GACfyE,EAAEkJ,QAAUoD,OACPxD,YAAY9I,QAEhBgK,KAAOvO,KAAKsO,GAAGT,aAGxBiD,KAAA,mBACQC,EAAM,EAAGjR,EAAIE,KAAKgP,KAAK7O,OACpBL,KAAK,KACJyE,EAAIvE,KAAKgP,KAAKlP,GACd0I,EAAIjE,EAAE2J,WAAa3J,EAAEoJ,gBACzBoD,GAAOvI,EAAIA,EAAIjE,EAAE0F,cAEd8G,QAYFC,wBAGUpM,WAAAA,MACXxF,EAAIwF,EAAGzE,gBACN8Q,KAAO,IAAIxR,MAAML,GACfA,KAAK,KACJyC,EAAI,IAAIkN,EAAMnK,EAAGxF,SAChB6R,KAAK7R,GAAKyC,EACfA,EAAEqP,SAAW9R,8BAIrB0R,KAAA,mBACQC,EAAM,EAAGjR,EAAIE,KAAKiR,KAAK9Q,OACpBL,KAAKiR,GAAO/Q,KAAKiR,KAAKnR,GAAGgR,cACzBC,KAGXI,OAAA,SAAOtP,GAIHA,EAAEqP,SAAWlR,KAAKiR,KAAK9Q,YAClB8Q,KAAKrR,KAAKiC,MAOnBa,OAAA,SAAOb,OAKCuP,EAAOpR,KAAKiR,KAAK9Q,OAAS,EAC1BkR,EAAYrR,KAAKiR,KAAKG,QACrBH,KAAK9Q,OAASiR,EACfvP,IAAMwP,SACDJ,KAAKpP,EAAEqP,UAAYG,EACxBA,EAAUH,SAAWrP,EAAEqP,aAS/BvP,MAAA,SAAM0D,OACEU,EAAIV,EAAEwB,KAAKwH,MAAO3D,EAAIrF,EAAEyB,MAAMuH,MAI9BwC,EAAOxL,EAAEyB,MAAM2G,OAASpI,EAAEwB,KAAK4G,OAASpI,EAAE0B,IAC1ChB,EAAEiJ,KAAK7O,OAASuK,EAAEsE,KAAK7O,QACvBuK,EAAEkG,YAAY7K,EAAGV,EAAGwL,QACfnO,OAAOqD,KAEZA,EAAE6K,YAAYlG,EAAGrF,GAAIwL,QAChBnO,OAAOgI,OAQpBtK,QAAA,SAAQsE,QACCuM,KAAK7Q,QAAQsE,MAItB4M,qBAAA,gBACSL,KAAK7Q,SAAQ,SAAAyB,UAAIA,EAAEoN,+BAI5BiB,MAAA,SAAMqB,mBACGD,4BACAL,KAAK7Q,SAAQ,SAAAyB,OACV0C,EAAI1C,EAAE6N,YACA,OAANnL,GAAcA,EAAE8K,GAAKmC,EAAOC,uBAC5B5P,EAAI0C,EAAEsC,KAAKwH,MACXU,EAAMmB,MAAM3L,GAAGnE,SAAQ,SAAAsR,UAAIC,EAAKR,OAAOO,MACvCC,EAAKjP,OAAOb,GACZ0P,EAAS3R,KAAK2E,8BA6BjBiN,wBAOU5M,EAAuBgN,WAAvBhN,UAAuBgN,OACjChN,GAAKA,EACVA,EAAGxE,SAAQ,SAAAmE,GACPA,EAAEuK,IAAM,GAAIvK,EAAEsK,KAAO,WAKpB+C,GAAKA,EACVA,EAAGxR,SAAQ,SAAAiF,GACPA,EAAEwB,KAAKgI,KAAKjP,KAAKyF,GACjBA,EAAEyB,MAAMgI,IAAIlP,KAAKyF,WAKhBkM,SAAWK,EAAGlK,KAAI,SAAArC,UAAMA,EAAEuJ,QAAS,EAAcvJ,UACjDmL,GAAK,gCAGdM,KAAA,kBACW9Q,KAAKwQ,GAAGM,UAKnBe,qBAAA,SAAqBvD,QACZiD,SAAWvR,KAAK4R,GAAGlK,KAAI,SAAArC,UAAMA,EAAEuJ,QAAS,EAAcvJ,UACtDmL,GAAK,IAAIQ,EAAOhR,KAAK4E,SACrB4L,GAAGpQ,SAAQ,SAACyB,EAAG/B,UAAM+B,EAAE0M,KAAOD,EAAGxO,SAG1CgS,oBAAA,SAAoBxD,QACX1J,GAAGxE,SAAQ,SAACmE,EAAGzE,UAAMyE,EAAEoJ,gBAAkBW,EAAGxO,SA4B7CiS,aAAA,mBACAC,EAAWjN,OAAO8D,UAClBtE,EAAgB,KAChBwB,EAAI/F,KAAKuR,SACTnS,EAAI2G,EAAE5F,OACN8R,EAAc7S,EACTU,EAAI,EAAGA,EAAIV,IAAKU,EAAG,KACpBuF,EAAIU,EAAEjG,OACNuF,EAAE4I,mBACFD,EAAQ3I,EAAE2I,YACV3I,EAAE0I,UAAYC,EAAQgE,KACtBA,EAAWhE,EACXzJ,EAAIc,EACJ4M,EAAcnS,EACVuF,EAAE0I,UAAU,cAGpBkE,IAAgB7S,IACf4S,EAAWR,EAAOU,kBAAoB3N,EAAEqK,QAAUrK,EAAEwJ,YAErDhI,EAAEkM,GAAelM,EAAE3G,EAAI,GACvB2G,EAAE5F,OAASf,EAAI,GAEZmF,KAKX4N,QAAA,WACmB,MAAXnS,KAAKwQ,UACAA,GAAK,IAAIQ,EAAOhR,KAAK4E,UAKzB4L,GAAGN,MAAMlQ,KAAKuR,kBACfhN,EAAgB,MACZA,EAAIvE,KAAK+R,kBAAoBxN,EAAEwJ,UAAYxJ,EAAEyJ,QAAUwD,EAAOU,kBAAoB3N,EAAEqK,SAAS,KAC7F8B,EAAKnM,EAAEsC,KAAKwH,SAMZqC,IANwBnM,EAAEuC,MAAMuH,WAO3BmC,GAAG7O,MAAM4C,OACX,IACCmM,EAAGT,4BAA4B1L,EAAEuC,MAAOvC,EAAEsC,MAAO,CAEjDtC,EAAE0J,eAAgB,eAIlBiC,EAAQQ,EAAGL,aAAa9L,EAAEsC,KAAMtC,EAAEuC,UACxB,OAAVoJ,EAKG,CAIH3L,EAAE0J,eAAgB,gBARbuC,GAAGW,OAAOjB,EAAMQ,SAChBF,GAAGW,OAAOjB,EAAMS,SAChBH,GAAG9N,OAAOgO,QACVa,SAAS3R,KAAKsQ,EAAMO,YAQzBlM,EAAEyJ,SAAW,OAKRuD,SAAS3R,KAAK2E,QAKdiM,GAAG7O,MAAM4C,QAe9B6N,MAAA,gBACSD,kBACDE,EAAWtN,OAAO8D,UAAWiI,EAAO9Q,KAAKwQ,GAAGM,OACzC5K,KAAK+E,IAAIoH,EAAWvB,GAAQ,WAC1BqB,UACLE,EAAWvB,EACXA,EAAO9Q,KAAKwQ,GAAGM,cAEZA,eAnKJU,wBAAwB,KACxBA,mBAAmB,WCtUjBc,wCA4BE,SAAUC,WACbC,EAAMxS,KAAKyS,MACXC,EAAO1S,KAAK2S,WAED,OAARH,GAAc,KACbnN,EAAIrF,KAAK4S,YAAYL,EAAMC,EAAID,SACzB,IAANlN,SACAqN,EAAKG,QAAUL,EACRE,EAGPA,EAAKI,WAAWlT,KAAK4S,GACrBA,EAAMA,EAAIO,UAAU1N,EAAI,UAIzB,iCAvCXyC,MAAA,gBACS2K,MAAQ,UACRO,KAAO,KAIhBC,KAAA,SAAKV,WACGC,EAAMxS,KAAKyS,MAEA,OAARD,GAAc,KACbnN,EAAIrF,KAAK4S,YAAYL,EAAMC,EAAID,SACzB,IAANlN,SACOmN,EAAID,KAGXC,EAAMA,EAAIO,UAAU1N,EAAI,UAIzB,QAwBX6N,WAAA,SAAWX,UACAvS,KAAKmT,OAAOZ,EAAMvS,KAAK4S,gBAIlCQ,WAAA,SAAWb,OACHc,EAAMrT,KAAK4S,mBAMR5S,KAAKmT,OAAOZ,YAJE3Q,EAAGC,UACbwR,EAAIxR,EAAGD,SAOtByE,IAAA,eACQmM,EAAMxS,KAAKyS,SACH,OAARD,SACO,UAGS,OAAbA,EAAI3L,MACP2L,EAAMA,EAAI3L,YAGP2L,EAAID,QAIf9H,IAAA,eACQ+H,EAAMxS,KAAKyS,SACH,OAARD,SACO,UAGU,OAAdA,EAAI1L,OACP0L,EAAMA,EAAI1L,aAGP0L,EAAID,QAKfI,SAAA,kBACW,IAAIW,EAAStT,SAIxBuT,KAAA,SAAKC,WACyBjB,EAAtBkB,EAAKzT,KAAK2S,WACgB,QAAtBJ,EAAOkB,EAAG9E,SACd6E,EAAGjB,MAKXmB,MAAA,SAAMF,WACwBjB,EAAtBkB,EAAKzT,KAAK2S,WACgB,QAAtBJ,EAAOkB,EAAGhF,SACd+E,EAAGjB,MAKXY,OAAA,SAAOZ,EAAMc,WACLM,EAAM3T,KAAKyS,MACXC,EAAO1S,KAAK2S,WAED,OAARgB,GAAc,KACbtO,EAAIrF,KAAK4S,YAAYL,EAAMoB,EAAIpB,SACzB,IAANlN,SACAqN,EAAKG,QAAUc,EACRjB,EAEXA,EAAKI,WAAWlT,KAAK+T,GACrBA,EAAMA,EAAIZ,UAAU1N,EAAI,OAGvB,IAAIvF,EAAI4S,EAAKI,WAAW3S,OAAS,EAAGL,GAAK,IAAKA,KAE3CuT,EAAId,GADRoB,EAAMjB,EAAKI,WAAWhT,IACJyS,MAAQ,SACtBG,EAAKG,QAAUc,EACfjB,EAAKI,WAAW3S,OAASL,EAClB4S,SAIfA,EAAKI,WAAW3S,OAAS,EAClBuS,QAGFY,wBAIGM,QACHC,MAAQD,OACRd,WAAa,QACbD,QAAU,gCAGnBN,KAAA,kBAC4B,OAAjBvS,KAAK6S,QAAmB7S,KAAK6S,QAAQN,KAAO,QAKvD5D,KAAA,cACyB,OAAjB3O,KAAK6S,QAAkB,KACnBiB,EAAO9T,KAAK6T,MAAMpB,MACT,OAATqB,QACKC,SAASD,OAGjB,KAIOE,KAHmB,OAAvBhU,KAAK6S,QAAQ/L,QAIV,IACCkN,EAAOhU,KAAK6S,SACR7S,KAAK8S,WAAW3S,OAGf,MACI0S,QAAU,gBAHVA,QAAU7S,KAAK8S,WAAWrL,YAM9BzH,KAAK6S,QAAQ/L,QAAUkN,aAI3BlB,WAAWlT,KAAKI,KAAK6S,cACrBkB,SAAS/T,KAAK6S,QAAQ/L,cAGX,OAAjB9G,KAAK6S,QAAmB7S,KAAK6S,QAAQN,KAAO,QAKvD9D,KAAA,cACyB,OAAjBzO,KAAK6S,QAAkB,KACnBiB,EAAO9T,KAAK6T,MAAMpB,MACT,OAATqB,QACKG,SAASH,OAGjB,KAEOE,KADkB,OAAtBhU,KAAK6S,QAAQhM,OAEV,IACCmN,EAAOhU,KAAK6S,SACR7S,KAAK8S,WAAW3S,OAGf,MACI0S,QAAU,gBAHVA,QAAU7S,KAAK8S,WAAWrL,YAM9BzH,KAAK6S,QAAQhM,OAASmN,aAG1BlB,WAAWlT,KAAKI,KAAK6S,cACrBoB,SAASjU,KAAK6S,QAAQhM,aAGX,OAAjB7G,KAAK6S,QAAmB7S,KAAK6S,QAAQN,KAAO,QAGvDwB,SAAA,SAASG,QACiB,OAAfA,EAAMrN,WACJiM,WAAWlT,KAAKsU,GACrBA,EAAQA,EAAMrN,UAEbgM,QAAUqB,KAGnBD,SAAA,SAASC,QACkB,OAAhBA,EAAMpN,YACJgM,WAAWlT,KAAKsU,GACrBA,EAAQA,EAAMpN,WAEb+L,QAAUqB,QAIjBC,wBAKU5B,QACHA,KAAOA,OACP1L,KAAO,UACPC,MAAQ,UACRsN,KAAM,6BAGfrB,UAAA,SAAUsB,UACCA,EAAMrU,KAAK8G,MAAQ9G,KAAK6G,QAGnCyN,UAAA,SAAUD,EAAKE,GACPF,OACKvN,MAAQyN,OAGR1N,KAAO0N,QAKXC,yBAKGC,sCAEHhC,MAAQ,OACRG,YAAc6B,IACdzB,KAAO,sCAIhB7B,OAAA,SAAOoB,OACCmC,GAAM,KAES,OAAf1U,KAAKyS,WAEAA,MAAQ,IAAI0B,EAAK5B,GACtBmC,GAAM,OACD1B,WAEJ,KACG2B,EAAO,IAAIR,OAAKS,GAEhBP,GAAM,EACNjD,GAAO,EAGPyD,EAAK,KACLC,EAAMH,EACNxJ,EAAI,KACJlK,EAAOjB,KAAKyS,UAChBqC,EAAIhO,MAAQ9G,KAAKyS,QAGJ,IACI,OAATxR,GAEAA,EAAO,IAAIkT,EAAK5B,GAChBpH,EAAEmJ,UAAUD,EAAKpT,GACjByT,GAAM,OACD1B,QAEAwB,EAAOO,OAAO9T,EAAK4F,OAAS2N,EAAOO,OAAO9T,EAAK6F,SAEpD7F,EAAKmT,KAAM,EACXnT,EAAK4F,KAAKuN,KAAM,EAChBnT,EAAK6F,MAAMsN,KAAM,GAIjBI,EAAOO,OAAO9T,IAASuT,EAAOO,OAAO5J,GAAI,KACrC6J,EAAOF,EAAIhO,QAAU+N,EAErB5T,IAASkK,EAAE4H,UAAU3B,GACrB0D,EAAIR,UAAUU,EAAMR,EAAOS,cAAcJ,GAAKzD,IAG9C0D,EAAIR,UAAUU,EAAMR,EAAOU,cAAcL,GAAKzD,QAIlDiC,EAAMrT,KAAK4S,YAAY3R,EAAKsR,KAAMA,MAG1B,IAARc,QAIJjC,EAAOiD,EAII,OAAPQ,IACAC,EAAMD,GAEVA,EAAK1J,EACLA,EAAIlK,EACJA,EAAOA,EAAK8R,UARZsB,EAAMhB,EAAM,QAYXZ,MAAQkC,EAAK7N,kBAIjB2L,MAAM2B,KAAM,EAEVM,KAIXhS,OAAA,SAAO6P,MACgB,OAAfvS,KAAKyS,aACE,MAGPkC,EAAO,IAAIR,OAAKS,GAChB3T,EAAO0T,EACX1T,EAAK6F,MAAQ9G,KAAKyS,cACdtH,EAAI,KACJ0J,EAAK,KACLM,EAAQ,KACRd,GAAM,EAEqB,OAAxBpT,EAAK8R,UAAUsB,IAAe,KAC7BjD,EAAOiD,EAGXQ,EAAK1J,EACLA,EAAIlK,EACJA,EAAOA,EAAK8R,UAAUsB,OAElBhB,EAAMrT,KAAK4S,YAAYL,EAAMtR,EAAKsR,SAEtC8B,EAAMhB,EAAM,EAGA,IAARA,IACA8B,EAAQlU,IAIPuT,EAAOO,OAAO9T,KAAUuT,EAAOO,OAAO9T,EAAK8R,UAAUsB,OAClDG,EAAOO,OAAO9T,EAAK8R,WAAWsB,IAAO,KACjCe,EAAKZ,EAAOS,cAAchU,EAAMoT,GACpClJ,EAAEmJ,UAAUlD,EAAMgE,GAClBjK,EAAIiK,OAEH,IAAKZ,EAAOO,OAAO9T,EAAK8R,WAAWsB,IAAO,KACvCgB,EAAUlK,EAAE4H,WAAW3B,MACX,OAAZiE,KACKb,EAAOO,OAAOM,EAAQtC,WAAW3B,KAAWoD,EAAOO,OAAOM,EAAQtC,UAAU3B,IAM5E,KACG4D,EAAOH,EAAG/N,QAAUqE,EAEpBqJ,EAAOO,OAAOM,EAAQtC,UAAU3B,IAChCyD,EAAGP,UAAUU,EAAMR,EAAOU,cAAc/J,EAAGiG,IAEtCoD,EAAOO,OAAOM,EAAQtC,WAAW3B,KACtCyD,EAAGP,UAAUU,EAAMR,EAAOS,cAAc9J,EAAGiG,QAI3CkE,EAAMT,EAAG9B,UAAUiC,GACvBM,EAAIlB,KAAM,EACVnT,EAAKmT,KAAM,EACXkB,EAAIzO,KAAKuN,KAAM,EACfkB,EAAIxO,MAAMsN,KAAM,OAnBhBjJ,EAAEiJ,KAAM,EACRiB,EAAQjB,KAAM,EACdnT,EAAKmT,KAAM,UAyBjB,OAAVe,IACAA,EAAM5C,KAAOtR,EAAKsR,KAClBpH,EAAEmJ,UAAUnJ,EAAErE,QAAU7F,EAAMA,EAAK8R,UAAwB,OAAd9R,EAAK4F,YAC7CmM,aAIJP,MAAQkC,EAAK7N,MACC,OAAf9G,KAAKyS,aACAA,MAAM2B,KAAM,GAGJ,OAAVe,KAGJJ,OAAP,SAAc9T,UACM,OAATA,GAAiBA,EAAKmT,OAG1Ba,cAAP,SAAqBnB,EAAMO,OACnBL,EAAOF,EAAKf,WAAWsB,UAE3BP,EAAKQ,WAAWD,EAAKL,EAAKjB,UAAUsB,IACpCL,EAAKM,UAAUD,EAAKP,GAEpBA,EAAKM,KAAM,EACXJ,EAAKI,KAAM,EAEJJ,KAGJkB,cAAP,SAAqBpB,EAAMO,UACvBP,EAAKQ,WAAWD,EAAKG,EAAOS,cAAcnB,EAAKf,WAAWsB,IAAOA,IAC1DG,EAAOS,cAAcnB,EAAMO,OAnMX/B,YC3QfiD,EAAmB/R,UAC/BA,EAAEgS,YAA6B,IAAbhS,EAAExC,OAChBwC,EAAExC,OAAOyU,QAAO,SAAC/K,EAAcrF,UAAMA,EAAEmQ,OAAOE,MAAMhL,KAAIiL,EAAUC,SAClED,EAAUC,aACU,IAAbpS,EAAEpC,SACToC,EAAEgS,OAAoBhS,EAAEpC,OAAOqU,QAAO,SAAC/K,EAAcrF,UAAMkQ,EAAmBlQ,GAAGqQ,MAAMhL,KAAIlH,EAAEgS,SACjGhS,EAAEgS,OAAShS,EAAEgS,OAAOK,QAAQrS,EAAEsS,SACvBtS,EAAEgS,WAGAG,wBAEE/N,EACAmO,EACAC,EACAC,UAHArO,SACAmO,SACAC,SACAC,IAEJL,MAAP,kBAAmC,IAAID,EAAU5Q,OAAOmR,kBAAmBnR,OAAOoR,kBAAmBpR,OAAOmR,kBAAmBnR,OAAOoR,+CAEtIC,GAAA,kBAAuBpW,KAAK4H,EAAI5H,KAAK+V,GAAK,KAE1CM,GAAA,kBAAuBrW,KAAKgW,EAAIhW,KAAKiW,GAAK,KAE1CK,SAAA,SAAS5L,OACD6L,EAAKvW,KAAKoW,KAAMI,EAAK9L,EAAE0L,YACvBG,GAAMC,GAAM9L,EAAE9C,EAAI5H,KAAK+V,EAAU/V,KAAK+V,EAAIrL,EAAE9C,EAC5C4O,GAAMD,GAAMvW,KAAK4H,EAAI8C,EAAEqL,EAAUrL,EAAEqL,EAAI/V,KAAK4H,EACzC,KAGX6O,SAAA,SAAS/L,OACDgM,EAAK1W,KAAKqW,KAAMM,EAAKjM,EAAE2L,YACvBK,GAAMC,GAAMjM,EAAEsL,EAAIhW,KAAKiW,EAAUjW,KAAKiW,EAAIvL,EAAEsL,EAC5CW,GAAMD,GAAM1W,KAAKgW,EAAItL,EAAEuL,EAAUvL,EAAEuL,EAAIjW,KAAKgW,EACzC,KAGXY,WAAA,SAAWR,OACHrN,EAAKqN,EAAKpW,KAAKoW,UACdxO,GAAKmB,OACLgN,GAAKhN,KAGd8N,WAAA,SAAWR,OACHS,EAAKT,EAAKrW,KAAKqW,UACdL,GAAKc,OACLb,GAAKa,KAGd7N,MAAA,kBACWjJ,KAAK+V,EAAI/V,KAAK4H,KAGzBsB,OAAA,kBACWlJ,KAAKiW,EAAIjW,KAAKgW,KAGzBN,MAAA,SAAMhL,UACK,IAAIiL,EAAUzP,KAAKG,IAAIrG,KAAK4H,EAAG8C,EAAE9C,GAAI1B,KAAKuE,IAAIzK,KAAK+V,EAAGrL,EAAEqL,GAAI7P,KAAKG,IAAIrG,KAAKgW,EAAGtL,EAAEsL,GAAI9P,KAAKuE,IAAIzK,KAAKiW,EAAGvL,EAAEuL,OAYjHc,kBAAA,SAAkBC,EAAYC,EAAYC,EAAYC,WAC9CC,EAAQ,CAAC,CAACpX,KAAK4H,EAAG5H,KAAKgW,EAAGhW,KAAK+V,EAAG/V,KAAKgW,GACnC,CAAChW,KAAK+V,EAAG/V,KAAKgW,EAAGhW,KAAK+V,EAAG/V,KAAKiW,GAC9B,CAACjW,KAAK+V,EAAG/V,KAAKiW,EAAGjW,KAAK4H,EAAG5H,KAAKiW,GAClC,CAACjW,KAAK4H,EAAG5H,KAAKiW,EAAGjW,KAAK4H,EAAG5H,KAAKgW,IAC9BqB,EAAgB,GACXvX,EAAI,EAAGA,EAAI,IAAKA,EAAG,KACpB4K,EAAIiL,EAAU2B,iBAAiBN,EAAIC,EAAIC,EAAIC,EAAIC,EAAMtX,GAAG,GAAIsX,EAAMtX,GAAG,GAAIsX,EAAMtX,GAAG,GAAIsX,EAAMtX,GAAG,IACzF,OAAN4K,GAAY2M,EAAczX,KAAK,CAAEgI,EAAG8C,EAAE9C,EAAGoO,EAAGtL,EAAEsL,WAE/CqB,KAWXE,gBAAA,SAAgBL,EAAYC,OACpBK,EAAOxX,KAAK+W,kBAAkB/W,KAAKoW,KAAMpW,KAAKqW,KAAMa,EAAIC,UACrDK,EAAKrX,OAAS,EAAIqX,EAAK,GAAK,QAGvCC,SAAA,iBACW,CACH,CAAE7P,EAAG5H,KAAK4H,EAAGoO,EAAGhW,KAAKgW,GACrB,CAAEpO,EAAG5H,KAAK+V,EAAGC,EAAGhW,KAAKgW,GACrB,CAAEpO,EAAG5H,KAAK+V,EAAGC,EAAGhW,KAAKiW,GACrB,CAAErO,EAAG5H,KAAK4H,EAAGoO,EAAGhW,KAAKiW,OAGtBqB,iBAAP,SACIN,EAAYC,EACZC,EAAYC,EACZO,EAAYC,EACZC,EAAYC,OACRC,EAAOZ,EAAKF,EAAIe,EAAOH,EAAKF,EAC5BM,EAAOb,EAAKF,EAAIgB,EAAOJ,EAAKF,EAC5BnM,EAAcyM,EAAOH,EAAOC,EAAOC,KACpB,GAAfxM,EAAkB,OAAO,SACzB0M,EAAOlB,EAAKU,EAAIS,EAAOlB,EAAKU,EAE5B/V,GADOmW,EAAOI,EAAOF,EAAOC,GACjB1M,EAEX3J,GADOiW,EAAOK,EAAOH,EAAOE,GACjB1M,SACX5J,GAAK,GAAKA,GAAK,GAAKC,GAAK,GAAKA,GAAK,EAC5B,CACH+F,EAAGoP,EAAKpV,EAAIkW,EACZ9B,EAAGiB,EAAKrV,EAAIoW,GAGb,QAGXnC,QAAA,SAAQuC,UACG,IAAIzC,EAAU3V,KAAK4H,EAAIwQ,EAAKpY,KAAK+V,EAAIqC,EAAKpY,KAAKgW,EAAIoC,EAAKpY,KAAKiW,EAAImC,kBAehEC,EAAgBrZ,EAAmBC,EAAmBqZ,OAE5DC,EAAKvZ,EAAOuY,gBAAgBtY,EAAOmX,KAAMnX,EAAOoX,OAAS,CAAEzO,EAAG5I,EAAOoX,KAAMJ,EAAGhX,EAAOqX,MACvFmC,EAAKvZ,EAAOsY,gBAAgBvY,EAAOoX,KAAMpX,EAAOqX,OAAS,CAAEzO,EAAG3I,EAAOmX,KAAMJ,EAAG/W,EAAOoX,MACrFtN,EAAKyP,EAAG5Q,EAAI2Q,EAAG3Q,EACfkP,EAAK0B,EAAGxC,EAAIuC,EAAGvC,EACfjQ,EAAIG,KAAKC,KAAK4C,EAAKA,EAAK+N,EAAKA,GAAK2B,EAAK1S,EAAIuS,QACxC,CACHI,mBAAoBH,EACpBI,mBAAoBH,EACpBI,WAAY,CAAEhR,EAAG2Q,EAAG3Q,EAAI6Q,EAAK1P,EAAKhD,EAAGiQ,EAAGuC,EAAGvC,EAAIyC,EAAK3B,EAAK/Q,aAajD8S,EAAWvY,EAA6BrB,EAAmBqZ,OACnEE,EAAKvZ,EAAOsY,gBAAgBjX,EAAEsH,EAAGtH,EAAE0V,GAClCwC,IAAIA,EAAK,CAAE5Q,EAAG3I,EAAOmX,KAAMJ,EAAG/W,EAAOoX,WACtCtN,EAAKyP,EAAG5Q,EAAItH,EAAEsH,EACdkP,EAAK0B,EAAGxC,EAAI1V,EAAE0V,EACdjQ,EAAIG,KAAKC,KAAK4C,EAAKA,EAAK+N,EAAKA,SAC1B,CAAElP,EAAG4Q,EAAG5Q,EAAI0Q,EAAKvP,EAAKhD,EAAGiQ,EAAGwC,EAAGxC,EAAIsC,EAAKxB,EAAK/Q,OAGlDoO,EAIF,SAAmB5P,EAAoBmG,EAAqBoO,UAAzCvU,SAAoBmG,WAAqBoO,OACnDrK,KAAOsK,SACPpK,KAAOoK,KAIdC,EACF,SAAmBC,EAAwB1U,EAAgBuU,eAAxCG,SAAwB1U,WAAgBuU,GAG/D,SAASI,EAActX,EAAUC,UACzBD,EAAEkX,IAAMjX,EAAEiX,IACH,EAEPlX,EAAEkX,IAAMjX,EAAEiX,KAGVlX,EAAEqX,QAFM,EAMRpX,EAAEoX,OAEK,EAEJ,EAGX,SAASF,WACE,IAAIvE,GAAa,SAAC5S,EAAGC,UAAMD,EAAEkX,IAAMjX,EAAEiX,OAYhD,IAAIK,EAAuB,CACvBC,UAAW,SAAA1O,UAAIA,EAAE0L,MACjBiD,QAAS,SAAA3O,UAAIA,EAAEsL,GACfsD,SAAU,SAAA5O,UAAIA,EAAEuL,GAChBsD,QAAS,SAAA7O,UAAIA,EAAEzB,SACfuQ,SAAU,SAACC,EAAMC,EAAOC,EAAQ3G,UAAS,IAAI2C,EAAUgE,EAAS3G,EAAO,EAAG2G,EAAS3G,EAAO,EAAGyG,EAAMC,IACnGE,eAiGJ,SAAyBrV,EAASsV,OAC1BnV,EAAI,SAACoV,EAASC,WAEVtU,EADAgO,EAAKoG,EAASG,SAASzV,GAEI,QAAvBkB,EAAIgO,EAAGqG,OAAsB,KAC7BG,EAAUxU,EAAEiF,EAAE4L,SAAS/R,EAAEmG,OACzBuP,GAAW,GAAKA,GAAWxU,EAAEiF,EAAE+L,SAASlS,EAAEmG,MAC1CnG,EAAEuV,GAAS3I,OAAO1L,GAClBA,EAAEsU,GAAS5I,OAAO5M,IAElB0V,GAAW,UAKvBvV,EAAE,OAAQ,QACVA,EAAE,OAAQ,UA9GVwV,EAAuB,CACvBd,UAAW,SAAA1O,UAAIA,EAAE2L,MACjBgD,QAAS,SAAA3O,UAAIA,EAAE9C,GACf0R,SAAU,SAAA5O,UAAIA,EAAEqL,GAChBwD,QAAS,SAAA7O,UAAIA,EAAExB,UACfsQ,SAAU,SAACC,EAAMC,EAAOC,EAAQ3G,UAAS,IAAI2C,EAAU8D,EAAMC,EAAOC,EAAS3G,EAAO,EAAG2G,EAAS3G,EAAO,IACvG4G,eA2GJ,SAAyBrV,EAASsV,OAC1BnV,EAAI,SAACoV,EAASC,OACVtU,EAAIoU,EAASG,SAASzV,GAAGuV,KACnB,OAANrU,GAAcA,EAAEiF,EAAE4L,SAAS/R,EAAEmG,GAAK,IAClCnG,EAAEuV,GAAS3I,OAAO1L,GAClBA,EAAEsU,GAAS5I,OAAO5M,KAG1BG,EAAE,OAAQ,QACVA,EAAE,OAAQ,UAjHd,SAASyV,EAAyBrG,EAAuBpP,EAAkB0V,EAAgBC,YAAAA,IAAAA,GAAuB,OAE1GvE,EAAUhC,EAAKgC,QACfwE,OAA4B,IAAhBxG,EAAK1S,OAAyB0S,EAAK1S,OAAOjB,OAAS,EAC/Doa,OAA4B,IAAhBzG,EAAK9S,OAAyB8S,EAAK9S,OAAOb,OAAS,EAC/Dqa,EAAkCF,EAChCxG,EAAK1S,OAAOqU,QAAO,SAACgF,EAAmBjX,UAAMiX,EAAIC,OAAOP,EAAyB3W,EAAGkB,EAAG0V,GAAQ,MAAQ,IADlE,GAEvChb,GAAKib,EAAc,EAAI,GAAKE,EAAKD,EACjC1V,EAAiB,IAAInF,MAAML,GAC3ByD,EAAkB,IAAIpD,MAAML,GAC5BU,EAAI,EACJC,EAAM,SAAC2K,EAAGnG,GAAQ1B,EAAG/C,GAAK4K,EAAG9F,EAAG9E,KAAOyE,MACvC8V,EAAa,KAETxY,EAAeiS,EAAK0B,OACpBnQ,EAAIX,EAAE0U,UAAUvX,GAAIvB,EAAIoE,EAAE6U,QAAQ1X,GAAK,EACvC4X,EAAO/U,EAAE2U,QAAQxX,GAAI6X,EAAQhV,EAAE4U,SAASzX,GACxCwE,EAAMhB,EAAI/E,EAAIwV,EAAU,EAAGrL,EAAMpF,EAAI/E,EAAIwV,EAAU,EACvDhC,EAAK6G,OAAOhN,gBAAkBtH,EAC9BtG,EAAI2E,EAAE8U,SAASC,EAAMC,EAAOrT,EAAKyP,GAAUhC,EAAK6G,QAChD7G,EAAK8G,OAAOjN,gBAAkBlD,EAC9B1K,EAAI2E,EAAE8U,SAASC,EAAMC,EAAOjP,EAAKqL,GAAUhC,EAAK8G,QAEhDL,GAAIzG,EAAK9S,OAAOZ,SAAQ,SAAA2F,UAAKhG,EAAIgG,EAAEyP,OAAQzP,EAAE8U,aAC7CP,GAAIxG,EAAK1S,OAAOhB,SAAQ,SAAAoD,OACpB3B,EAAe2B,EAAEgS,OACrBzV,EAAI2E,EAAE8U,SAAS9U,EAAE2U,QAAQxX,GAAI6C,EAAE4U,SAASzX,GAAI6C,EAAE0U,UAAUvX,GAAI6C,EAAE6U,QAAQ1X,IAAK2B,EAAEmX,eAE7E/I,EAAKkJ,EAAoBjY,EAAI+B,EAAIF,EAAG0V,UACpCE,IACA1V,EAAGxE,SAAQ,SAAAmE,GAAOA,EAAEsK,KAAO,GAAItK,EAAEuK,IAAM,MACvC8C,EAAGxR,SAAQ,SAAAiF,GAAOA,EAAEwB,KAAKgI,KAAKjP,KAAKyF,GAAIA,EAAEyB,MAAMgI,IAAIlP,KAAKyF,MACxDyO,EAAK1S,OAAOhB,SAAQ,SAAAoD,OACZuX,GAAiBvX,EAAEsS,QAAUpR,EAAE6U,QAAQ/V,EAAEgS,SAAW,EACxDhS,EAAEmX,OAAO7L,IAAI1O,SAAQ,SAAAiF,UAAKA,EAAE0B,KAAOgU,KACnCvX,EAAEmX,OAAO9L,KAAKzO,SAAQ,SAAAiF,GAAOA,EAAEwB,KAAOrD,EAAEoX,OAAQvV,EAAE0B,KAAOgU,SAG1DP,EAAiBE,OAAO9I,GAGnC,SAASkJ,EAAoBjY,EAAiBmM,EAC1CgM,EAAqBZ,OAEjBta,EAAGV,EAAIyD,EAAG1C,OACV8a,EAAI,EAAI7b,EACZmL,QAAQ2Q,OAAOlM,EAAK7O,QAAUf,OAC1B+b,EAAS,IAAI1b,MAAawb,OACzBnb,EAAI,EAAGA,EAAIV,IAAKU,EAAG,KAChB4K,EAAI7H,EAAG/C,GACPyE,EAAI,IAAI4P,EAAKnF,EAAKlP,GAAI4K,EAAGsQ,EAAK5B,UAAU1O,IAC5CyQ,EAAOrb,GAAK,IAAIkZ,GAAM,EAAMzU,EAAGyW,EAAK3B,QAAQ3O,IAC5CyQ,EAAOrb,EAAIV,GAAK,IAAI4Z,GAAM,EAAOzU,EAAGyW,EAAK1B,SAAS5O,IAEtDyQ,EAAOhY,KAAK+V,OACRtH,EAAK,IAAInS,MACToa,EAAWd,QACVjZ,EAAI,EAAGA,EAAImb,IAAKnb,EAAG,KAChBO,EAAI8a,EAAOrb,MACXyE,EAAIlE,EAAEkE,EACNlE,EAAE4Y,OACFY,EAAS1I,OAAO5M,GAChByW,EAAKpB,eAAerV,EAAGsV,OACpB,CAEHA,EAASnX,OAAO6B,OACZ6W,EAAiB,SAACrV,EAAG2E,OACjB2Q,GAAOL,EAAKzB,QAAQxT,EAAE2E,GAAKsQ,EAAKzB,QAAQ7O,EAAEA,IAAM,EAAI0P,EACxDxI,EAAGhS,KAAK,IAAIkO,EAAW/H,EAAExB,EAAGmG,EAAEnG,EAAG8W,KAEjC7M,EAAkB,SAACsL,EAASC,EAASuB,WACjC7V,EAAGgO,EAAKlP,EAAEuV,GAASnH,WACQ,QAAvBlN,EAAIgO,EAAGqG,OACXwB,EAAM7V,EAAGlB,GACTkB,EAAEsU,GAASrX,OAAO6B,IAG1BiK,EAAgB,OAAQ,QAAQ,SAAC/I,EAAGlB,UAAM6W,EAAe3V,EAAGlB,MAC5DiK,EAAgB,OAAQ,QAAQ,SAAC/I,EAAGlB,UAAM6W,EAAe7W,EAAGkB,cAGpE8E,QAAQ2Q,OAAyB,IAAlBrB,EAAS7G,MACjBpB,WAkCK2J,EAAqB1Y,EAAiBmM,UAC3C8L,EAAoBjY,EAAImM,EAAMmK,EAAO,eAGhCqC,EAAqB3Y,EAAiBmM,UAC3C8L,EAAoBjY,EAAImM,EAAMkL,EAAO,eAGhCuB,EAA0B3H,UAC/BqG,EAAyBrG,EAAMqF,EAAO,eAGjCuC,EAA0B5H,UAC/BqG,EAAyBrG,EAAMoG,EAAO,UA2BpCyB,yBACUzU,EAAevB,8BACxB,EAAGA,gBADMuB,qBADciH,GAMxByN,wBAKW1W,EACR9D,EACA7B,EACRmH,EACQmV,0BAFAtc,IAAAA,EAA6B,eACrCmH,IAAAA,EAAoB,eACZmV,IAAAA,GAAyB,cAJjB3W,cACR9D,iBACA7B,qBAEAsc,OAEHC,UAAY5W,EAAMwC,KAAI,SAACnD,EAAGzE,UACpByE,EAAEsW,SAAW,IAAIc,EAAgB7b,EAAG,MAG3C4G,GAAa1G,KAAK+b,kBAAkBrV,GAEpCmV,GAAiBtc,QAAyC,IAArBA,EAAU6B,OAAwB,CACvE8D,EAAM9E,SAAQ,SAAAmE,MACpBA,EAAE0E,OAAU1E,EAAE2E,YAMA8S,EAAKzX,EAAE0E,MAAQ,EAAGgT,EAAK1X,EAAE2E,OAAS,EACtC3E,EAAEiR,OAAS,IAAIG,EAAUpR,EAAEqD,EAAIoU,EAAIzX,EAAEqD,EAAIoU,EAAIzX,EAAEyR,EAAIiG,EAAI1X,EAAEyR,EAAIiG,QAJ3E1X,EAAEiR,OAAS,IAAIG,EAAUpR,EAAEqD,EAAGrD,EAAEqD,EAAGrD,EAAEyR,EAAGzR,EAAEyR,MAMhCT,EAAmBhW,OACfO,EAAIoF,EAAM/E,OACdiB,EAAOhB,SAAQ,SAAAoD,GACXK,EAAKiY,UAAUhc,GAAK0D,EAAEmX,OAAS,IAAIgB,EAAgB7b,SAA4B,IAAhB0D,EAAE0Y,UAA4B1Y,EAAE0Y,UAAY,KAC3GrY,EAAKiY,UAAUhc,GAAK0D,EAAEoX,OAAS,IAAIe,EAAgB7b,SAA4B,IAAhB0D,EAAE0Y,UAA4B1Y,EAAE0Y,UAAY,oCAM/GC,iBAAA,SAAiB9W,UACd,IAAIyI,EACP9N,KAAKkF,MAAMG,EAAEwB,MAAMgU,SACnB7a,KAAKkF,MAAMG,EAAEyB,OAAO+T,SACpBxV,EAAE0B,SACoB,IAAf1B,EAAE0I,UAA2B1I,EAAE0I,aAItCqO,aAAA,SAAa/W,iBACZrF,KAAK6b,mBAENtV,EAAO,IAAK8V,EAAM,QACP,MAAXhX,EAAEkB,OAAcA,EAAO,IAAK8V,EAAM,cAClCzX,EAAkBS,EAAEiX,QAAQ5U,KAAI,SAAArF,UAAK4B,EAAKiB,MAAM7C,EAAEpB,SAAOkC,MAAK,SAACvB,EAAGC,UAAMD,EAAE2E,GAAQ1E,EAAE0E,MACpF4E,EAAe,KACnBvG,EAAGxE,SAAQ,SAAAmE,MAEH4G,EAAG,KACCoR,EAAUpR,EAAE5E,GAAQ4E,EAAEkR,GACtBE,EAAUhY,EAAEgC,KACZhC,EAAEgC,GAAQgW,GAGlBpR,EAAI5G,SAIJiY,gBAAA,SAAgBnX,cAChBI,EAAIzF,KAAKkF,MAAMG,EAAEiX,QAAQ,GAAGrb,MAAM4Z,cACjCuB,aAAa/W,OACduM,EAAgB,MAAXvM,EAAEkB,KAAevG,KAAKyc,aAAezc,KAAK0c,aACnDrX,EAAEiX,QAAQK,MAAM,GAAGvc,SAAQ,SAAAiC,GAEvBuP,EAAGhS,KAAK,IAAIkO,EAAWrI,EADfoH,EAAK3H,MAAM7C,EAAEpB,MAAM4Z,SACExY,EAAEoL,QAAQ,UAIvCsO,kBAAA,SAAkBrV,cAClBkW,EAAQ,SAAAvX,eAAuB,IAAXA,EAAEnG,MAAmC,eAAXmG,EAAEnG,WAC/Cud,aAAe/V,EACfmW,QAAO,SAAAxX,SAAgB,MAAXA,EAAEkB,MAAgBqW,EAAMvX,MACpCqC,KAAI,SAAArC,UAAKsM,EAAKwK,iBAAiB9W,WAC/BqX,aAAehW,EACfmW,QAAO,SAAAxX,SAAgB,MAAXA,EAAEkB,MAAgBqW,EAAMvX,MACpCqC,KAAI,SAAArC,UAAKsM,EAAKwK,iBAAiB9W,MACpCqB,EACKmW,QAAO,SAAAxX,SAAgB,cAAXA,EAAEnG,QACdkB,SAAQ,SAAAiF,UAAKsM,EAAK6K,gBAAgBnX,SAGnCyX,wBAAA,SAAwB/Q,EAAcgR,EAAcC,EAAmBC,QACtE/X,MAAM9E,SAAQ,SAACmE,EAAGzE,GACfyE,EAAE2Y,OACF3Y,EAAEsW,SAAS5Q,OAAS1F,EAAE4Y,YAAc5Y,EAAE4Y,YAAc,IACpDH,EAAQld,GAAKmd,EAAW1Y,IAExBA,EAAEsW,SAAS5Q,OAAS,MAEpBtE,GAAKpB,EAAE0E,OAAS,GAAK,EAAGmU,GAAK7Y,EAAE2E,QAAU,GAAK,EAC9CmU,EAAKtR,EAAGjM,GAAIwd,EAAKP,EAAGjd,GACxByE,EAAEiR,OAAS,IAAIG,EAAU0H,EAAK1X,EAAG0X,EAAK1X,EAAG2X,EAAKF,EAAGE,EAAKF,SAI9DG,SAAA,SAASxR,EAAcgR,EAAcnV,IAC5B5H,KAAKT,WAAeS,KAAK6b,eAAiB7b,KAAKyc,oBAC/CxQ,QAAQF,EAAIgR,EAAIhR,EAAInE,GAAG,SAAArD,UAAIA,EAAEiZ,KAAIxd,KAAKyc,aAAchB,GACrD,SAAAlX,UAAKA,EAAEiR,OAAOoB,WAAWhP,EAAoBrD,EAAEsW,SAAU3T,OAAS3C,EAAEsW,SAAS3M,eAC7E,SAAA1K,OACQia,EAAO7V,EAAoBpE,EAAEmX,OAAQzT,OAAS1D,EAAEmX,OAAOzM,WACvDwP,EAAO9V,EAAoBpE,EAAEoX,OAAQ1T,OAAS1D,EAAEoX,OAAO1M,WACvDyP,EAAKna,EAAEsS,QAAU,EACrBtS,EAAEgS,OAAO5N,EAAI6V,EAAOE,EACpBna,EAAEgS,OAAOO,EAAI2H,EAAOC,QAIhCC,SAAA,SAAS7R,EAAcgR,EAAc/G,IAC5BhW,KAAKT,WAAcS,KAAK0c,oBACxBzQ,QAAQF,EAAIgR,EAAIA,EAAI/G,GAAG,SAAAzR,UAAIA,EAAEsZ,KAAI7d,KAAK0c,aAAchB,GACrD,SAAAnX,UAAKA,EAAEiR,OAAOqB,WAAWb,EAAoBzR,EAAEsW,SAAU3T,OAAS3C,EAAEsW,SAAS3M,eAC7E,SAAA1K,OACQsa,EAAO9H,EAAoBxS,EAAEmX,OAAQzT,OAAS1D,EAAEmX,OAAOzM,WACvD6P,EAAO/H,EAAoBxS,EAAEoX,OAAQ1T,OAAS1D,EAAEoX,OAAO1M,WACvDyP,EAAKna,EAAEsS,QAAU,EACrBtS,EAAEgS,OAAOQ,EAAI8H,EAAOH,EACpBna,EAAEgS,OAAOS,EAAI8H,EAAOJ,QAIhCK,iBAAA,4BACW,CACH,SAACjS,EAAIgR,EAAInV,UAAMqW,EAAKV,SAASxR,EAAIgR,EAAInV,IACrC,SAACmE,EAAIgR,EAAI/G,UAAMiI,EAAKL,SAAS7R,EAAIgR,EAAI/G,QAIrC/J,QAAA,SAAQF,EAAcgR,EAAc7I,EAAiB8I,EACzDC,EACArL,EACAkJ,EACAoD,EACAC,QAEKrB,wBAAwB/Q,EAAIgR,EAAIC,EAASC,GAC1Cjd,KAAKT,WAAaS,KAAK6b,gBACvBtG,EAAmBvV,KAAKT,WACxBqS,EAAKA,EAAG8I,OAAOI,EAAoB9a,KAAKT,kBAEvC6S,MAAMpS,KAAK8b,UAAWlK,EAAIsC,EAAO8I,QACjC9X,MAAM9E,QAAQ8d,GACfle,KAAKT,WAAaS,KAAK6b,qBAClBza,OAAOhB,QAAQ+d,GACpB5I,EAAmBvV,KAAKT,eAIxB6S,MAAA,SAAMxN,EAAgBgN,EAAkBwM,EAAoBpB,OAC5DqB,EAAS,IAAI7M,EAAO5M,EAAIgN,GAC5ByM,EAAOxM,qBAAqBuM,GAC5BC,EAAOvM,oBAAoBkL,GAC3BqB,EAAOjM,cClkBNkM,wBAIUC,aAAAA,OACVC,SAAW,8BAGbC,SAAA,SAASC,WACRC,EAAM,GAAIC,GAAY,EACjB9e,EAAI,EAAGA,EAAIE,KAAKwe,SAASre,SAAUL,EAAG,KACvC+e,EAA0B7e,KAAKwe,SAAS1e,GACvC+e,EAAQN,MAITK,IACAD,GAAY,KAEhBA,GAAYE,EAAQJ,SAASC,GAC7BE,GAAY,GAPRA,GAAY,QASR,KAARD,IACAA,EAAM,IAAMA,EAAM,MAEd3e,KAAKue,KAAOG,EAAS1e,KAAKue,MAAQ,IAAMI,KAG7Cve,QAAA,SAAQsE,GACN1E,KAAK4V,UACNlR,EAAE1E,KAAKue,KAAMve,WACRwe,SAASpe,SAAQ,SAAAE,UAAKA,EAAEF,QAAQsE,UAItC/B,MAAA,kBACI3C,KAAK4V,QAAU,EAAI,EAAI5V,KAAKwe,SAAS/I,QAAO,SAACrW,EAAWge,UACpDhe,EAAIge,EAAEza,UACd,MAGA0D,IAAA,kBACIrG,KAAKue,QAGT3I,MAAA,kBACiB,MAAb5V,KAAKue,QAGT9Z,SAAA,SAAS2Y,MACRpd,OAASod,EAAG,OAAO,MAClB,IAAItd,EAAI,EAAGA,EAAIE,KAAKwe,SAASre,OAAQL,OAClCE,KAAKwe,SAAS1e,GAAG2E,SAAS2Y,GAAI,OAAO,SAEtC,KAGJ0B,OAAA,SAAOC,qBACH/e,KAAKwe,SAASQ,OAAM,SAAA5B,UAAI2B,EAASxe,EAAKge,KAAMnB,EAAEmB,OAASnB,EAAE0B,OAAOC,SAGpE5N,OAAA,SAAO8N,EAASF,UACZ/e,KAAK2B,MAAM,IAAI2c,EAAeW,GAAMF,MAGxCpd,MAAA,SAAMud,EAAuBH,UAC5B/e,KAAK4V,QAAgBsJ,EAChBA,EAAMtJ,QAAgB5V,KACtB+e,EAAS/e,KAAKue,KAAMW,EAAMX,YAC1BC,SAAS5e,KAAKsf,GACZlf,OAEPkf,EAAMV,SAAS5e,KAAKI,MACbkf,MAIRC,UAAA,SAAUJ,UACT/e,KAAK4V,QAAgB,KACb5V,KAAKof,WAAWL,MAGzBK,WAAA,SAAWL,MACc,GAAxB/e,KAAKwe,SAASre,OAAa,OAAO,IAAIme,EAAe,MACpD,GAA4B,GAAxBte,KAAKwe,SAASre,cAAsBH,KAAKwe,SAAS,OAEnDa,EAAYrf,KAAKwe,SAAS/W,MAAM9F,MAAM3B,KAAKwe,SAAS/W,MAAOsX,GAC3DO,EAAYtf,KAAKof,WAAWL,UACzBM,EAAU1d,MAAM2d,EAAWP,MAGnCQ,YAAA,SAAYV,EAAyBW,EAAaC,EAA8CV,OAC/FW,EAAUb,EAAQM,UAAUJ,GAEhCF,EAAQN,KAAOmB,EAAQnB,KACvBM,EAAQL,SAAWkB,EAAQlB,SACP,OAAhBiB,GAAyC,OAAjBC,EAAQnB,MAChCkB,EAAYZ,EAAQN,KAAMM,OAE1Bc,EAAc,IAAIrB,EAAYkB,UACd,OAAhBC,GACAA,EAAYD,EAAUG,GAEnB3f,KAAK2B,MAAMge,EAAaZ,SAO1Ba,wBAEWb,iBAAAA,6BAKbc,IAAA,kBACC7f,KAAK4V,QAAkB,KACpB5V,KAAK8T,KAAKyK,QAMd3e,KAAA,mBACC+f,EACYG,EAAPhgB,EAAI,EAAQggB,EAAShgB,uBAAAA,mBAAAA,KAAMA,EAChC6f,EAAc,IAAIrB,EAAYwB,QACzBhM,KAAO9T,KAAK4V,QACb+J,EAAc3f,KAAK8T,KAAKnS,MAAMge,EAAa3f,KAAK+e,iBAEjDY,KAMJ/J,MAAA,kBACK5V,KAAK8T,OAAS9T,KAAK8T,KAAKyK,QAM7BO,OAAA,kBACI9e,KAAK8T,KAAKgL,OAAO9e,KAAK+e,aAM1B3e,QAAA,SAAQsE,QACNoP,KAAK1T,QAAQsE,MAKf+C,IAAA,cACCzH,KAAK4V,eACE,SAEPqJ,EAAMjf,KAAK8T,KAAKzN,kBACfyN,KAAO9T,KAAK8T,KAAKqL,UAAUnf,KAAK+e,UAC9BE,KAKJc,UAAA,SAAUC,EAA0BC,EAAWR,YAAAA,IAAAA,EAA+C,WAC5F3L,KAAO9T,KAAK8T,KAAKyL,YAAYS,EAAUC,EAAQR,EAAazf,KAAK+e,aAEnEN,SAAA,SAASC,UACL1e,KAAK8T,KAAK2K,SAASC,MAMvB/b,MAAA,kBACI3C,KAAK8T,KAAKnR,cCnLnBud,EACF,SAAmB/e,EAAmB4I,WAAnB5I,gBAAmB4I,GAGpCoK,EACF,SAAmBhT,WAAAA,OACVyE,WAAa,IAQpBua,EACF,SAAmBlf,EAAmBwN,EAAyBjG,aAA5CvH,YAAmBwN,SAAyBjG,GAUtD4X,yBAGUhhB,EAAkB0E,EAAYtD,EAAqCE,EAAqC2f,UAAxGjhB,UAAkB0E,OAC5B8B,WAAa,IAAInG,MAAMO,KAAKZ,WAC7BU,EAAIE,KAAKZ,EAAUU,UAAU8F,WAAW9F,GAAK,IAAIqU,EAAKrU,OAE1DA,EAAIE,KAAK8D,GAAG3D,OAAeL,KAAK,KACxBO,EAAIL,KAAK8D,GAAGhE,GACZ2F,EAAYjF,EAAeH,GAAIkE,EAAY7D,EAAeL,GAC1DmI,EAAI6X,EAAUhgB,QACbuF,WAAWH,GAAGG,WAAWhG,KAAK,IAAIsgB,EAAU3b,EAAGiE,SAC/C5C,WAAWrB,GAAGqB,WAAWhG,KAAK,IAAIsgB,EAAUza,EAAG+C,gCAY5D8X,eAAA,mBACQpY,EAAI,IAAIzI,MAAMO,KAAKZ,GACdU,EAAI,EAAGA,EAAIE,KAAKZ,IAAKU,EAC1BoI,EAAEpI,GAAKE,KAAKugB,mBAAmBzgB,UAE5BoI,KASXsY,kBAAA,SAAkBtM,UACPlU,KAAKugB,mBAAmBrM,MAGnCuM,mBAAA,SAAmBvM,EAAe3O,UACvBvF,KAAKugB,mBAAmBrM,EAAO3O,MAM1Cmb,+BAAA,SACIxM,EACA3O,EACAob,OAEI3V,EAAI,IAAI4U,GAA0B,SAAChe,EAAGC,UAAMD,EAAE4G,GAAK3G,EAAE2G,KACrD/C,EAAUzF,KAAK4F,WAAWsO,GAC1B0M,EAAiB,IAAIT,EAAW1a,EAAE,KAAK,GACvCob,EAAc,OAClB7V,EAAEpL,KAAKghB,IACA5V,EAAE4K,UAELnQ,GADAmb,EAAK5V,EAAEvD,OACAxG,MACDE,KAAOoE,WAGTzF,EAAI2F,EAAEG,WAAWzF,OAAeL,KAAK,KACjCghB,EAAYrb,EAAEG,WAAW9F,GACzByE,EAAIvE,KAAK4F,WAAWkb,EAAU3f,QAG9Byf,EAAGnS,MAAQlK,EAAEpD,KAAOyf,EAAGnS,KAAKxN,KAAKE,QAIjC4f,EAASxc,EAAEpD,GAAK,IAAMsE,EAAEtE,QACzB4f,KAAUF,GAAeA,EAAYE,IAAWH,EAAGpY,QAGlDwY,EAAKJ,EAAGnS,KAAOkS,EAASC,EAAGnS,KAAKxN,KAAKE,GAAIsE,EAAEtE,GAAIoD,EAAEpD,IAAM,EACvDV,EAAImgB,EAAGpY,EAAIsY,EAAU/W,SAAWiX,EAGpCH,EAAYE,GAAUtgB,EACtBuK,EAAEpL,KAAK,IAAIugB,EAAW5b,EAAGqc,EAAIngB,cAGjCwgB,EAAgB,GACbL,EAAGnS,MAENwS,EAAKrhB,MADLghB,EAAKA,EAAGnS,MACKxN,KAAKE,WAEf8f,KAGHV,mBAAA,SAAmBrM,EAAegN,YAAAA,IAAAA,GAAgB,WAClDlW,EAAI,IAAI4U,GAAoB,SAAChe,EAAGC,UAAMD,EAAE4G,GAAK3G,EAAE2G,KAC/C1I,EAAIE,KAAK4F,WAAWzF,OACpBqI,EAAc,IAAI/I,MAAMK,GACrBA,KAAK,KACJmB,EAAajB,KAAK4F,WAAW9F,GACjCmB,EAAKuH,EAAI1I,IAAMoU,EAAQ,EAAInP,OAAOmR,kBAClCjV,EAAK+J,EAAIA,EAAEpL,KAAKqB,SAEZ+J,EAAE4K,SAAS,KAEXnQ,EAAIuF,EAAEvD,SACVe,EAAE/C,EAAEtE,IAAMsE,EAAE+C,EACR/C,EAAEtE,KAAO+f,EAAM,SACXD,EAAiB,GACjB1c,EAAIkB,OACiB,IAAXlB,EAAEkK,MACZwS,EAAKrhB,KAAK2E,EAAEkK,KAAKtN,IACjBoD,EAAIA,EAAEkK,YAEHwS,MAEXnhB,EAAI2F,EAAEG,WAAWzF,OAAeL,KAAK,KAC7BghB,EAAYrb,EAAEG,WAAW9F,GAEzBW,GADA8D,EAAIvE,KAAK4F,WAAWkb,EAAU3f,IAC1BsE,EAAE+C,EAAIsY,EAAU/W,UACpBtE,EAAE+C,IAAMzD,OAAO8D,WAAatE,EAAEiE,EAAI/H,IAClC8D,EAAEiE,EAAI/H,EACN8D,EAAEkK,KAAOhJ,EACTuF,EAAE+U,UAAUxb,EAAEyG,EAAGzG,GAAG,SAAClE,EAAE2K,UAAI3K,EAAE2K,EAAIA,cAItCxC,QCzJE2Y,gBAKAC,GACT,SAAmBpK,EAAmBC,EAAmBC,EAAmBC,WAAzDH,UAAmBC,UAAmBC,UAAmBC,GAGnEkK,kFAAkBF,aAUfG,GAAOC,EAAWC,EAAWC,UACjCD,EAAG5Z,EAAI2Z,EAAG3Z,IAAM6Z,EAAGzL,EAAIuL,EAAGvL,IAAMyL,EAAG7Z,EAAI2Z,EAAG3Z,IAAM4Z,EAAGxL,EAAIuL,EAAGvL,GAGtE,SAAS0L,GAAMvW,EAAUvE,EAAW+a,UACzBL,GAAOnW,EAAGvE,EAAI+a,GAAM,EAG/B,SAASC,GAAMzW,EAAUvE,EAAW+a,UACzBL,GAAOnW,EAAGvE,EAAI+a,GAAM,EAiH/B,SAASE,GAAoBC,EAAUC,OAI/BngB,EAAWC,EAAWwD,EACR2c,EAJd5iB,EAAI2iB,EAAE5hB,OAAS,KAQfyhB,GAAME,EAAGC,EAAE,GAAIA,EAAE,MAAQL,GAAMI,EAAGC,EAAE3iB,EAAI,GAAI2iB,EAAE,IAC9C,OAAO,MAENngB,EAAI,EAAGC,EAAIzC,IAAM,IACdyC,EAAID,GAAM,EACV,OAAI8f,GAAMI,EAAGC,EAAEngB,GAAImgB,EAAElgB,IACVD,EAEAC,MAGfmgB,EAAMJ,GAAME,EAAGC,GADf1c,EAAIa,KAAK+b,OAAOrgB,EAAIC,GAAK,IACJ,GAAIkgB,EAAE1c,OACfqc,GAAMI,EAAGC,EAAE1c,EAAI,GAAI0c,EAAE1c,IAC7B,OAAOA,EAILqc,GAAMI,EAAGC,EAAEngB,EAAI,GAAImgB,EAAEngB,IAEnBogB,GAGIN,GAAMI,EAAGC,EAAEngB,GAAImgB,EAAE1c,IAFrBxD,EAAIwD,EAKAzD,EAAIyD,EAIP2c,GAGGJ,GAAME,EAAGC,EAAEngB,GAAImgB,EAAE1c,IACjBxD,EAAIwD,EAHRzD,EAAIyD,GAiBpB,SAAS6c,GAAoBJ,EAAUC,OAG/BngB,EAAWC,EAAWwD,EACR2c,EAHd5iB,EAAI2iB,EAAE5hB,OAAS,KAOfuhB,GAAMI,EAAGC,EAAE3iB,EAAI,GAAI2iB,EAAE,MAAQH,GAAME,EAAGC,EAAE,GAAIA,EAAE,IAC9C,OAAO,MAENngB,EAAI,EAAGC,EAAIzC,IAAM,IACdyC,EAAID,GAAM,EACV,OAAIggB,GAAME,EAAGC,EAAEngB,GAAImgB,EAAElgB,IACVD,EAEAC,KAGfmgB,EAAMJ,GAAME,EAAGC,GADf1c,EAAIa,KAAK+b,OAAOrgB,EAAIC,GAAK,IACJ,GAAIkgB,EAAE1c,IACvBqc,GAAMI,EAAGC,EAAE1c,EAAI,GAAI0c,EAAE1c,MAAQ2c,EAC7B,OAAO3c,EAILuc,GAAME,EAAGC,EAAEngB,EAAI,GAAImgB,EAAEngB,IAElBogB,EAGGJ,GAAME,EAAGC,EAAEngB,GAAImgB,EAAE1c,IACjBxD,EAAIwD,EAEJzD,EAAIyD,EALRxD,EAAIwD,EASJ2c,EACApgB,EAAIyD,EAEAqc,GAAMI,EAAGC,EAAEngB,GAAImgB,EAAE1c,IACjBxD,EAAIwD,EAEJzD,EAAIyD,YAaR8c,GAAkBJ,EAAYK,EAAYC,EAAsCC,EAAsCC,EAAiDC,OAC/KC,EAAaC,EAIjBA,EAAMJ,EAAGP,EADTU,EAAMJ,EAAGD,EAAE,GAAIL,IACEK,WAGbO,GAAO,GACHA,GAAM,KACVA,GAAO,EAECF,IAAQV,EAAE5hB,OAAS,IAAGsiB,EAAM,IAC5BF,EAAKH,EAAEM,GAAMX,EAAEU,GAAMV,EAAEU,EAAM,OAC/BA,OAGU,IAARC,IAAWA,EAAMN,EAAEjiB,OAAS,IAC5BqiB,EAAKT,EAAEU,GAAML,EAAEM,GAAMN,EAAEM,EAAM,OAC/BA,EACFC,GAAO,QAGR,CAAEN,GAAII,EAAKH,GAAII,YAQVE,GAAoBb,EAAYK,UACrCD,GAAkBJ,EAAGK,EAAGP,GAAqBK,GAAqBR,GAAOE,QAWvEiB,GACT,SAAmBR,EAAmBC,WAAnBD,UAAmBC,GAG7BQ,gBAOAC,kFAAiB5B,IAIjB6B,GACT,SACW7hB,EACA8hB,EACAC,EACA/X,WAHAhK,cACA8hB,kBACAC,SACA/X,EAEPA,EAAEgY,GAAKnjB,MAIFojB,yBAEEpkB,EACAC,eADAD,cACAC,qBACXkB,OAAA,eACQ4I,EAAK/I,KAAKhB,OAAOmM,EAAEvD,EAAI5H,KAAKf,OAAOkM,EAAEvD,EACrCkP,EAAK9W,KAAKhB,OAAOmM,EAAE6K,EAAIhW,KAAKf,OAAOkM,EAAE6K,SAClC9P,KAAKC,KAAK4C,EAAKA,EAAK+N,EAAKA,SAI3BuM,yBAGUvB,EAAiBwB,aAAjBxB,SAFK,UACF,GAEbwB,OA+BIvB,EAAIuB,EAAGvB,EAAEpF,MAAM,QACf4G,EAAID,EAAGC,EAAE5G,MAAM,OAhCf,SACDvd,EAAI0iB,EAAE3hB,OAEDL,EAAI,EAAGA,EAAIV,EAAGU,IAAK,SACpBqL,EAAI2W,EAAEhiB,GAEDuB,EAAI,EAAGA,EAAI8J,EAAEhL,SAAUkB,EAAG,KAE3B8hB,EAAK,IAAIH,GAAiBhjB,KAAK+hB,EAAE5hB,OAAQL,EAAGuB,EADvC8J,EAAE9J,SAEN0gB,EAAEniB,KAAKujB,GAIR9hB,EAAI,GAAGrB,KAAKujB,EAAE3jB,KAAK,IAAIwjB,GAAejY,EAAE9J,EAAI,GAAG8hB,GAAIA,IAGvDhY,EAAEhL,OAAS,GAAGH,KAAKujB,EAAE3jB,KAAK,IAAIwjB,GAAejY,EAAE,GAAGgY,GAAIhY,EAAEA,EAAEhL,OAAS,GAAGgjB,SAErErjB,EAAI,EAAGA,EAAIV,EAAI,EAAGU,SACnB0jB,EAAK1B,EAAEhiB,OACFuB,EAAIvB,EAAI,EAAGuB,EAAIjC,EAAGiC,IAAK,KACxBoiB,EAAK3B,EAAEzgB,GACPZ,EAAIijB,GAASF,EAAIC,OAChB,IAAIzY,KAAKvK,EAAG,KACT4E,EAAI5E,EAAEuK,QAEL2Y,iBADQH,EAAGne,EAAEgd,IAAcoB,EAAGpe,EAAEid,IACCxiB,EAAGuB,kCAS7DsiB,iBAAA,SAAiBle,EAAalB,EAAaqf,EAAYC,GAC9C7jB,KAAK8jB,gBAAgB,IAAI1C,GAAY3b,EAAEmC,EAAGnC,EAAEuQ,EAAGzR,EAAEqD,EAAGrD,EAAEyR,GAAI4N,EAAIC,SAC1DN,EAAE3jB,KAAK,IAAIwjB,GAAe3d,EAAE0d,GAAI5e,EAAE4e,QAG/CY,SAAA,SAAS5Y,EAAayY,OA5PE9B,EAAUC,EAG9BiC,EA0PI5kB,EAAIY,KAAK8hB,EAAE3hB,YACV4hB,EAAEniB,KAAK,IAAIojB,GAAiBhjB,KAAK+hB,EAAE5hB,OAAQf,EAAG,EAAG+L,QACjD,IAAIrL,EAAI,EAAGA,EAAIV,IAAKU,KACjBA,IAAM8jB,OACNK,EAAOjkB,KAAK8hB,EAAEhiB,GACdW,GAlQYqhB,EAkQW3W,EA/P/B6Y,OAAAA,GAAAA,GAH8BjC,EAkQIkC,GA/PtBtH,MAAM,IACd/c,KAAKmiB,EAAE,IAER,CAAEmC,KAAMrC,GAAoBC,EAAGkC,GAAUG,KAAMjC,GAAoBJ,EAAGkC,UA6PhEL,iBAAiBxY,EAAG8Y,EAAKxjB,EAAE0jB,MAAOP,EAAI9jB,QACtC6jB,iBAAiBxY,EAAG8Y,EAAKxjB,EAAEyjB,MAAON,EAAI9jB,UAExCqL,EAAEgY,MAELW,gBAAA,SAAgB/d,EAAgB6d,EAAYC,OAC3C,IAAI/jB,EAAI,EAAGV,EAAIY,KAAK8hB,EAAE3hB,OAAQL,EAAIV,IAAKU,KACpCA,GAAK8jB,GAAM9jB,GAAK+jB,GAAMO,GAAWre,EAAG/F,KAAK8hB,EAAEhiB,IAAIK,OAAS,SACjD,SAGR,QAIf,SAASikB,GAAWre,EAAgB+b,WAC5BtK,EAAO,GACF1X,EAAI,EAAGV,EAAI0iB,EAAE3hB,OAAQL,EAAIV,IAAKU,EAAG,KAClCukB,EAAM1O,EAAU2B,iBAChBvR,EAAEiR,GAAIjR,EAAEkR,GACRlR,EAAEmR,GAAInR,EAAEoR,GACR2K,EAAEhiB,EAAI,GAAG8H,EAAGka,EAAEhiB,EAAI,GAAGkW,EACrB8L,EAAEhiB,GAAG8H,EAAGka,EAAEhiB,GAAGkW,GAEbqO,GAAK7M,EAAK5X,KAAKykB,UAEhB7M,WAGKkM,GAAS3B,EAAYK,WAE7BjgB,EAAI4f,EAAE5hB,OAAS,EAAGf,EAAIgjB,EAAEjiB,OAAS,EACjCmkB,EAAK,IAAIxB,GACJhjB,EAAI,EAAGA,GAAKqC,IAAKrC,MACjB,IAAIuB,EAAI,EAAGA,GAAKjC,IAAKiC,EAAG,KACrBkjB,EAAKxC,EAAO,GAALjiB,EAASqC,EAAIrC,EAAI,GACxB0kB,EAAKzC,EAAEjiB,GACP2kB,EAAK1C,EAAEjiB,GAAKqC,EAAI,EAAIrC,EAAI,GACxB4kB,EAAKtC,EAAO,GAAL/gB,EAASjC,EAAIiC,EAAI,GACxB2a,EAAKoG,EAAE/gB,GACPsjB,EAAKvC,EAAE/gB,GAAKjC,EAAI,EAAIiC,EAAI,GACxBujB,EAAStD,GAAOiD,EAAIC,EAAIxI,GACxB6I,EAASvD,GAAOkD,EAAIE,EAAI1I,GACxB8I,EAASxD,GAAOkD,EAAIxI,EAAI2I,GACxBI,EAASzD,GAAOoD,EAAI1I,EAAIwI,GACxBQ,EAAS1D,GAAOtF,EAAIuI,EAAIC,GACxBS,EAAS3D,GAAOtF,EAAIwI,EAAIC,GACxBG,GAAU,GAAKC,GAAU,GAAKC,EAAS,GACpCC,GAAU,GAAKC,GAAU,GAAKC,EAAS,EACtCX,EAAGY,GAAK,IAAIrC,GAAU/iB,EAAGuB,GACtBujB,GAAU,GAAKC,GAAU,GAAKC,EAAS,GAC3CC,GAAU,GAAKC,GAAU,GAAKC,EAAS,EACtCX,EAAGa,GAAK,IAAItC,GAAU/iB,EAAGuB,GACtBujB,GAAU,GAAKC,EAAS,GAAKC,GAAU,GAC3CC,GAAU,GAAKC,EAAS,GAAKC,GAAU,EACtCX,EAAGvX,GAAK,IAAI8V,GAAU/iB,EAAGuB,GACtBujB,GAAU,GAAKC,EAAS,GAAKC,GAAU,GAC3CC,GAAU,GAAKC,EAAS,GAAKC,GAAU,IACtCX,EAAGc,GAAK,IAAIvC,GAAU/iB,EAAGuB,WAIlCijB,EASX,SAASe,GAAUla,EAAYH,UACnBG,EAAE6T,OAAM,SAAAza,UAPpB,SAA2B4G,EAAU8Y,OAC5B,IAAInkB,EAAI,EAAGV,EAAI6kB,EAAK9jB,OAAQL,EAAIV,IAAKU,KAClC8hB,GAAMqC,EAAKnkB,EAAI,GAAImkB,EAAKnkB,GAAIqL,GAAI,OAAO,SACxC,EAIema,CAAkB/gB,EAAGyG,MCzc/C,ICaYua,GDbRC,IAEiB,EAAItf,KAAKC,KAAK,IAAM,WAMzBsf,GAAaC,EAAmB/f,EAAGyX,EAAGuI,EAAWC,EAAmBC,mBAAnBD,IAAAA,EAAgB,YAAGC,IAAAA,GAAc,qBAK1FC,EAAYngB,EACZogB,EAAa3I,EAKb4I,GAHAJ,OAAyC,IAAlBA,EAAgCA,EAAgB,EACvED,OAAiC,IAAdA,EAA4BA,EAAY,EAE9C,GACbM,EAAc,EACdC,EAAY,EAEZC,EAAgB,EAChBC,EAAO,YAiLFC,EAAK9T,EAAM+T,GAChBF,EAAO,GACPJ,EAAa,EACbC,EAAc,EACdE,EAlMS,MAoMJ,IAAIrmB,EAAI,EAAGA,EAAIyS,EAAKpS,OAAQL,IAE7BymB,EADQhU,EAAKzS,GACDwmB,UAGTpgB,KAAK+E,IA4CJ+a,EAAaC,EA5CcL,YAI9BW,EAASvL,EAAMsL,WAGhBE,OAAS5R,EAEJ9U,EAAI,EAAGA,EAAIsmB,EAAKjmB,OAAQL,OACxBsmB,EAAKtmB,GAAG2mB,YAAczL,EAAK9R,QAAYkd,EAAKtmB,GAAG8H,EAAIwe,EAAKtmB,GAAGmJ,MAAQ+R,EAAK/R,MA7N5E,GA6N6Gqd,GA3NvG,KA2NmJ,CACtJE,EAASJ,EAAKtmB,SAKtBsmB,EAAKxmB,KAAKob,QAEKpG,IAAX4R,GACAxL,EAAKpT,EAAI4e,EAAO5e,EAAI4e,EAAOvd,MAtO1B,GAuOD+R,EAAKhF,EAAIwQ,EAAOE,OAChB1L,EAAKyL,WAAazL,EAAK9R,OACvB8R,EAAK0L,OAAS1L,EAAKhF,EACnBwQ,EAAOC,YAAczL,EAAK9R,OA1OzB,GA2ODsd,EAAOE,QAAU1L,EAAK9R,OA3OrB,KA6OD8R,EAAKhF,EAAImQ,EACTA,GAAiBnL,EAAK9R,OA9OrB,GA+OD8R,EAAKpT,EAtOA,EAuOLoT,EAAK0L,OAAS1L,EAAKhF,EACnBgF,EAAKyL,WAAazL,EAAK9R,QAGvB8R,EAAKhF,EAAIgF,EAAK9R,OAAS+c,GAlPhB,OAkP6DA,EAAcjL,EAAKhF,EAAIgF,EAAK9R,OA1O3F,GA2OL8R,EAAKpT,EAAIoT,EAAK/R,MAAQ+c,GAnPf,OAmP2DA,EAAahL,EAAKpT,EAAIoT,EAAK/R,MA5OxF,GAgBQ,GAAjByc,EAAOvlB,kBAkBWulB,GAElBA,EAAOtlB,SAAQ,SAAUoD,OAIImjB,EACrBC,EAA0BC,EAC1BC,EAAWC,EAFUJ,EAHLnjB,EAIhBojB,EAAQ7hB,OAAO8D,UAAWge,EAAQ9hB,OAAO8D,UACzCie,EAAQ,EAAGC,EAAQ,EAEvBJ,EAAMK,MAAM5mB,SAAQ,SAAUmE,OACtBoB,OAAuB,IAAZpB,EAAE0E,MAAwB1E,EAAE0E,MAAQ0c,EAC/CvI,OAAwB,IAAb7Y,EAAE2E,OAAyB3E,EAAE2E,OAASyc,EACrDhgB,GAAK,EACLyX,GAAK,EACL0J,EAAQ5gB,KAAKuE,IAAIlG,EAAEqD,EAAIjC,EAAGmhB,GAC1BF,EAAQ1gB,KAAKG,IAAI9B,EAAEqD,EAAIjC,EAAGihB,GAC1BG,EAAQ7gB,KAAKuE,IAAIlG,EAAEyR,EAAIoH,EAAG2J,GAC1BF,EAAQ3gB,KAAKG,IAAI9B,EAAEyR,EAAIoH,EAAGyJ,MAG9BF,EAAM1d,MAAQ6d,EAAQF,EACtBD,EAAMzd,OAAS6d,EAAQF,KA7B/BI,CAAavB,YAiGEnT,EAAMqT,OACbsB,EAAcniB,OAAOmR,kBACrBiR,EAAY,EAChB5U,EAAKpP,MAAK,SAAUvB,EAAGC,UAAYA,EAAEqH,OAAStH,EAAEsH,kBAM5CrC,EAAOmQ,EAJXkP,EAAY3T,EAAKkD,QAAO,SAAU7T,EAAGC,UAC1BD,EAAEqH,MAAQpH,EAAEoH,MAAQrH,EAAEqH,MAAQpH,EAAEoH,SAIvCnC,EAAQoQ,WAyGU3E,OAClBtJ,EAAQ,SACZsJ,EAAKnS,SAAQ,SAAUoI,UAAYS,GAAST,EAAES,MA1PzC,MA2PEA,EA5GUme,CAAiB7U,GAC9B8U,EAAmB,EAEnBC,EAAOviB,OAAO8D,UACd0e,EAAOxiB,OAAO8D,UACd2e,GAAQ,EAGRze,EAAKhE,OAAO8D,UACZ4e,EAAK1iB,OAAO8D,UAERE,EAAKmd,GAAcuB,EAxJhB,MAwJmD,IAE9C,GAARD,OACIxQ,EAAKlQ,GAASA,EAAQD,GAAQ2e,GAC9B8B,EAAOjB,EAAK9T,EAAMyE,MAEd,GAARwQ,OACItQ,EAAKrQ,GAAQC,EAAQD,GAAQ2e,GAC7B+B,EAAOlB,EAAK9T,EAAM2E,MAG1BnO,EAAK7C,KAAK+E,IAAI+L,EAAKE,GACnBuQ,EAAKvhB,KAAK+E,IAAIqc,EAAOC,GAEjBD,EAAOJ,IACPA,EAAcI,EACdH,EAAYnQ,GAGZuQ,EAAOL,IACPA,EAAcK,EACdJ,EAAYjQ,GAGZoQ,EAAOC,GACP1gB,EAAOmQ,EACPA,EAAKE,EACLoQ,EAAOC,EACPC,EAAO,IAEP1gB,EAAQoQ,EACRA,EAAKF,EACLuQ,EAAOD,EACPE,EAAO,GAGPH,IAAqB,UAK7BhB,EAAK9T,EAAM4U,GA9Jfnf,CAAM0d,GACHG,YAoEmCH,GAClCA,EAAOtlB,SAAQ,SAAUoD,OAEjBmW,EAAS,CAAE/R,EAAG,EAAGoO,EAAG,GAExBxS,EAAEwjB,MAAM5mB,SAAQ,SAAUa,GACtB0Y,EAAO/R,GAAK3G,EAAK2G,EACjB+R,EAAO3D,GAAK/U,EAAK+U,KAGrB2D,EAAO/R,GAAKpE,EAAEwjB,MAAM7mB,OACpBwZ,EAAO3D,GAAKxS,EAAEwjB,MAAM7mB,WAIhBsN,EAAcjK,EAAEoE,GADF+R,EAAO/R,EAAIpE,EAAEyF,MAAQ,GACJ6c,EAAY,EAAIE,EAAa,EAA5DvY,EAAkEjK,EAAEwS,GAD3B2D,EAAO3D,EAAIxS,EAAE0F,OAAS,GACoB6c,EAAa,EAAIE,EAAc,EAGtHziB,EAAEwjB,MAAM5mB,SAAQ,SAAUa,GACtBA,EAAK2G,GAAK6F,EACVxM,EAAK+U,GAAKvI,QAvFlBia,CAA6BhC,mBAgOrBiC,GAAeziB,EAAOC,WAC9ByiB,EAAQ,GACRC,EAAO,GACPnC,EAAS,GACToC,EAAW,EAENhoB,EAAI,EAAGA,EAAIqF,EAAMhF,OAAQL,IAAK,KAC/BioB,EAAO5iB,EAAMrF,GACbkoB,EAAKD,EAAK/oB,OACVipB,EAAKF,EAAK9oB,OACV4oB,EAAKG,EAAG9gB,OACR2gB,EAAKG,EAAG9gB,OAAOtH,KAAKqoB,GAEpBJ,EAAKG,EAAG9gB,OAAS,CAAC+gB,GAElBJ,EAAKI,EAAG/gB,OACR2gB,EAAKI,EAAG/gB,OAAOtH,KAAKooB,GAEpBH,EAAKI,EAAG/gB,OAAS,CAAC8gB,OAGjBloB,EAAI,EAAGA,EAAIoF,EAAM/E,OAAQL,IAAK,KAC/BmB,EAAOiE,EAAMpF,GACb8nB,EAAM3mB,EAAKiG,QACfghB,EAAajnB,GAAM,YAGdinB,EAAa9oB,EAAG+oB,WACEvT,IAAnBgT,EAAMxoB,EAAE8H,QACRihB,IACAL,IACApC,EAAO9lB,KAAK,CAAEonB,MAAO,MAEzBY,EAAMxoB,EAAE8H,OAAS4gB,EACjBpC,EAAOoC,EAAW,GAAGd,MAAMpnB,KAAKR,OAC5BgpB,EAAWP,EAAKzoB,EAAE8H,UACjBkhB,MAEA,IAAI/mB,EAAI,EAAGA,EAAI+mB,EAASjoB,OAAQkB,IACjC6mB,EAAaE,EAAS/mB,IAAI,WAI3BqkB,ECvPX,SAAS2C,GAAQ7kB,eACc,IAAbA,EAAExC,aAA8C,IAAbwC,EAAEpC,QAhD3CmkB,GAAAA,cAAAA,qCAAmBA,qBAAMA,uBAyExB+C,uDACa,CAAC,EAAG,sBACoC,yBAC3B,8BACH,oBACZ,0BACK,4BACK,iBAGX,cACF,gBACC,mBACG,iBACmB,qBACjB,wBACG,mBACE,mCACO,qBACd,0BACM,4BACC,gBAGV,uBAkVqB,CACnC9nB,eAAgB8nB,EAAO9nB,eACvBE,eAAgB4nB,EAAO5nB,eACvBsF,UAAWsiB,EAAOC,cAClB5nB,QAAS,SAAAoF,SAA+B,mBAAnBxF,EAAKioB,UAA2BjoB,EAAKioB,UAAUziB,GAAK,+BAlVtE0iB,GAAA,SAAGpoB,EAAuBqoB,UAExB1oB,KAAK2oB,QAAO3oB,KAAK2oB,MAAQ,IACb,iBAANtoB,OACFsoB,MAAMpD,YAAUllB,IAAMqoB,OAEtBC,MAAMtoB,GAAKqoB,EAEb1oB,QAKD4oB,QAAA,SAAQvoB,GACVL,KAAK2oB,YAAuC,IAAvB3oB,KAAK2oB,MAAMtoB,EAAEnB,YAC7BypB,MAAMtoB,EAAEnB,MAAMmB,MAOjBwoB,KAAA,iBACE7oB,KAAK8oB,aAMPA,KAAA,cACF9oB,KAAK+oB,OAAS/oB,KAAKgpB,uBACdC,UAAW,OACXL,QAAQ,CAAE1pB,KAAMqmB,YAAUhgB,IAAKmG,MAAO1L,KAAK+oB,OAAS,EAAGvc,OAAQxM,KAAKkpB,eAClE,MAIP7mB,EAAGvC,EAFDV,EAAIY,KAAKqI,OAAOlI,gBAIjBgpB,SAASthB,MAAMC,QACfhI,EAAI,EAAGA,EAAIV,IAAKU,GACjBuC,EAAIrC,KAAKqI,OAAOvI,IACVod,aACkB,IAAT7a,EAAEmb,SAAsC,IAATnb,EAAEwb,KACxCxb,EAAEmb,GAAKnb,EAAEuF,EACTvF,EAAEwb,GAAKxb,EAAE2T,QAGRmT,SAASthB,MAAM9H,IAAID,EADhB,CAACuC,EAAEmb,GAAInb,EAAEwb,UAKrBuL,EAAKppB,KAAKmpB,SAASzc,oBAEZ,IAAP0c,OACKL,OAAS,OACqB,IAArB/oB,KAAKkpB,mBACdH,OAASK,QAEbF,YAAcE,OAEdC,2BAEAT,QAAQ,CAAE1pB,KAAMqmB,YAAUuD,KAAMpd,MAAO1L,KAAK+oB,OAAQvc,OAAQxM,KAAKkpB,eAC/D,KAIHG,oBAAA,mBAEAhnB,EADEuF,EAAI5H,KAAKmpB,SAASvhB,EAAE,GAAIoO,EAAIhW,KAAKmpB,SAASvhB,EAAE,GAC3C9H,EAAIE,KAAKqI,OAAOlI,OAChBL,MACHuC,EAAIrC,KAAKqI,OAAOvI,IACd8H,EAAIA,EAAE9H,GACRuC,EAAE2T,EAAIA,EAAElW,MAahBoF,MAAA,SAAMX,OACGA,EAAG,IACuB,IAAvBvE,KAAKqI,OAAOlI,QAAgBH,KAAKspB,OAAOnpB,OAAS,EAAG,KAGhDf,EAAI,OACHkqB,OAAOlpB,SAAQ,SAAU2F,GAC1B3G,EAAI8G,KAAKuE,IAAIrL,EAAW2G,EAAE/G,OAAgB+G,EAAE9G,gBAE3CoJ,OAAS,IAAI5I,QAAQL,OACrB,IAAIU,EAAI,EAAGA,EAAIV,IAAKU,OAChBuI,OAAOvI,GAAK,UAGlBE,KAAKqI,mBAEXA,OAAS9D,EACPvE,QAUXoB,OAAA,SAAOwG,qBACEA,QACA2hB,QAAU3hB,OACV4hB,WAAa,QACbD,QAAQnpB,SAAQ,SAAAoD,QACQ,IAAdA,EAAEsS,UACTtS,EAAEsS,QAAU,QACQ,IAAbtS,EAAExC,QACTwC,EAAExC,OAAOZ,SAAQ,SAACmE,EAAGzE,GACA,iBAANyE,KACNf,EAAExC,OAAOlB,GAAK+D,EAAKwE,OAAO9D,IAAIiiB,OAAShjB,WAG5B,IAAbA,EAAEpC,QACToC,EAAEpC,OAAOhB,SAAQ,SAACqpB,EAAI3pB,GACA,iBAAP2pB,KACNjmB,EAAEpC,OAAOtB,GAAK+D,EAAK0lB,QAAQE,IAAKjD,OAAShjB,cAIrDgmB,WAAWxoB,OAAShB,KAAKqI,OAAOwU,QAAO,SAAAtY,eAAyB,IAAbA,EAAEiiB,eACrDgD,WAAWpoB,OAASpB,KAAKupB,QAAQ1M,QAAO,SAAArZ,eAAyB,IAAbA,EAAEgjB,UACpDxmB,MArBQA,KAAKupB,WAwBxBG,iBAAA,SAAiBhlB,OACTlB,EAAImmB,EAAqB3pB,KAAKqI,OAAQrI,KAAKspB,OAAQtpB,KAAKV,aAAcU,KAAKwpB,wBAC1EpoB,OAAOoC,EAAEpC,QACdsD,EAAElB,GACKxD,QAWX6b,cAAA,SAActX,UACLqlB,UAAUzpB,aACV0pB,eAAiBtlB,EACfvE,MAFuBA,KAAK6pB,kBAevCC,mBAAA,SAAmBvlB,UACVqlB,UAAUzpB,aACV4pB,oBAAsBxlB,EACpBvE,MAFuBA,KAAK+pB,uBAWvCC,WAAA,SAAWzjB,EAAc0jB,UAChBL,UAAUzpB,SAAQoG,EAAO,UACzB2jB,yBAA2B,CAC5B3jB,KAAMA,EACNS,iBAA2C,iBAAlBijB,EAA6B,kBAAqBA,GAAkBA,GAE1FjqB,QAUXmF,MAAA,SAAMyC,UACGgiB,UAAUzpB,aACVmpB,OAAS1hB,EACP5H,MAFuBA,KAAKspB,UAavC5iB,YAAA,SAAYrB,UACHukB,UAAUzpB,aACVgqB,aAAe9kB,EACbrF,MAFuBA,KAAKmqB,gBAcvCC,eAAA,SAAe5hB,UACNohB,UAAUzpB,aACVkqB,gBAAkB7hB,EAChBxI,MAFuBA,KAAKqqB,mBAavCrX,KAAA,SAAKpL,UACIA,QACA0iB,YAAc1iB,EACZ5H,MAFQA,KAAKsqB,eAYxBC,gBAAA,SAAgB3iB,UACPA,QACA4iB,iBAAmB5iB,EACjB5H,MAFQA,KAAKwqB,oBAYxBC,iBAAA,SAAiB7iB,UACRA,QACA8iB,kBAAoB9iB,EAClB5H,MAFQA,KAAK0qB,qBAYxBC,aAAA,SAAa/iB,UACJA,QAGAgjB,cAA6B,mBAANhjB,EAAmBA,GAAKA,OAC/CijB,sBAAwB,KACtB7qB,MAJIA,KAAK4qB,iBAOpBE,SAAA,SAASpmB,eACA8jB,UAAY9jB,EACV1E,QAKX+qB,qBAAA,SAAqBnjB,UACZA,QACAohB,WAA0B,mBAANphB,EAAmBA,GAAKA,EAC1C5H,MAFQA,KAAKgpB,cAOxBtd,MAAA,SAAM9D,UACGgiB,UAAUzpB,QAEXyH,GAAKA,EACD5H,KAAK+oB,OACM/oB,KAAK+oB,OAAZnhB,EAAI,EAAiBA,EACN,EACZA,EAAI,IACN5H,KAAKipB,gBACDA,UAAW,OACXL,QAAQ,CAAE1pB,KAAMqmB,YAAUrR,MAAOxI,MAAO1L,KAAK+oB,OAASnhB,SACtDihB,SAGN7oB,MAbmBA,KAAK+oB,UAiBvCiC,cAAA,SAAcjD,SAC2B,mBAAvB/nB,KAAK4qB,eAA+D5qB,KAAK4qB,cAAe7C,GAAiB/nB,KAAK4qB,iBAGzHrC,cAAP,SAAqBR,EAAyB5nB,GAC1C4nB,EAAK5nB,OAASA,KAGlB8qB,YAAA,SAAYlD,SACyB,mBAAnB/nB,KAAKwoB,UAA2BxoB,KAAKwoB,UAAUT,GAAQ,KAoBzE9hB,yBAAA,SAAyBilB,EAAqBvlB,8BAAAA,IAAAA,EAAY,QACjDglB,cAAa,SAAA5kB,UAAKmlB,EAAcnlB,EAAE5F,eAClC0qB,sBAAwB,kBAAM5kB,EAAyBhC,EAAKqlB,OAAQrlB,EAAK3E,aAAcqG,IACrF3F,QAaXoG,mBAAA,SAAmB8kB,EAAqBvlB,8BAAAA,IAAAA,EAAY,QAC3CglB,cAAa,SAAA5kB,UAAKmlB,EAAcnlB,EAAE5F,eAClC0qB,sBAAwB,kBAAMzkB,EAAmByG,EAAKyc,OAAQzc,EAAKvN,aAAcqG,IAC/E3F,QAaXkU,MAAA,SACIiX,EACAC,EACAC,EACAC,EACAC,EACA1F,uBALAsF,IAAAA,EAAyC,YACzCC,IAAAA,EAA0C,YAC1CC,IAAAA,EAA0C,YAC1CC,IAAAA,EAA6B,YAC7BC,IAAAA,GAAc,YACd1F,IAAAA,GAAc,OA6BV2F,EAzBApsB,EAAiBY,KAAKkF,QAAS/E,OAC/B8a,EAAI7b,EAAI,EAAIY,KAAKupB,QAAQppB,OAEzBwF,EAAI3F,KAAKsqB,YAAY,GACrBlN,EAAIpd,KAAKsqB,YAAY,GAErB1iB,EAAI,IAAInI,MAAMwb,GAAIjF,EAAI,IAAIvW,MAAMwb,GAEhC9S,EAAI,KAEJsjB,EAAKzrB,KAAK6pB,oBAETxhB,OAAOjI,SAAQ,SAACmE,EAAGzE,GACpByE,EAAE2C,MAAQpH,OACS,IAARyE,EAAEqD,IACTrD,EAAEqD,EAAIjC,EAAI,EAAGpB,EAAEyR,EAAIoH,EAAI,GAE3BxV,EAAE9H,GAAKyE,EAAEqD,EAAGoO,EAAElW,GAAKyE,EAAEyR,KAGrBhW,KAAK6qB,uBAAuB7qB,KAAK6qB,wBAMjC7qB,KAAKqqB,gBAELmB,EAAYxrB,KAAKqqB,iBAGjBmB,EAAa,IAAIpL,GAAWnF,EAAGjb,KAAKspB,OAAQhB,EAAO9nB,eAAgB8nB,EAAO5nB,gBAAgB,SAAAqF,UAAI4L,EAAKqZ,cAAcjlB,MAAKua,iBAItHnY,EAAIF,EAAQkB,mBAAmB8R,GAAG,kBAAM,UACnCqO,OAAOlpB,SAAQ,SAAA2F,GACO,iBAAZA,EAAE/G,SAAoB+G,EAAE/G,OAAS2S,EAAKtJ,OAAetC,EAAE/G,SAC3C,iBAAZ+G,EAAE9G,SAAoB8G,EAAE9G,OAAS0S,EAAKtJ,OAAetC,EAAE9G,iBAEjEqqB,OAAOlpB,SAAQ,SAAAC,OACVoF,EAAI6iB,EAAO9nB,eAAeH,GAAIkE,EAAI+jB,EAAO5nB,eAAeL,GAC9D8H,EAAE1C,GAAGlB,GAAK4D,EAAE5D,GAAGkB,GAAKpF,EAAE4J,QAAU,UAIpC/B,EAAID,EAAQkB,mBAAmB8R,GAAG,SAAUnb,EAAGuB,UACxCmqB,EAAU1rB,GAAGuB,SAGpBrB,KAAKwpB,iBAAgD,IAA3BxpB,KAAKwpB,WAAWpoB,OAAwB,KAC9DtB,EAAIV,OAKHmqB,QAAQnpB,SAAQ,SAAAoD,IAJD,SAAC1D,EAAGuB,EAAGqqB,EAAU1hB,GACjC7B,EAAErI,GAAGuB,GAAK8G,EAAE9G,GAAGvB,GAAK4rB,EACpBxjB,EAAEpI,GAAGuB,GAAK6G,EAAE7G,GAAGvB,GAGiC,GAAhD6rB,CAAc7rB,EAAGA,EAAI,EAAG6R,EAAK+Y,wBAiBL,IAAblnB,EAAEgS,QACT5N,EAAE9H,GAAK6F,EAAI,EAAGqQ,EAAElW,KAAOsd,EAAI,EAC3BxV,EAAE9H,GAAK6F,EAAI,EAAGqQ,EAAElW,KAAOsd,EAAI,IAE3BxV,EAAE9H,GAAK0D,EAAEgS,OAAO5N,EAAGoO,EAAElW,KAAO0D,EAAEgS,OAAOQ,EACrCpO,EAAE9H,GAAK0D,EAAEgS,OAAOO,EAAGC,EAAElW,KAAO0D,EAAEgS,OAAOS,WAG1CjW,KAAKwpB,WAAa,CAAExoB,OAAQhB,KAAKqI,OAAQjH,OAAQ,QAEpDwqB,EAAiB5rB,KAAKmqB,cAAgB,OACtCnqB,KAAKkqB,gCACM5qB,aAAc0H,iBAAmBhH,KAAKkqB,yBAAyBljB,iBAC1E4kB,EAAiBA,EAAelR,OAAOpU,EAAgClH,EAAGY,KAAKspB,OAAQtpB,KAAKkqB,yBAAyB3jB,KAAYvG,KAAKV,qBAKrIuc,eAAc,QACdsN,SAAW,IAAIlhB,EAAQ,CAACL,EAAGoO,GAAI9N,OAAG0M,EAAW5U,KAAKqI,aAElD8gB,SAASthB,MAAMC,QACXhI,EAAI,EAAGA,EAAIV,IAAKU,EAAG,KACpBuC,EAAIrC,KAAKqI,OAAOvI,GAChBuC,EAAE6a,QACF7a,EAAEmb,GAAKnb,EAAEuF,EACTvF,EAAEwb,GAAKxb,EAAE2T,OAEJmT,SAASthB,MAAM9H,IAAID,EADhB,CAACuC,EAAEuF,EAAGvF,EAAE2T,aAInBmT,SAASxc,UAAY3M,KAAKgpB,gBAK1B6C,cAAcV,EAAgCvjB,EAAGoO,GAGlD4V,EAAezrB,OAAS,IAAGH,KAAKmpB,SAASld,QAAU,IAAI2P,EAAW5b,KAAKqI,OAAQrI,KAAKupB,QAASvpB,KAAKwpB,WAAYoC,GAAgB5N,yBAC7HmL,SAAS7c,IAAI8e,QACbU,8BAA8BnmB,EAAGyX,EAAGyI,QAGpChK,cAAc4P,GACfA,SACKpjB,OAAOjI,SAAQ,SAAUmE,EAAGzE,GAAKyE,EAAEqD,EAAIA,EAAE9H,GAAIyE,EAAEyR,EAAIA,EAAElW,WACrDqpB,SAASld,QAAU,IAAI2P,EAAW5b,KAAKqI,OAAQrI,KAAKupB,QAASvpB,KAAKwpB,WAAYoC,GAAgB,GAAM5N,wBACpG3V,OAAOjI,SAAQ,SAAUmE,EAAGzE,GAAK8H,EAAE9H,GAAKyE,EAAEqD,EAAGoO,EAAElW,GAAKyE,EAAEyR,WAI1DmT,SAAShhB,EAAIA,OACbghB,SAAS7c,IAAI+e,GAEdC,EAAoB,MACfnC,SAASve,aAAe,SACxBue,SAASxe,aAAe3K,KAAKqI,OAAO,GAAGY,WACvCkgB,SAASre,iBAAmB1L,OAC5B+pB,SAASje,gBAAkB9L,GAAK6b,MACjC8Q,EAAK9jB,EAAQkB,mBAAmB8R,GAAE,SAACnb,EAAGuB,UAClCvB,GAAKV,GAAKiC,GAAKjC,EAAU+I,EAAErI,GAAGuB,GAC3B,UAEN8nB,SAAShhB,EAAI4jB,OACb5C,SAAS7c,IAAIgf,eAGjBjC,2BACAyC,8BAA8BnmB,EAAGyX,EAAGyI,GAClC0F,EAAcvrB,KAAKgsB,SAAWhsB,QAGjC6rB,cAAA,SAActf,EAAoB3E,EAAaoO,MAC/ChW,KAAKupB,QAAQppB,OAAS,GAAKoM,EAAa,EAAG,KAGvCnN,EAAIY,KAAKqI,OAAOlI,OAChBd,EAAQW,KAAKspB,OAAO5hB,KAAI,SAAArH,SAAU,CAAErB,OAAeqB,EAAErB,OAAQkI,MAAOjI,OAAeoB,EAAEpB,OAAQiI,UAC7FtC,EAAK5E,KAAKqI,OAAOX,KAAI,SAAAnD,SAAU,CAAE2C,MAAO3C,EAAE2C,eACzCqiB,QAAQnpB,SAAQ,SAACoD,EAAG1D,GACrB8E,EAAGhF,KAAU,CAAEsH,MAAO1D,EAAE0D,MAAQ9H,EAAIU,YAEnCypB,QAAQnpB,SAAQ,SAACoD,EAAG1D,QACG,IAAb0D,EAAExC,QACTwC,EAAExC,OAAOZ,SAAQ,SAAAmE,UAAKlF,EAAMO,KAAK,CAAEZ,OAAQwE,EAAE0D,MAAOjI,OAAQsF,EAAE2C,gBAC1C,IAAb1D,EAAEpC,QACToC,EAAEpC,OAAOhB,SAAQ,SAAA6rB,UAAM5sB,EAAMO,KAAK,CAAEZ,OAAQwE,EAAE0D,MAAOjI,OAAQgtB,EAAG/kB,mBAIpEohB,GACCtV,KAAKhT,KAAKgT,QACV9N,MAAMN,GACNO,MAAM9F,GACNwc,eAAc,GACd8O,aAAa3qB,KAAK2qB,gBAClB1kB,yBAAyB,GACzB8kB,qBAAqB,MACrB7W,MAAM3H,EAAY,EAAG,EAAG,GAAG,QAE3BlE,OAAOjI,SAAQ,SAAAmE,GAChBqD,EAAErD,EAAE2C,OAAStC,EAAGL,EAAE2C,OAAOU,EACzBoO,EAAEzR,EAAE2C,OAAStC,EAAGL,EAAE2C,OAAO8O,eAGxBmT,SAAS7c,IAAIC,MAKlBuf,8BAAA,SAA8B7iB,EAAeC,EAAgB2c,0BAAAA,IAAAA,GAAuB,IAEnF7lB,KAAKqqB,iBAAmBrqB,KAAK+pB,oBAAqB,KAC/CniB,EAAI5H,KAAKmpB,SAASvhB,EAAE,GAAIoO,EAAIhW,KAAKmpB,SAASvhB,EAAE,QAC3CS,OAAOjI,SAAQ,SAAUmE,EAAGzE,GAAKyE,EAAEqD,EAAIA,EAAE9H,GAAIyE,EAAEyR,EAAIA,EAAElW,MAE1D2lB,GADakC,GAAe3nB,KAAKqI,OAAQrI,KAAKspB,QACzBrgB,EAAOC,EAAQlJ,KAAKwqB,iBAAkB,EAAG3E,QACzDxd,OAAOjI,SAAQ,SAACmE,EAAGzE,GACpBme,EAAKkL,SAASvhB,EAAE,GAAG9H,GAAKyE,EAAEqD,EAAGqW,EAAKkL,SAASvhB,EAAE,GAAG9H,GAAKyE,EAAEyR,EACnDzR,EAAEiR,SACFjR,EAAEiR,OAAOoB,WAAWrS,EAAEqD,GACtBrD,EAAEiR,OAAOqB,WAAWtS,EAAEyR,WAMtCgW,OAAA,kBACWhsB,KAAK0L,MAAM,OAGtBwgB,KAAA,kBACWlsB,KAAK0L,MAAM,MAKtBygB,mBAAA,SAAmBC,YAAAA,IAAAA,EAAqB,QAC/BC,iBAAmB,IAAIhJ,GACxBrjB,KAAKqI,OAAOX,KAAI,SAAUnD,UACfA,EAAEiR,OAAOK,SAASuW,GAAY3U,kBAajD6U,UAAA,SAAUC,EAAMjU,EAAgBkU,YAAhBlU,IAAAA,EAAa,OACrBmU,EAAW,GAIXC,EAAM,IAAIrJ,GAAuBrjB,KAAKqsB,iBAAiBvK,EAAG,CAAEC,EAAG/hB,KAAKqsB,iBAAiBtK,EAAGwB,EAAGvjB,KAAKqsB,iBAAiB9I,IACjHoJ,EAAkB,CAAE/kB,EAAG2kB,EAAKvtB,OAAO4I,EAAGoO,EAAGuW,EAAKvtB,OAAOgX,GACrD4W,EAAkB,CAAEhlB,EAAG2kB,EAAKttB,OAAO2I,EAAGoO,EAAGuW,EAAKttB,OAAO+W,GACrD9B,EAAQwY,EAAI3I,SAAS4I,EAAOJ,EAAKvtB,OAAOkI,OACxC3B,EAAMmnB,EAAI3I,SAAS6I,EAAOL,EAAKttB,OAAOiI,OAC1CwlB,EAAI/I,iBAAiBgJ,EAAOC,EAAOL,EAAKvtB,OAAOkI,MAAOqlB,EAAKttB,OAAOiI,YAC9C,IAATslB,GACPA,EAAKE,OAILG,EADS,IAAIzM,GAAWsM,EAAI3K,EAAE5hB,OAAQusB,EAAInJ,GAD9B,SAAAljB,UAAKA,EAAErB,OAAOmC,MAAgB,SAAAd,UAAKA,EAAEpB,OAAOkC,MAAa,SAAAd,UAAKA,EAAEF,YAEtDsgB,mBAAmBvM,EAAM/S,GAAIoE,EAAIpE,OAC/B,IAAxB0rB,EAAa1sB,QAAgB0sB,EAAa1sB,SAAWusB,EAAI3K,EAAE5hB,OAAQ,KAC/D2sB,EAAQzU,EAAgBkU,EAAKvtB,OAAO+tB,YAAaR,EAAKttB,OAAO8tB,YAAazU,GAC9EmU,EAAW,CAACK,EAAMpU,mBAAoBoU,EAAMlU,gBACzC,SACCxZ,EAAIytB,EAAa1sB,OAAS,EAC1BgL,EAAIuhB,EAAI3K,EAAE8K,EAAaztB,IAAI+L,EAC3BH,EAAI0hB,EAAI3K,EAAE8K,EAAa,IAAI1hB,EAEtBrL,GADL2sB,EAAW,CAACF,EAAKvtB,OAAO+tB,YAAYxV,gBAAgBpM,EAAEvD,EAAGuD,EAAE6K,IAClD5W,GAAGU,GAAK,IAAKA,EACtB2sB,EAAS7sB,KAAK8sB,EAAI3K,EAAE8K,EAAa/sB,IAAIqL,GACzCshB,EAAS7sB,KAAKiZ,EAAW7N,EAAGuhB,EAAKttB,OAAO8tB,YAAazU,WAclDmU,KAIJjsB,eAAP,SAAsBH,SACS,iBAAbA,EAAErB,OAA8BqB,EAAErB,OAAgBqB,EAAErB,OAAQkI,SAIvExG,eAAP,SAAsBL,SACS,iBAAbA,EAAEpB,OAA8BoB,EAAEpB,OAAgBoB,EAAEpB,OAAQiI,SAIvE8lB,OAAP,SAAc3sB,UACHioB,EAAO9nB,eAAeH,GAAK,IAAMioB,EAAO5nB,eAAeL,MAO3D4sB,UAAP,SAAiBzkB,GACT6f,GAAQ7f,GACR8f,EAAO4E,YAAY1kB,EAAG8f,EAAO6E,WAAW3kB,KAExC8f,EAAO8E,SAAS5kB,GAChBA,EAAE0U,OAAS,MAMJkQ,SAAP,SAAgB7oB,GACdA,EAAGiZ,GAAKjZ,EAAEqD,EACVrD,EAAGsZ,GAAKtZ,EAAEyR,KAKLkX,YAAP,SAAmB1kB,EAAU6kB,QACT,IAAb7kB,EAAExH,QACTwH,EAAExH,OAAOZ,SAAQ,SAAAmE,GACbA,EAAE2Y,OAAS,EACXoL,EAAO8E,SAAS7oB,GACVA,EAAG+oB,kBAAoB/oB,EAAEqD,EAAIylB,EAAOzlB,EACpCrD,EAAGgpB,kBAAoBhpB,EAAEyR,EAAIqX,EAAOrX,UAG1B,IAAbxN,EAAEpH,QACToH,EAAEpH,OAAOhB,SAAQ,SAAAoD,UAAK8kB,EAAO4E,YAAY1pB,EAAG6pB,SAK7CF,WAAP,SAAkB3kB,UACV6f,GAAQ7f,GACD,CACHZ,EAAGY,EAAEgN,OAAOY,KACZJ,EAAGxN,EAAEgN,OAAOa,MAGT7N,KAMRglB,KAAP,SAAYhlB,EAAiB0F,GACrBma,GAAQ7f,SACgB,IAAbA,EAAExH,QACTwH,EAAExH,OAAOZ,SAAQ,SAAAmE,GACbiE,EAAEgN,OAAOoB,WAAW1I,EAAStG,GAC7BY,EAAEgN,OAAOqB,WAAW3I,EAAS8H,GACvBzR,EAAGiZ,GAAWjZ,EAAG+oB,kBAAoBpf,EAAStG,EAC9CrD,EAAGsZ,GAAWtZ,EAAGgpB,kBAAoBrf,EAAS8H,UAGpC,IAAbxN,EAAEpH,QACToH,EAAEpH,OAAOhB,SAAQ,SAAAoD,UAAK8kB,EAAOkF,KAAKhqB,EAAG0K,QAGnC1F,EAAGgV,GAAKtP,EAAStG,EACjBY,EAAGqV,GAAK3P,EAAS8H,MAMxByX,QAAP,SAAejlB,GACP6f,GAAQ7f,SACgB,IAAbA,EAAExH,QACTwH,EAAExH,OAAOZ,SAAQ,SAAAmE,GACb+jB,EAAOmF,QAAQlpB,UACFA,EAAG+oB,yBACH/oB,EAAGgpB,0BAGA,IAAb/kB,EAAEpH,QACToH,EAAEpH,OAAOhB,QAAQkoB,EAAOmF,UAG5BjlB,EAAE0U,QAAS,KAMZwQ,UAAP,SAAiBllB,GACbA,EAAE0U,OAAS,EACX1U,EAAEgV,GAAKhV,EAAEZ,EAAGY,EAAEqV,GAAKrV,EAAEwN,KAIlB2X,SAAP,SAAgBnlB,GACZA,EAAE0U,QAAS,QCz3BN0Q,0BAaIC,iCAMLxrB,EAAIwrB,SAEHxrB,EAAEumB,YACEA,QAAUvmB,EAAEumB,SAGhBvmB,EAAEwmB,SACEA,KAAOxmB,EAAEwmB,MAGbxmB,EAAEmrB,SACEA,KAAOnrB,EAAEmrB,MAGbnrB,EAAEomB,OACEA,GAAKpmB,EAAEomB,MAGXqF,UAAYvtB,EAAK0sB,UAAY3E,GAAO2E,YACpCc,QAAUxtB,EAAKktB,QAAUnF,GAAOmF,4CAnCzC7E,QAAA,SAAQvoB,OACRwoB,KAAA,eACA2E,KAAA,eACA/E,GAAA,SAAGuF,EAA+BtF,UAAsC1oB,SANzCsoB,ICUtB2F,0BAkBGC,kBAAAA,IAAAA,EAAiBC,KAAKC,2BAEzBF,UAAYA,IACZvF,MAAQuF,EAAUG,SAAS9I,YAAUA,YAAUrR,OAAQqR,YAAUA,YAAUuD,MAAOvD,YAAUA,YAAUhgB,UAEvG+oB,gBAECd,KAAO,eACHA,MACGA,EAAOU,EAAUK,SAASf,OACzBH,OAAO/E,GAAO6E,YACd1E,GAAG,sBAAuBH,GAAO2E,WACjCxE,GAAG,kBAAkB,SAAAjgB,GAClB8f,GAAOkF,KAAKhlB,EAAQ8lB,EAASJ,UAAUvF,OACvC2F,EAAStC,YAEZvD,GAAG,oBAAqBH,GAAOmF,aAGnC7D,UAAUzpB,OAAQ,OAAOqtB,OAKzBgB,KAAKhB,wCAvClB5E,QAAA,SAAQvoB,OACAouB,EAAU,CAAEvvB,KAAMqmB,YAAUllB,EAAEnB,MAAOwM,MAAOrL,EAAEqL,MAAOc,OAAQnM,EAAEmM,aAC9Dmc,MAAM8F,EAAQvvB,MAAMuvB,MAI7B5F,KAAA,2BACSqF,UAAUQ,OAAM,8BAAY5F,mBAqCrCL,GAAA,SAAGuF,EAA+BtF,eAErBC,MAAMF,GADU,iBAAduF,EACOA,EAEAzI,YAAUyI,GAFCtF,GAItB1oB,SArD2BsoB,ICIjCqG,0BAsBGT,gCAEHA,UAAYA,IACZvF,MAAQuF,EAAUG,SAAS9I,YAAUA,YAAUrR,OAAQqR,YAAUA,YAAUuD,MAAOvD,YAAUA,YAAUhgB,UAGvG+oB,gBAECd,KAAO,eACHA,MACGA,EAAOU,EAAUV,OAChBoB,QAAQtG,GAAO6E,YACf1E,GAAG,kBAAmBH,GAAO2E,WAC7BxE,GAAG,kBAAkB,SAAAjgB,GAClB8f,GAAOkF,KAAUhlB,EAAG0lB,EAAUvF,OAC9B2F,EAAStC,YAEZvD,GAAG,gBAAiBH,GAAOmF,aAG/B7D,UAAUzpB,OAAQ,OAAOqtB,EAK9B5D,UAAU,GAAG4E,KAAKhB,wCA7C1B5E,QAAA,SAAQvoB,OACAouB,EAAU,CAAEvvB,KAAMqmB,YAAUllB,EAAEnB,MAAOwM,MAAOrL,EAAEqL,MAAOc,OAAQnM,EAAEmM,aAG9Dmc,MAAM6F,KAAKC,EAAQvvB,KAAWuvB,MAIvC5F,KAAA,sBACQpoB,EAAIT,KAAKkuB,UAAUQ,OAAM,kBAAMG,YAAM/F,cAAUroB,EAAEyrB,aAyCzDzD,GAAA,SAAGuF,EAA+BtF,eAErBC,MAAMF,GADU,iBAAduF,EACOA,EAEAzI,YAAUyI,GAFCtF,GAItB1oB,SA1D6BsoB,ICR3BwG,GAIT,SAAmB3tB,EAAmB6Z,EAAwB9Y,WAA3Cf,YAAmB6Z,gBAAwB9Y,OACrD6sB,UAA2B,IAAb7sB,GAAgD,IAApBA,EAAS/B,QAGnD6uB,GACT,SAAmB7tB,EAAmByG,EAAiBoO,EAAkB/U,EAAiCmlB,YAAjCnlB,IAAAA,EAAoB,eAAamlB,IAAAA,EAAO,cAA9FjlB,SAAmByG,SAAiBoO,YAAkB/U,YAAiCmlB,GAGjG6I,yBAKU3uB,EAAeG,UAAfH,SAAeG,MAC1ByuB,EAAKD,EAAyBE,UAAU7uB,EAAGG,GAC3C2uB,EAAK3uB,EAAEkc,MAAM,GAAG5C,UAChBsV,EAAKJ,EAAyBE,UAAU7uB,EAAG8uB,GAC3CF,EAAG/uB,QAAUkvB,EAAGlvB,aACXA,OAAS+uB,EAAG/uB,YACZoY,GAAK2W,EAAG3W,QACRC,GAAK0W,EAAG1W,QACR8W,UAAW,SAEXnvB,OAASkvB,EAAGlvB,YACZoY,GAAK8W,EAAG9W,QACRC,GAAK/X,EAAEN,OAASkvB,EAAG7W,GAAK6W,EAAGlvB,YAC3BmvB,UAAW,YAGTH,UAAP,SAAoB7uB,EAAQG,WAC5B0B,EAAI7B,EAAEH,OACNf,EAAIqB,EAAEN,OACNovB,EAAQ,CAAEpvB,OAAQ,EAAGoY,IAAK,EAAGC,IAAK,GAClCzS,EAAI,IAAItG,MAAM0C,GACTrC,EAAI,EAAGA,EAAIqC,EAAGrC,IAAK,CACxBiG,EAAEjG,GAAK,IAAIL,MAAML,OACZ,IAAIiC,EAAI,EAAGA,EAAIjC,EAAGiC,OACff,EAAER,KAAOW,EAAEY,GAAI,KACXkD,EAAIwB,EAAEjG,GAAGuB,GAAY,IAANvB,GAAiB,IAANuB,EAAW,EAAI0E,EAAEjG,EAAI,GAAGuB,EAAI,GAAK,EAC3DkD,EAAIgrB,EAAMpvB,SACVovB,EAAMpvB,OAASoE,EACfgrB,EAAMhX,GAAKzY,EAAIyE,EAAI,EACnBgrB,EAAM/W,GAAKnX,EAAIkD,EAAI,QAEpBwB,EAAEjG,GAAGuB,GAAK,SAElBkuB,eAEXC,YAAA,kBACWxvB,KAAKG,QAAU,EAAIH,KAAKM,EAAEqc,MAAM3c,KAAKuY,GAAIvY,KAAKuY,GAAKvY,KAAKG,QAAU,SAQpEsvB,yBA0DUC,EAAuBC,EAAqCC,uBAAAA,IAAAA,EAAuB,uBAAnFF,oBAA4DE,cAzDvD,UA0Df1qB,MAAQwqB,EAAchoB,KAAI,SAACnD,EAAGzE,UAAM,IAAIgvB,GAAYhvB,EAAG6vB,EAASE,UAAUtrB,GAAIorB,EAASG,YAAYvrB,YACnGvD,OAAShB,KAAKkF,MAAM2X,QAAO,SAAAtY,UAAIA,EAAEwqB,aACjC3tB,OAASpB,KAAKkF,MAAM2X,QAAO,SAAArZ,UAAKA,EAAEurB,aAClCgB,KAAO/vB,KAAKgwB,aAAa,UACzBC,KAAOjwB,KAAKgwB,aAAa,UAGzB5uB,OAAOhB,SAAQ,SAAAmE,UAChBA,EAAErC,SAAS9B,SAAQ,SAAAiF,UAAI9E,EAAK2E,MAAcG,GAAGmhB,OAASjiB,aAGrDuP,KAAO,CAAE5R,SAAU,SACnBgD,MAAM9E,SAAQ,SAAAmE,QACS,IAAbA,EAAEiiB,SACTjiB,EAAEiiB,OAASjmB,EAAKuT,KAChBvT,EAAKuT,KAAK5R,SAAStC,KAAK2E,EAAEpD,KAQ9BoD,EAAE2rB,MAAQ,WAITC,YAAcnwB,KAAKkF,MAAMyX,MAAM,QAC/BwT,YAAYhtB,MAAK,SAACyE,EAAGoO,UAAMzV,EAAK6vB,SAASxoB,GAAKrH,EAAK6vB,SAASpa,MAKzChW,KAAKmwB,YAAYxT,MAAM,GAAG5C,UAAU8C,QAAO,SAAArZ,UAAKA,EAAEurB,QACxD3uB,SAAQ,SAAAmE,OAClBmG,EAAIiL,EAAUC,QAClBrR,EAAErC,SAAS9B,SAAQ,SAAAiF,UAAIqF,EAAIA,EAAEgL,MAAMnV,EAAK2E,MAAMG,GAAG2V,SACjDzW,EAAEyW,KAAOtQ,EAAEmL,QAAQtV,EAAKqvB,qBAGxBS,EAAUrwB,KAAKswB,UAAUtwB,KAAK+vB,KAAKroB,KAAI,SAAAgD,UAAIA,EAAEoO,QAC7CyX,EAAUvwB,KAAKswB,UAAUtwB,KAAKiwB,KAAKvoB,KAAI,SAAAgD,UAAIA,EAAEoO,QAG7C0X,EAAOH,EAAQ,GAAII,EAAOJ,EAAQA,EAAQlwB,OAAS,GACnDuwB,EAAOH,EAAQ,GAAII,EAAOJ,EAAQA,EAAQpwB,OAAS,GAGnDywB,EAAS5wB,KAAKiwB,KAAKvoB,KAAI,SAAAgD,SAAS,CAAEsM,GAAIwZ,EAAMtZ,GAAIuZ,EAAMxZ,GAAIvM,EAAEoO,IAAK3B,GAAIzM,EAAEoO,QACtE4B,OAAO6V,EAAQ7oB,KAAI,SAAAvF,SAAS,CAAE6U,GAAIwZ,EAAMtZ,GAAIuZ,EAAMxZ,GAAI9U,EAAGgV,GAAIhV,OAG9D0uB,EAAS7wB,KAAK+vB,KAAKroB,KAAI,SAAArC,SAAS,CAAE2R,GAAI3R,EAAEyT,IAAK5B,GAAI7R,EAAEyT,IAAK7B,GAAIyZ,EAAMvZ,GAAIwZ,MACrEjW,OAAO2V,EAAQ3oB,KAAI,SAAAvF,SAAS,CAAE6U,GAAI7U,EAAG+U,GAAI/U,EAAG8U,GAAIyZ,EAAMvZ,GAAIwZ,OAG3DG,EAAQF,EAAOlW,OAAOmW,GAG1BC,EAAM1wB,SAAQ,SAAA2F,UAAIA,EAAEgrB,MAAQ,WAGvBA,MAAQ,QACR1xB,MAAQ,GAGbuxB,EAAOxwB,SAAQ,SAAAgd,UACXyT,EAAOzwB,SAAQ,SAAAmE,OACP4G,EAAI,IAAI6jB,GAAKzuB,EAAKwwB,MAAM5wB,OAAQoE,EAAEyS,GAAIoG,EAAEnG,IAC5CmG,EAAE2T,MAAMnxB,KAAKuL,GACb5G,EAAEwsB,MAAMnxB,KAAKuL,GACb5K,EAAKwwB,MAAMnxB,KAAKuL,WAGZrL,EAAIS,EAAK4vB,YAAYhwB,OAClBL,KAAM,GAAG,KACRmB,EAAOV,EAAK4vB,YAAYrwB,GACxB4K,EAAIzJ,EAAK+Z,KACTjS,EAAK7C,KAAK+E,IAAIE,EAAEvD,EAAI8C,EAAE0L,MACtBU,EAAK5Q,KAAK+E,IAAIE,EAAE6K,EAAItL,EAAE2L,SACtBtN,EAAK2B,EAAEzB,QAAU,GAAK6N,EAAKpM,EAAExB,SAAW,EAAG,CACrCiC,EAAGlK,KAAOA,gBAOhC6vB,EAAM1wB,SAAQ,SAAC2F,EAAGirB,GAEdzwB,EAAK2E,MAAM9E,SAAQ,SAACmE,EAAGzE,GACnByE,EAAEyW,KAAKjE,kBAAkBhR,EAAEiR,GAAIjR,EAAEkR,GAAIlR,EAAEmR,GAAInR,EAAEoR,IAAI/W,SAAQ,SAAC6wB,EAAW5vB,OAE7D8J,EAAI,IAAI6jB,GAAKzuB,EAAKwwB,MAAM5wB,OAAQ8wB,EAAUrpB,EAAGqpB,EAAUjb,EAAGzR,EAAGwB,GACjExF,EAAKwwB,MAAMnxB,KAAKuL,GAChBpF,EAAEgrB,MAAMnxB,KAAKuL,GACb5G,EAAE2rB,MAAMtwB,KAAKuL,aAKjB+lB,EAAUhrB,KAAK+E,IAAIlF,EAAEkR,GAAKlR,EAAEoR,IAAM,GAClCga,EAAQ,SAACvvB,EAAGC,UAAMqvB,EAAUrvB,EAAE+F,EAAIhG,EAAEgG,EAAI/F,EAAEmU,EAAIpU,EAAEoU,GACpDjQ,EAAEgrB,MAAM5tB,KAAKguB,OACR,IAAIrxB,EAAI,EAAGA,EAAIiG,EAAEgrB,MAAM5wB,OAAQL,IAAK,KACjC2F,EAAIM,EAAEgrB,MAAMjxB,EAAI,GAAIyE,EAAIwB,EAAEgrB,MAAMjxB,GAChC2F,EAAExE,MAAQwE,EAAExE,OAASsD,EAAEtD,MAAQwE,EAAExE,KAAK8tB,MAC1CxuB,EAAKlB,MAAMO,KAAK,CAAEZ,OAAQyG,EAAEtE,GAAIlC,OAAQsF,EAAEpD,GAAIhB,OAAQ+F,KAAK+E,IAAIkmB,EAAM1rB,EAAGlB,qCA1J5E6sB,IAAA,SAAIxvB,UAAYA,EAAE6T,QAAO,SAAC7N,EAAGoO,UAAMpO,EAAIoO,KAAKpU,EAAEzB,UAI9C6vB,aAAA,SAAazpB,WACb8qB,EAAU,GACVC,EAAKtxB,KAAKgB,OAAO2b,MAAM,EAAG3c,KAAKgB,OAAOb,QACnCmxB,EAAGnxB,OAAS,GAAG,KAEdoxB,EAAcD,EAAGzU,QAAO,SAAAtY,UAAIA,EAAEyW,KAAK,UAAYzU,EAAKirB,eAAeF,EAAG,GAAGtW,SACzEyW,EAAM,CACNvsB,MAAOqsB,EACPzY,IAAK9Y,KAAKoxB,IAAIG,EAAY7pB,KAAI,SAAAnD,UAAIA,EAAEyW,KAAK,IAAMzU,UAEnD8qB,EAAQzxB,KAAK6xB,GACbA,EAAIvsB,MAAM9E,SAAQ,SAAAmE,UAAI+sB,EAAGI,OAAOJ,EAAGK,QAAQptB,GAAI,aAEnD8sB,EAAQluB,MAAK,SAACvB,EAAGC,UAAMD,EAAEkX,IAAMjX,EAAEiX,OAC1BuY,KAIHjB,SAAA,SAAS7rB,WACTqtB,EAAQ,EACLrtB,EAAEiiB,SAAWxmB,KAAK8T,MACrB8d,IACArtB,EAAIA,EAAEiiB,cAEHoL,KAIHtB,UAAA,SAAU1uB,MACG,IAAbA,EAAEzB,aACK,CAACyB,EAAE,YAGVmF,EAAMnF,EAAE,GAAKA,EAAE,GACfiwB,EAAO,CAACjwB,EAAE,GAAKmF,EAAM,GAChBjH,EAAI,EAAGA,EAAI8B,EAAEzB,OAAQL,IAC1B+xB,EAAKjyB,MAAMgC,EAAE9B,GAAK8B,EAAE9B,EAAI,IAAM,UAElC+xB,EAAKjyB,KAAKgC,EAAEA,EAAEzB,OAAS,GAAK4G,EAAM,GAC3B8qB,KAwHHC,YAAA,SAAYvtB,OACZwtB,EAAU,CAACxtB,MAGXwtB,EAAQnyB,KADR2E,EAAIA,EAAEiiB,cAEDjiB,IAAMvE,KAAK8T,aACbie,EAAQhY,aAIXiY,wBAAA,SAAwBpwB,EAAGC,WAC3BowB,EAAKjyB,KAAK8xB,YAAYlwB,GAAIswB,EAAKlyB,KAAK8xB,YAAYjwB,GAAI/B,EAAI,EACrDmyB,EAAGnyB,KAAOoyB,EAAGpyB,IAAIA,UAEjB,CAAEqyB,eAAgBF,EAAGnyB,EAAI,GAAIsyB,SAAUH,EAAGtV,MAAM7c,GAAG4a,OAAOwX,EAAGvV,MAAM7c,QAK9EuyB,iBAAA,SAAiBzwB,EAAGC,cACZof,EAAOjhB,KAAKgyB,wBAAwBpwB,EAAGC,GACvCywB,EAAgB,GACpBrR,EAAKmR,SAAShyB,SAAQ,SAAAmE,UAAI+tB,EAAc/tB,EAAEpD,IAAM,UAC5CoxB,EAAYtR,EAAKkR,eAAejwB,SAAS2a,QAAO,SAAAtY,WAAMA,KAAK+tB,aAE/DrR,EAAKmR,SACAvV,QAAO,SAAAtY,UAAIA,EAAEiiB,SAAWvF,EAAKkR,kBAC7B/xB,SAAQ,SAAAmE,UAAIguB,EAAYA,EAAU7X,OAAOnW,EAAEiiB,OAAOtkB,SAAS2a,QAAO,SAAAxX,UAAIA,IAAMd,EAAEpD,UAE5EoxB,EAAU7qB,KAAI,SAAAnD,UAAIV,EAAKqB,MAAMX,SAKjCiuB,eAAP,SAAsBC,EAAQ7qB,EAAGoO,WAEzB0c,EAAY,GACPC,EAAK,EAAGA,EAAKF,EAAOtyB,OAAQwyB,YAC7B7F,EAAQ2F,EAAOE,GACVpa,EAAK,EAAGA,EAAKuU,EAAM3sB,OAAQoY,KAC5BjY,EAASwsB,EAAMvU,IACjBqa,OAASD,EACXryB,EAAER,EAAIyY,EAEFrS,KAAK+E,IADC3K,EAAE,GAAGsH,GAAKtH,EAAE,GAAGsH,IACL,IAChB8qB,EAAU9yB,KAAKU,GAI3BoyB,EAAUvvB,MAAK,SAACvB,EAAGC,UAAMD,EAAE,GAAGgG,GAAK/F,EAAE,GAAG+F,cAGpCirB,EAAe,GACfC,EAAa,KACRhzB,EAAI,EAAGA,EAAI4yB,EAAUvyB,OAAQL,IAAK,KACnCQ,EAAIoyB,EAAU5yB,KACbgzB,GAAc5sB,KAAK+E,IAAI3K,EAAE,GAAGsH,GAAKkrB,EAAWha,KAAO,KAEpD+Z,EAAajzB,KADbkzB,EAAa,CAAEha,IAAKxY,EAAE,GAAGsH,GAAImrB,SAAU,KAG3CD,EAAWC,SAASnzB,KAAKU,UAEtBuyB,KAUJG,UAAP,SAAiBprB,EAAWoO,EAAWyc,EAAQM,EAAUE,EAAQlsB,OACzD3H,EAAI2zB,EAAS5yB,YACbf,GAAK,YACLwF,EAAKmuB,EAASrrB,KAAI,SAAApH,UAAK,IAAI6N,EAAS7N,EAAE,GAAGsH,OACzCgK,EAAK,GACA9R,EAAI,EAAGA,EAAIV,EAAGU,QACd,IAAIuB,EAAI,EAAGA,EAAIjC,EAAGiC,OACfvB,IAAMuB,OACN+nB,EAAK2J,EAASjzB,GAEdozB,EAAK9J,EAAGwJ,OACRO,EAFKJ,EAAS1xB,GAENuxB,OACRQ,GAAQ,EACRC,GAAQ,EAMH,KAALzrB,EACIqrB,EAAOC,EAAIC,KAEP/J,EAAG,GAAGpT,GAAKoT,EAAG,GAAGpT,IACjBod,EAAO/xB,EAAGgyB,EAAOvzB,IAEjBszB,EAAOtzB,EAAGuzB,EAAOhyB,IAIrB4xB,EAAOC,EAAIC,KACP/J,EAAG,GAAGpT,GAAKoT,EAAG,GAAGpT,IACjBod,EAAOtzB,EAAGuzB,EAAOhyB,IAEjB+xB,EAAO/xB,EAAGgyB,EAAOvzB,IAIzBszB,GAAQ,GAERxhB,EAAGhS,KAAK,IAAIkO,EAAWlJ,EAAGwuB,GAAOxuB,EAAGyuB,GAAOtsB,IAI1C,IAAIyK,EAAO5M,EAAIgN,GACrBQ,QACPxN,EAAGxE,SAAQ,SAACmE,EAAGzE,OACPQ,EAAIyyB,EAASjzB,GACbgZ,EAAMvU,EAAE2J,WACZ5N,EAAE,GAAGsH,GAAKtH,EAAE,GAAGsH,GAAKkR,MAChBgU,EAAQ2F,EAAOnyB,EAAEsyB,QACjBtyB,EAAER,EAAI,IAAGgtB,EAAMxsB,EAAER,EAAI,GAAG,GAAG8H,GAAKkR,GAChCxY,EAAER,EAAIgtB,EAAM3sB,OAAS,IAAG2sB,EAAMxsB,EAAER,EAAI,GAAG,GAAG8H,GAAKkR,UAIpDwa,cAAP,SAAqBb,EAAQ7qB,EAAWoO,EAAWid,EAA6ClsB,WACxF8rB,EAAepD,EAAW+C,eAAeC,EAAQ7qB,EAAGoO,GAE/ClW,EAAI,EAAGA,EAAI+yB,EAAa1yB,OAAQL,IAAK,SACtCyzB,EAAKV,EAAa/yB,GAClBqb,EAAS,GACJ9Z,EAAI,EAAGA,EAAIkyB,EAAGR,SAAS5yB,OAAQkB,IAAK,KACrCf,EAAIizB,EAAGR,SAAS1xB,GACpB8Z,EAAOvb,KAAK,CAAEV,KAAM,EAAGoB,EAAGA,EAAGwY,IAAK5S,KAAKG,IAAI/F,EAAE,GAAG0V,GAAI1V,EAAE,GAAG0V,MACzDmF,EAAOvb,KAAK,CAAEV,KAAM,EAAGoB,EAAGA,EAAGwY,IAAK5S,KAAKuE,IAAInK,EAAE,GAAG0V,GAAI1V,EAAE,GAAG0V,MAE7DmF,EAAOhY,MAAK,SAACvB,EAAGC,UAAMD,EAAEkX,IAAMjX,EAAEiX,IAAMlX,EAAE1C,KAAO2C,EAAE3C,YAC7Cua,EAAO,GACP+Z,EAAY,EAChBrY,EAAO/a,SAAQ,SAAAC,GACI,IAAXA,EAAEnB,MACFua,EAAK7Z,KAAKS,EAAEC,GACZkzB,KAEAA,IAEa,GAAbA,IACA/D,EAAWuD,UAAUprB,EAAGoO,EAAGyc,EAAQhZ,EAAMwZ,EAAQlsB,GACjD0S,EAAO,WAavBga,WAAA,SAAiBp0B,EAAeq0B,EAAkB10B,EAA6BC,cACvE00B,EAAat0B,EAAMqI,KAAI,SAAArH,UAAI4D,EAAK6oB,MAAM9tB,EAAOqB,GAAIpB,EAAOoB,OACxDuzB,EAAQnE,EAAWoE,WAAWF,GAC9BlB,EAASkB,EAAWjsB,KAAI,SAAUrH,UAAYovB,EAAWqE,aAAazzB,aAC1EovB,EAAW6D,cAAcb,EAAQ,IAAK,IAAKmB,EAAOF,GAClDjE,EAAW6D,cAAcb,EAAQ,IAAK,IAAKmB,EAAOF,GAClDjE,EAAWsE,eAAetB,EAAQkB,GAC3BlB,KAKJsB,eAAP,SAAsBtB,EAAQkB,GAC1BlB,EAAOryB,SAAQ,SAAC2yB,EAAUjzB,GACX6zB,EAAW7zB,GACNwvB,WACZyD,EAAShZ,UACTgZ,EAAS3yB,SAAQ,SAAU4zB,GACvBA,EAAQja,oBAMjBka,mBAAP,SAA0BC,EAAgBC,OAClCC,EAASluB,KAAKmuB,MAAMH,EAAM,GAAGle,EAAIke,EAAM,GAAGle,EAC1Cke,EAAM,GAAGtsB,EAAIssB,EAAM,GAAGtsB,GACtB0sB,EAASpuB,KAAKmuB,MAAMF,EAAM,GAAGne,EAAIme,EAAM,GAAGne,EAC1Cme,EAAM,GAAGvsB,EAAIusB,EAAM,GAAGvsB,GACtB2sB,EAAOH,EAASE,SAChBC,EAAOruB,KAAKsuB,IAAMD,GAAQruB,KAAKsuB,MAC/BD,EAAOD,EAASF,GAEbG,KAIIjT,OAAP,SAAc1f,EAAGC,EAAGwD,UACfxD,EAAE+F,EAAIhG,EAAEgG,IAAMvC,EAAE2Q,EAAIpU,EAAEoU,IAAMnU,EAAEmU,EAAIpU,EAAEoU,IAAM3Q,EAAEuC,EAAIhG,EAAEgG,IAAO,KAKvD6sB,SAAP,SAAgBC,WAChB9zB,EAAW,GACNd,EAAI,EAAGA,EAAI40B,EAAMv0B,OAAQL,IAAK,KAC/BqL,EAAIupB,EAAM50B,QACe,IAAlBc,EAASuK,EAAEpF,KAAoBnF,EAASuK,EAAEpF,GAAK,IAC1DnF,EAASuK,EAAEpF,GAAGoF,EAAET,IAAK,SAElB,SAAC3E,EAAG2E,eAA6B,IAAhB9J,EAASmF,IAAsBnF,EAASmF,GAAG2E,OAKhEmpB,WAAP,SAAkBx0B,WACVs1B,EAAY,GACP70B,EAAI,EAAGA,EAAIT,EAAMc,OAAS,EAAGL,QAC7B,IAAIuB,EAAIvB,EAAI,EAAGuB,EAAIhC,EAAMc,OAAQkB,IAAK,KAInCoE,EAAGmB,EAAI+a,EAHPthB,EAAIhB,EAAMS,GACV4E,EAAIrF,EAAMgC,GACVuzB,EAAM,IAAI3F,GAAyB5uB,EAAGqE,GAEvB,IAAfkwB,EAAIz0B,SAEJy0B,EAAItF,WAGJ5qB,EAAEqV,UACFrV,EAAE4qB,UAAW,EACbsF,EAAM,IAAI3F,GAAyB5uB,EAAGqE,KAErCkwB,EAAIrc,IAAM,GAAKqc,EAAIpc,IAAM,KACzBoc,EAAIrc,GAAKqc,EAAIz0B,QAAUE,EAAEF,QAAUy0B,EAAIpc,GAAKoc,EAAIz0B,QAAUuE,EAAEvE,QAE7Dw0B,EAAU/0B,KAAK,CAAEmG,EAAGjG,EAAG4K,EAAGrJ,KAG1BuzB,EAAIrc,GAAKqc,EAAIz0B,QAAUE,EAAEF,QAAUy0B,EAAIpc,GAAKoc,EAAIz0B,QAAUuE,EAAEvE,QAM5DsF,EAAIpF,EAAEu0B,EAAIrc,GAAK,GACfoJ,EAAKthB,EAAEu0B,EAAIrc,GAAK,GAChB3R,EAAKlC,EAAEkwB,EAAIpc,GAAK,KAEhB/S,EAAIpF,EAAEu0B,EAAIrc,GAAKqc,EAAIz0B,OAAS,GAC5ByG,EAAKvG,EAAEu0B,EAAIrc,GAAKqc,EAAIz0B,QACpBwhB,EAAKjd,EAAEkwB,EAAIpc,GAAKoc,EAAIz0B,SAEpBsvB,EAAWnO,OAAO7b,EAAGmB,EAAI+a,GACzBgT,EAAU/0B,KAAK,CAAEmG,EAAG1E,EAAGqJ,EAAG5K,IAE1B60B,EAAU/0B,KAAK,CAAEmG,EAAGjG,EAAG4K,EAAGrJ,aAK/BouB,EAAWgF,SAASE,MAMxBb,aAAP,SAAoB7S,YACP4T,EAAU1pB,SACD,CAAEvD,EAAGuD,EAAEvD,EAAGoO,EAAG7K,EAAE6K,WAE7B8e,EAAa,SAAClzB,EAAGC,EAAGwD,UAAMa,KAAK+E,KAAKpJ,EAAE+F,EAAIhG,EAAEgG,IAAMvC,EAAE2Q,EAAIpU,EAAEoU,IAAMnU,EAAEmU,EAAIpU,EAAEoU,IAAM3Q,EAAEuC,EAAIhG,EAAEgG,IAAM,MAC5FmrB,EAAW,GACXnxB,EAAIizB,EAAU5T,EAAK,IACdnhB,EAAI,EAAGA,EAAImhB,EAAK9gB,OAAQL,IAAK,KAC9B+B,EAAIgzB,EAAU5T,EAAKnhB,IAAKuF,EAAIvF,EAAImhB,EAAK9gB,OAAS,EAAI8gB,EAAKnhB,EAAI,GAAK,KAC/DuF,GAAMyvB,EAAWlzB,EAAGC,EAAGwD,KACxB0tB,EAASnzB,KAAK,CAACgC,EAAGC,IAClBD,EAAIC,UAGLkxB,KAKXjG,MAAA,SAAMxsB,EAAWG,cACTzB,EAASgB,KAAKkF,MAAc5E,GAAIrB,EAASe,KAAKkF,MAAczE,QAC3D8xB,UAAYvyB,KAAKqyB,iBAAiBrzB,EAAQC,OAE3C81B,EAAiB,QAChBxC,UAAUnyB,SAAQ,SAAAiC,UAAK0yB,EAAe1yB,EAAElB,IAAMkB,UAC9C2yB,cAAgBh1B,KAAKX,MAAMwd,QAAO,SAAAxc,OAC/BoF,EAAIoH,EAAKkkB,MAAM1wB,EAAErB,QACjBuF,EAAIsI,EAAKkkB,MAAM1wB,EAAEpB,gBACZwG,EAAExE,MAAQwE,EAAExE,KAAKE,MAAM4zB,GACzBxwB,EAAEtD,MAAQsD,EAAEtD,KAAKE,MAAM4zB,UAI7B,IAAIj1B,EAAI,EAAGA,EAAId,EAAOkxB,MAAM/vB,OAAQL,SAGhCk1B,cAAcp1B,KAAK,CACpBZ,OAHIA,EAAOkxB,MAAM,GAAG/uB,GAIpBlC,OAHID,EAAOkxB,MAAMpwB,GAAGqB,GAIpBhB,OAAQ,QAGPL,EAAI,EAAGA,EAAIb,EAAOixB,MAAM/vB,OAAQL,SAGhCk1B,cAAcp1B,KAAK,CACpBZ,OAHIC,EAAOixB,MAAM,GAAG/uB,GAIpBlC,OAHIA,EAAOixB,MAAMpwB,GAAGqB,GAIpBhB,OAAQ,QAwBZ80B,EAhByB,IAAI7U,GAAWpgB,KAAK+wB,MAAM5wB,OAAQH,KAAKg1B,eAJpD,SAAA30B,UAAIA,EAAErB,UACN,SAAAqB,UAAIA,EAAEpB,UACN,SAAAoB,UAAIA,EAAEF,UAaoBugB,+BACtC1hB,EAAOkxB,MAAM,GAAG/uB,GAAIlC,EAAOixB,MAAM,GAAG/uB,IAXtB,SAACsE,EAAGlB,EAAGoB,OACjB/D,EAAIiL,EAAKkkB,MAAMtrB,GAAI5D,EAAIgL,EAAKkkB,MAAMxsB,GAAIc,EAAIwH,EAAKkkB,MAAMprB,GACrDoD,EAAK7C,KAAK+E,IAAI5F,EAAEuC,EAAIhG,EAAEgG,GAAIkP,EAAK5Q,KAAK+E,IAAI5F,EAAE2Q,EAAIpU,EAAEoU,UAEhDpU,EAAEX,OAASjC,GAAU4C,EAAEX,OAASY,EAAEZ,MAAQY,EAAEZ,OAAShC,GAAU4C,EAAEZ,OAASoE,EAAEpE,KACrE,EACJ8H,EAAK,GAAK+N,EAAK,EAAI,IAAO,KASPiD,UAAUrS,KAAI,SAAAd,UAAMiG,EAAKkkB,MAAMnqB,aAC7DquB,EAAWr1B,KAAKI,KAAKkF,MAAMjG,EAAOkC,IAAI+uB,MAAM,IAGrC+E,EAAWpY,QAAO,SAACtY,EAAGzE,WACvBA,EAAIm1B,EAAW90B,OAAS,GAAK80B,EAAWn1B,EAAI,GAAGmB,OAASjC,GAAUuF,EAAEtD,OAASjC,GACxEc,EAAI,GAAKyE,EAAEtD,OAAShC,GAAUg2B,EAAWn1B,EAAI,GAAGmB,OAAShC,SAGjEi2B,aAAP,SAAoBpI,EAAkBqI,EAAsBC,EAAoBC,OAyDpErE,EACAppB,EAAaoO,EAIbsf,EAAcC,EA7DlBjxB,EAAS,CACTkxB,UAAW,KAAO1I,EAAM,GAAG,GAAGllB,EAAI,IAAMklB,EAAM,GAAG,GAAG9W,EAAI,IACxDyf,UAAW,OAEX3I,EAAM3sB,OAAS,MACV,IAAIL,EAAI,EAAGA,EAAIgtB,EAAM3sB,OAAQL,IAAK,KAG/BiJ,GADAnB,GADAopB,EAAKlE,EAAMhtB,IACJ,GAAG8H,GACDopB,EAAG,GAAGppB,EACfkP,GAFad,EAAIgb,EAAG,GAAGhb,GAEdgb,EAAG,GAAGhb,KACflW,EAAIgtB,EAAM3sB,OAAS,EAAG,CAClB+F,KAAK+E,IAAIlC,GAAM,EACfnB,GAAKmB,EAAK7C,KAAK+E,IAAIlC,GAAMosB,EAEzBnf,GAAKc,EAAK5Q,KAAK+E,IAAI6L,GAAMqe,EAE7B7wB,EAAOkxB,WAAa,KAAO5tB,EAAI,IAAMoO,EAAI,QACrCjQ,EAAI+mB,EAAMhtB,EAAI,GACdiM,EAAKhG,EAAE,GAAG6B,EAAGmV,EAAKhX,EAAE,GAAGiQ,EAG3BjN,EAFShD,EAAE,GAAG6B,EAEJmE,EACV+K,EAFS/Q,EAAE,GAAGiQ,EAEJ+G,MAGN7F,EAAIC,EAFJue,EAAQjG,EAAWwE,mBAAmBjD,EAAIjrB,GAAK,EAAI,EAAI,EAGvDG,KAAK+E,IAAIlC,GAAM,GACfmO,EAAKnL,EAAKhD,EAAK7C,KAAK+E,IAAIlC,GAAMosB,EAC9Bhe,EAAK4F,IAEL7F,EAAKnL,EACLoL,EAAK4F,EAAKjG,EAAK5Q,KAAK+E,IAAI6L,GAAMqe,OAE9B/e,EAAKlQ,KAAK+E,IAAIiM,EAAKtP,GACnByO,EAAKnQ,KAAK+E,IAAIkM,EAAKnB,GACvB1R,EAAOkxB,WAAa,KAAOpf,EAAK,IAAMC,EAAK,QAAUqf,EAAQ,IAAMxe,EAAK,IAAMC,EAAK,QAChF,KACCwe,EAAW,CAAC/tB,EAAGoO,GAEf9P,KAAK+E,IAAIlC,GAAM,GAEfusB,EAAe,CADf1tB,GAAKmB,EAAK7C,KAAK+E,IAAIlC,GAAMssB,EACNrf,EAAIof,GACvBG,EAAe,CAAC3tB,EAAGoO,EAAIof,KAGvBE,EAAe,CAAC1tB,EAAIwtB,EADpBpf,GAAKc,EAAK5Q,KAAK+E,IAAI6L,GAAMue,GAEzBE,EAAe,CAAC3tB,EAAIwtB,EAAYpf,IAEpC1R,EAAOkxB,WAAa,KAAO5tB,EAAI,IAAMoO,EAAI,IACrCqf,EAAc,IACd/wB,EAAOmxB,UAAY,KAAOE,EAAS,GAAK,IAAMA,EAAS,GAAK,MAAQL,EAAa,GAAK,IAAMA,EAAa,GACvG,MAAQC,EAAa,GAAK,IAAMA,EAAa,UAOvDxsB,GADAnB,GADAopB,EAAKlE,EAAM,IACJ,GAAGllB,GACDopB,EAAG,GAAGppB,EACfkP,GAFad,EAAIgb,EAAG,GAAGhb,GAEdgb,EAAG,GAAGhb,EACf2f,EAAW,CAAC/tB,EAAGoO,GAEf9P,KAAK+E,IAAIlC,GAAM,GAEfusB,EAAe,CADf1tB,GAAKmB,EAAK7C,KAAK+E,IAAIlC,GAAMssB,EACNrf,EAAIof,GACvBG,EAAe,CAAC3tB,EAAGoO,EAAIof,KAGvBE,EAAe,CAAC1tB,EAAIwtB,EADpBpf,GAAKc,EAAK5Q,KAAK+E,IAAI6L,GAAMue,GAEzBE,EAAe,CAAC3tB,EAAIwtB,EAAYpf,IAEpC1R,EAAOkxB,WAAa,KAAO5tB,EAAI,IAAMoO,EAAI,IACrCqf,EAAc,IACd/wB,EAAOmxB,UAAY,KAAOE,EAAS,GAAK,IAAMA,EAAS,GAAK,MAAQL,EAAa,GAAK,IAAMA,EAAa,GACvG,MAAQC,EAAa,GAAK,IAAMA,EAAa,WAGhDjxB,QC1pBNsxB,yBAEc52B,EAAuBC,eAAvBD,cAAuBC,qBAC1C42B,aAAA,SAAajuB,qBACF1B,KAAKC,KACRyB,EAAE6N,QAAO,SAACpQ,EAAWd,OACXwE,EAAKxE,EAAEhE,EAAKtB,QAAUsF,EAAEhE,EAAKvB,eAC5BqG,EAAI0D,EAAKA,IACjB,4BAiBF+sB,wBAMU5wB,EAAwBC,EAAwB4wB,uBAAAA,IAAAA,EAA0B,cAA1E7wB,aAAwBC,uBAAwB4wB,mBAF9C,iCAqBY,OAlBxBzxB,OAAS,IAAI7E,MAAMq2B,EAASh0B,OAC5B,IAAIhC,EAAI,EAAGA,EAAIg2B,EAASh0B,IAAKhC,OACzBwE,OAAOxE,GAAK,IAAIL,MAAMyF,EAAM/E,QAErC+E,EAAM9E,SAAQ,SAACmE,EAAGzE,iBACEg2B,EAASE,qBAAM,KAAtB3Z,eACgB,IAAV9X,EAAE8X,KAAqB9X,EAAE8X,GAAOnW,KAAKoD,UAEpDzF,EAAKS,OAAO,GAAGxE,GAAKyE,EAAEqD,EACtB/D,EAAKS,OAAO,GAAGxE,GAAKyE,EAAEyR,EACtBnS,EAAKS,OAAO,GAAGxE,GAAKyE,EAAE0xB,gCAI9BC,WAAA,SAAWnwB,UACAA,EAAE8vB,aAAa71B,KAAKsE,WAM/B4P,MAAA,SAAM3H,uBAAAA,IAAAA,EAAqB,SACjBnN,EAAIY,KAAKkF,MAAM/E,OAEjBb,EAAe,IAAI62B,GAEnBn2B,KAAKo2B,uBACLhwB,EAAmBpG,KAAKmF,MAAO7F,EAAc,UAE5C6F,MAAM/E,SAAQ,SAAAC,UAAKA,EAAEF,QAAU8D,EAAK8xB,uBAGnC3L,EAAkB,IAAIhK,GAAWhhB,EAAGY,KAAKmF,OAC3C,SAAA9E,UAAIA,EAAErB,UAAQ,SAAAqB,UAAIA,EAAEpB,UAAQ,SAAAoB,UAAKA,EAAEF,UAASmgB,iBAE1CpY,EAAID,EAAQkB,mBAAmB/J,GAAG,SAACU,EAAGuB,UAAM+oB,EAAetqB,GAAGuB,MAIhE8G,EAAIF,EAAQkB,mBAAmB/J,GAAG,kBAAqB,UACtD+F,MAAM/E,SAAQ,gBAAGpB,IAAAA,OAAQC,IAAAA,cAAakJ,EAAEnJ,GAAQC,GAAUkJ,EAAElJ,GAAQD,GAAU,UAE9Eq3B,QAAU,IAAIpuB,EAAQjI,KAAKsE,OAAQ4D,QACnCmuB,QAAQ1pB,UAAY,UACpB0pB,QAAQluB,EAAIA,EAIbnI,KAAK0G,cACL1G,KAAKq2B,QAAQpqB,QAAU,IAAI2P,EAAwB5b,KAAKkF,MAAO,KAAM,KAAMlF,KAAK0G,aAAasX,wBAE5F,IAAIle,EAAI,EAAGA,EAAIE,KAAKkF,MAAM/E,OAAQL,IAAK,KACpCyE,EAAIvE,KAAKkF,MAAMpF,GACfyE,EAAE2Y,YACGmZ,QAAQxuB,MAAM9H,IAAID,EAAG,CAACyE,EAAEqD,EAAGrD,EAAEyR,EAAGzR,EAAE0xB,gBAI1CI,QAAQ/pB,IAAIC,GACVvM,QAGX8oB,KAAA,gBACSuN,QAAQxuB,MAAMC,YACd,IAAIhI,EAAI,EAAGA,EAAIE,KAAKkF,MAAM/E,OAAQL,IAAK,KACpCyE,EAAIvE,KAAKkF,MAAMpF,GACfyE,EAAE2Y,YACGmZ,QAAQxuB,MAAM9H,IAAID,EAAG,CAACyE,EAAEqD,EAAGrD,EAAEyR,EAAGzR,EAAE0xB,WAGxCj2B,KAAKq2B,QAAQ3pB,0BA5EjBopB,OAAO,CAAC,IAAK,IAAK,KAClBA,IAAIA,EAASE,KAAK71B,YA+EvBg2B,uDACF31B,eAAA,SAAeH,UAAyBA,EAAErB,UAC1C0B,eAAA,SAAeL,UAAyBA,EAAEpB,UAC1CohB,UAAA,SAAUhgB,UAAyBA,EAAEF,UACrC6F,UAAA,SAAU3F,EAAQ0F,GAAa1F,EAAEF,OAAS4F,mIP7EnBuwB,OAELx2B,EADdgiB,EAAIwU,EAAE3Z,MAAM,GAAGxZ,MAAK,SAACvB,EAAGC,UAAMD,EAAEgG,IAAM/F,EAAE+F,EAAI/F,EAAE+F,EAAIhG,EAAEgG,EAAI/F,EAAEmU,EAAIpU,EAAEoU,KAChE5W,EAAIk3B,EAAEn2B,OAENsd,EAAOqE,EAAE,GAAGla,MACX9H,EAAI,EAAGA,EAAIV,GACR0iB,EAAEhiB,GAAG8H,IAAM6V,IADE3d,OAGjBy2B,EAASz2B,EAAI,EACbwI,EAAa,MACjBA,EAAE1I,KAAKkiB,EAPM,IAQTyU,IAAWn3B,EAAI,EACX0iB,EAAEyU,GAAQvgB,IAAM8L,EATX,GASqB9L,GAC1B1N,EAAE1I,KAAKkiB,EAAEyU,QACV,KAECC,EAAQC,EAASr3B,EAAI,EACrBse,EAAOoE,EAAE1iB,EAAI,GAAGwI,MACf9H,EAAIV,EAAI,EAAGU,GAAK,GACbgiB,EAAEhiB,GAAG8H,IAAM8V,EADK5d,SAExB02B,EAAS12B,EAAI,EAGbA,EAAIy2B,IACKz2B,GAAK02B,QAENlV,GAAOQ,EAvBN,GAuBiBA,EAAE0U,GAAS1U,EAAEhiB,KAAO,GAAKA,EAAI02B,SAG5CluB,EAAEnI,OAAS,KAGVmhB,GAAOhZ,EAAEA,EAAEnI,OAAS,GAAImI,EAAEA,EAAEnI,OAAS,GAAI2hB,EAAEhiB,IAAM,IAGjDwI,EAAEnI,QAAU,EAhCf,GAkCDL,GAAawI,EAAE1I,KAAKkiB,EAAEhiB,IAI1B22B,GAAUD,GACVluB,EAAE1I,KAAKkiB,EAAE2U,QACTC,EAAMpuB,EAAEnI,WACZL,EAAI02B,IACK12B,GAAKy2B,QAENjV,GAAOQ,EAAE2U,GAAS3U,EAAEyU,GAASzU,EAAEhiB,KAAO,GAAKA,EAAIy2B,SAG5CjuB,EAAEnI,OAASu2B,KAGVpV,GAAOhZ,EAAEA,EAAEnI,OAAS,GAAImI,EAAEA,EAAEnI,OAAS,GAAI2hB,EAAEhiB,IAAM,IAGjDwI,EAAEnI,QAAU,EArDf,GAuDDL,GAAawI,EAAE1I,KAAKkiB,EAAEhiB,YAG3BwI,+FA6LyByZ,EAAYK,UACrCD,GAAkBJ,EAAGK,EAAGF,GAAqBA,GAAqBN,GAAOA,oCAVhDG,EAAYK,OACxCrV,EAAK6V,GAAoBR,EAAGL,SACzB,CAAEM,GAAItV,EAAGuV,GAAIA,GAAIvV,EAAGsV,sKOhQ3B,SACWza,EACAoO,EACAigB,YAFAruB,IAAAA,EAAY,YACZoO,IAAAA,EAAY,YACZigB,IAAAA,EAAY,UAFZruB,SACAoO,SACAigB,mNPwQqBlU,EAAYK,UACrCD,GAAkBJ,EAAGK,EAAGP,GAAqBA,GAAqBH,GAAOA,yKGvP3DmM,UACd,IAAID,GAAeC,sDHwDO1iB,EAAU2W,EAAYpd,GACvDod,EAAEnF,MAAM,GAAGxZ,MACP,SAACvB,EAAGC,UAAMqE,KAAKmuB,MAAMzyB,EAAEoU,EAAI7K,EAAE6K,EAAGpU,EAAEgG,EAAIuD,EAAEvD,GAAK1B,KAAKmuB,MAAMxyB,EAAEmU,EAAI7K,EAAE6K,EAAGnU,EAAE+F,EAAIuD,EAAEvD,MACzExH,QAAQsE,gDQzEIwpB,UACjBA,GAMT,SAAgBA,UAECA,EAAWyI,SAAqD,OAApCzI,EAAWyI,QAAQpH,MAD9C,QAPIqH,CAAO1I,GACd,IAAID,GAAqBC,GAE7B,IAAIS,GAAuBT,uLC7Bd2I,EAAUnD,EAAkBoD,EAAgBC,UAChEF,EAASG,KAAK9iB,MAAM,EAAG,EAAG,EAAG,IAAI,GAKrC,SAAehP,EAAO9D,EAAQ01B,EAAgBC,GAC1C7xB,EAAM9E,SAAQ,SAAAoI,GACVA,EAAEyuB,WAAkB,CAChBC,KAAM1uB,EAAE0uB,KACR1hB,OAAQhN,EAAEgN,OAAOK,SAASihB,OAGlC11B,EAAOhB,SAAQ,SAAAoI,GACXA,EAAEyuB,WAAkB,CAChBzhB,OAAQhN,EAAEgN,OAAOK,SAASkhB,GAC1B70B,eAA+B,IAAbsG,EAAEpH,OAAyBoH,EAAEpH,OAAOsG,KAAI,SAAArC,UAAIH,EAAM/E,OAASkF,EAAElE,MAAM,IAChFuZ,YAA2B,IAAblS,EAAExH,OAAyBwH,EAAExH,OAAO0G,KAAI,SAAArC,UAAIA,EAAE6B,SAAS,YAG9EiwB,EAAkBjyB,EAAMwV,OAAOtZ,GAAQsG,KAAI,SAACc,EAAG1I,UAC/C0I,EAAEyuB,WAAW91B,GAAKrB,EACX0I,EAAEyuB,qBAEN,IAAIxH,GAAW0H,EAAiB,CACnCrH,YAAa,SAACvrB,UAAWA,EAAErC,UAC3B2tB,UAAW,SAAAtrB,UAAKA,EAAEiR,SACnBshB,EAASC,GAzBKjK,CAAM+J,EAASG,KAAK9xB,QAAS2xB,EAASG,KAAK51B,SAAU01B,EAAQC,GAC5DtD,WAAgBoD,EAASO,WAAW9xB,WAAYouB,GAAU,SAAArzB,UAAIA,EAAErB,OAAOi4B,WAAW91B,MAAI,SAAAd,UAAIA,EAAEpB,OAAOg4B,WAAW91B,qGTgcnGgK,EAAYH,MACjCqa,GAAUla,EAAGH,GAAI,OAAO,KACxBqa,GAAUra,EAAGG,GAAI,OAAO,MACvB,IAAIrL,EAAI,EAAGV,EAAI+L,EAAEhL,OAAQL,EAAIV,IAAKU,EAAG,KAClCyE,EAAI4G,EAAErL,GAAI2F,EAAI0F,EAAErL,EAAI,MACpBskB,GAAW,IAAIhD,GAAY3b,EAAEmC,EAAGnC,EAAEuQ,EAAGzR,EAAEqD,EAAGrD,EAAEyR,GAAIhL,GAAG7K,OAAS,EAAG,OAAO,SAEvE,mCS3aXwmB,EACA3T,EACAqkB,OAGID,EACJzQ,EAAMzhB,MAAM9E,SAAQ,SAACmE,EAAEzE,UAAYyE,EAAG2C,MAAQpH,UAC1CwoB,IACCzM,eAAc,GACd3W,MAAMyhB,EAAMzhB,OACZC,MAAMwhB,EAAMxhB,OACZukB,kBAAiB,SAAUlhB,IACxB4uB,EAAa5uB,GACFpH,OAAOhB,SAAQ,SAAAmE,UAAIA,EAAEuR,QAAUuhB,YAK9Cj4B,EAAIunB,EAAMzhB,MAAM/E,OAChBd,EAAQ,GACRuF,EAAK+hB,EAAMzhB,MAAMyX,MAAM,UAC3B/X,EAAGxE,SAAQ,SAACmE,EAAGzE,UAAYyE,EAAG2C,MAAQpH,KACtCs3B,EAAWh2B,OAAOhB,SAAQ,SAAAoD,OAClB8zB,EAAY9zB,EAAE0D,MAAQ1D,EAAErC,GAAK/B,EACjCwF,EAAGhF,KAAK4D,QACgB,IAAbA,EAAExC,QACTwC,EAAExC,OAAOZ,SAAQ,SAAAmE,UAAKlF,EAAMO,KAAK,CAAEZ,OAAQs4B,EAAWr4B,OAAQsF,EAAE2C,gBAC5C,IAAb1D,EAAEpC,QACToC,EAAEpC,OAAOhB,SAAQ,SAAA6rB,UAAM5sB,EAAMO,KAAK,CAAEZ,OAAQs4B,EAAWr4B,OAAQgtB,EAAG9qB,GAAK/B,UAE/Eg4B,EAAW9xB,WAAWlF,SAAQ,SAAAC,GAC1BhB,EAAMO,KAAK,CAAEZ,OAAQqB,EAAErB,OAAOkI,MAAOjI,OAAQoB,EAAEpB,OAAOiI,gBAItDohB,IACCtV,KAAKA,GACL9N,MAAMN,GACNO,MAAM9F,GACNwc,eAAc,GACd8O,aAAa,IACb1kB,yBAAyB,GACzB8kB,qBAAqB,MACrB7W,MAAM,IAAK,EAAG,EAAG,GAAG,GAKlB,CACH8iB,MACI,IAAI1O,IACHyC,qBAAqB,MACrB/X,KAAKA,GACL6I,eAAc,GACd3W,MAAMyhB,EAAMzhB,OACZC,MAAMwhB,EAAMxhB,OAEZslB,iBAAiB,MACjBE,aAAa,IACb1kB,yBAAyB,GACzByjB,kBAAiB,SAAUlhB,IACxB4uB,EAAa5uB,GACFpH,OAAOhB,SAAQ,SAAUmE,GAChCA,EAAEuR,QAAUuhB,QAEjBnjB,MAAM,GAAI,EAAG,IAAK,GAAG,GAC5BkjB,WAAYA,2Cd+Z4BG,EAAkDrkB,EAAqBE,WAGzGxO,EAAiB2yB,EAAM7vB,KAAI,SAAApH,UAAK,IAAI6N,EAAS7N,EAAEk3B,kBAC/C5lB,EAAmB,GACnBxS,EAAIm4B,EAAMp3B,OACPL,EAAI,EAAGA,EAAIV,EAAI,EAAGU,IAEvB8R,EAAGhS,KAAK,IAAIkO,EAAWlJ,EAAG9E,GAAI8E,EAAG9E,EAAI,IADxBy3B,EAAMz3B,GAC4BkT,KADhBukB,EAAMz3B,EAAI,GACmBkT,MAAQ,QAElEykB,EAAW7yB,EAAG,GAChB8yB,EAAY9yB,EAAGxF,EAAI,GACnBu4B,EAAeJ,EAAM,GAAGvkB,KAAO,EAC/B4kB,EAAgBL,EAAMn4B,EAAI,GAAG4T,KAAO,EACpC6kB,EAAmB,KAAMC,EAAmB,YAC5C5kB,IACA2kB,EAAS,IAAI1pB,EAAS+E,EAA8B,IAAlBukB,EAASxtB,QAC3CrF,EAAGhF,KAAKi4B,GACRjmB,EAAGhS,KAAK,IAAIkO,EAAW+pB,EAAQJ,EAAUE,KAEzCvkB,IACA0kB,EAAS,IAAI3pB,EAASiF,EAA+B,IAAnBskB,EAAUztB,QAC5CrF,EAAGhF,KAAKk4B,GACRlmB,EAAGhS,KAAK,IAAIkO,EAAW4pB,EAAWI,EAAQF,KAEjC,IAAIpmB,EAAO5M,EAAIgN,GACrBQ,QACA,CACH2lB,WAAYnzB,EAAG+X,MAAM,EAAG4a,EAAMp3B,QAAQuH,KAAI,SAAAnD,UAAKA,EAAE2J,cACjDgF,WAAY2kB,EAASA,EAAO3pB,WAAaupB,EAASvpB,WAAaypB,EAC/DvkB,WAAY0kB,EAASA,EAAO5pB,WAAawpB,EAAUxpB,WAAa0pB,8BElKzC/0B,OACvB+B,EAAK/B,EAAG6E,KAAI,SAAAgD,UAAK,IAAIyD,EAASzD,EAAE0L,SAChCxE,EAAK2J,EAAqB1Y,EAAI+B,GAC9ByZ,EAAS,IAAI7M,EAAO5M,EAAIgN,GAC5ByM,EAAOjM,QACPxN,EAAGxE,SAAQ,SAACmE,EAAGzE,UAAM+C,EAAG/C,GAAG8W,WAAWrS,EAAE2J,eACxCtJ,EAAK/B,EAAG6E,KAAI,SAAAgD,UAAI,IAAIyD,EAASzD,EAAE2L,SAC/BzE,EAAK4J,EAAqB3Y,EAAI+B,IAC9ByZ,EAAS,IAAI7M,EAAO5M,EAAIgN,IACjBQ,QACPxN,EAAGxE,SAAQ,SAACmE,EAAGzE,UAAM+C,EAAG/C,GAAG+W,WAAWtS,EAAE2J"}